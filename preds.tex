%Part{Preds, Root = "CLM.MSS"}
%Chapter of Common Lisp Manual.  Copyright 1984, 1988, 1989 Guy L. Steele Jr.

\clearpage\def\pagestatus{FINAL PROOF}

\chapter{Predicates Предикаты}
\label{PREDS}

A \emph{predicate} is a function that tests for some condition involving
its arguments and returns {\false} if the condition is false, or some
non-{\false} value if the condition is true.  One may think of a predicate as
producing a Boolean value, where {\false} stands for \emph{false} and anything
else stands for \emph{true}.  Conditional control structures such as
\cdf{cond},
\cdf{if}, \cdf{when}, and \cdf{unless} test such Boolean values.
We say that a predicate \emph{is true} when it returns a non-{\false} value,
and \emph{is false} when it returns {\false}; that is, it is true or false
according to whether the condition being tested is true or false.

\emph{Предикат} --- это функция, которая проверяет некоторое условие
переданное в аргументах и возвращает {\false}, если условие ложное, или
не-{\false} значение, если условие истинное. Можно рассматривать, что предикат
производит булево значение, где \cd{\false} обозначает \emph{ложь} и все
другое --- \emph{истину}. Условные управляющие структуры, такие как \cdf{cond},
\cdf{if}, \cdf{when} и \cdf{unless} проверяют такие булевы значения.
Мы говорит, что предикат \emph{истеннен}, когда он возвращает не-{\false}
значение, и \emph{ложен}, когда он возвращает {\false}, то есть он истеннен
или ложен в зависимости от того, истинно или ложно проверяемое условие.

By convention, the names of predicates usually end in the letter
\cd{p} (which stands for ``predicate'').
Common Lisp uses a uniform convention in hyphenating names of predicates.
If the name of the predicate is formed by adding a \cd{p} to
an existing name, such as the name of a data type,
a hyphen is placed before the final \cd{p} if and only if there is
a hyphen in the existing name.  For example, \cd{number} begets \cd{numberp}
but \cd{standard-char} begets \cd{standard-char-p}.
On the other hand, if the name of a predicate is formed by adding
a prefixing qualifier to the front of an existing predicate name,
the two names are joined with a hyphen and the presence or absence
of a hyphen before the final \cd{p} is not changed.  For example,
the predicate \cd{string-lessp} has no hyphen before the \cd{p}
because it is the string version of \cdf{lessp} (a MacLisp function
that has been renamed \cdf{<} in Common Lisp).  The name \cd{string-less-p}
would incorrectly imply that it is a predicate that tests for a kind
of object called a \cdf{string-less}, and the name \cd{stringlessp}
would connote a predicate that tests whether something has no strings
(is ``stringless'')!

По соглашению, имена предикатов обычно заканчиваются на букву \cd{p} (которая
обозначает <<предикат>>).
Common Lisp использует единое соглашение для использования дефисов в именах
предикатов. Если имя предиката создано с помощью добавления \cd{p} к уже
существующему имены, такому как имя типа данных, тогда дефис помещается перед
последним \cd{p} тогда и только тогда, когда в исходном имени были
дефисы. Например, \cd{number} становится \cd{numberp}, но \cd{standard-char}
становится \cd{standard-char-p}.
С другой стороны, если имя предиката сформировано добавлением префиксного
спецификатора в начало существующего имени предиката, то два имени соединяются с
помощью дефиса, и наличие или отсутствие перед завершающим \cd{p} не
изменяется. Например, предикат \cd{string-lessp} не содержит дефиса перед
\cd{p}, потому что это строковая версия \cd{lessp} (MacLisp функция, которая
была переименована в \cdf{<} в Common Lisp'е). Имя \cd{string-less-p} было бы
некорректно указывающим на то, что это предикат проверяющий тип объекта
называемого \cd{string-less}, а имя \cd{stringlessp} имело бы смысл того, что
проверяет, отсутствие строк в чем-либо. 

The control structures that test Boolean values only test for
whether or not the value is {\false}, which is considered to be false.  Any
other value is considered to be true.  Often a predicate will return {\false} if
it ``fails'' and some \emph{useful} value if it ``succeeds'';
such a function can be used not only as a test but
also for the useful value provided in case of success.  An example
is \cdf{member}.

Управляющие структуры, которые проверяют булевы значения, проверяют только
является или нет значение {\false}, которое рассматривается как ложное. Любое
другое значение рассматривается как истинное. Часто предикат будет возвращать
{\false}, в случае <<неудачи>> и некоторое \emph{полезное} значение в случае
<<успеха>>. Такие функции могут использоваться не только для проверки, но и
также для использования полезного значения, получаемого в случае
успеха. Например \cdf{member}.

If no better non-{\nil} value is available for the purpose of indicating
success, by convention the symbol \cdf{t} is used as the ``standard''
true value.

Если лучшего, чем не-{\nil} значения, в целях указания успеха не оказалось, по
соглашению в качестве <<стандартного>> значения истины используется символ \cdf{t}.

\section{Logical Values Логические значения}

The names \cdf{nil} and \cdf{t} are constants in Common Lisp.  Although they
are symbols like any other symbols, and appear to be treated
as variables when evaluated, it is not permitted to modify their
values.  See \cdf{defconstant}.

Имена \cdf{nil} и \cdf{t} в Common Lisp'е являются константами. Несмотря на то,
что они являются обычными символами, и мгут использоваться в качестве переменных
при вычислениях, их значения не могут быть изменены. Смотрите \cd{defconstant}.

\begin{defun}[Constant]
nil

The value of {\nil} is always {\nil}.  This object represents the logical
\emph{false} value and also the empty list.  It can also be written \cd{()}.

Значение {\nil} всегда {\nil}. Этот объект обозначает логическую ложь, а также
пустой список. Он также может быть записан, как \cd{()}.
\end{defun}

\begin{defun}[Constant]
t

The value of \cdf{t} is always \cdf{t}.

Значение \cdf{t} всегда \cdf{t}.
\end{defun}

\section{Data Type Predicates Предикаты типов данных}

Perhaps the most important predicates in Lisp are those that deal
with data types;  that is, given a data object one can determine whether
or not it belongs to a given type, or one can compare two type specifiers.

Возможно наиболее важными предикатами в Lisp'е эти предикаты, которые различают
типы данных. То есть позволяют узнать принадлежит ли заданный объект данному 
типу, или могут сравнивать два спецификатора типов.

\subsection{General Type Predicates Общие предикаты типов}

If a data type is viewed as the set of all objects belonging to the type,
then the \cdf{typep} function is a set membership test, while \cdf{subtypep}
is a subset test.

Если тип данных рассматривать, как множество все объектов приндлежащих этому
типу, тогда функция \cdf{typep} проверяет принадлежность множеству, тогда как
\cd{subtypep} --- принадлежность подмножеству.

\begin{defun}[Function]
typep object type

\cdf{typep} is a predicate that
is true if \emph{object} is of type \emph{type}, and is false otherwise.
Note that an object can be ``of'' more than one type, since one type can
include another.  The \emph{type} may be any of the type specifiers
mentioned in chapter~\ref{DTSPEC} \emph{except} that it may not
be or contain a type specifier list whose first element is \cdf{function}
or \cdf{values}.
A specifier of the form \cd{(satisfies \emph{fn})} is handled simply
by applying the function \emph{fn} to \emph{object}
(see \cdf{funcall}); the \emph{object} is considered
to be of the specified type if the result is not {\false}.

\cdf{typep} является предикатом, которые истенен, если объект \emph{object}
принадлежит типу \emph{type}, и ложен в противном случае.
Следует отметить что объект может принадлежать нескольким типам, так как один
тип может включать другой. \emph{type} может быть любым спецификатором типа,
описанным в главе~\ref{DTSPEC}, за исключением того, что он не может быть или
включать список спецификатор типа, у которого первый элемент равен
\cdf{function} или \cdf{values}.
Спецификатор формы \cd{(satisfies \emph{fn})} обрабатывается просто как применение
функции \emph{fn} к объекту \emph{object} (смотрите \cdf{funcall}). Объект
\emph{object} принадлежит заданному типу, если результат не равен {\false}.

\begin{new}
X3J13 voted in January 1989
\issue{ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS}
to change \cdf{typep} to give specialized
\cdf{array} and \cdf{complex} type specifiers the same meaning for
purposes of type discrimination as they have for declaration purposes.
Of course, this also applies to such type specifiers as \cdf{vector}
and \cdf{simple-array}
(see section~\ref{SPECIALIZED-TYPE-SPECIFIER-SECTION}).
Thus
\begin{lisp}
(typep foo '(array bignum))
\end{lisp}
in the first edition asked the question, Is \cdf{foo} an array
specialized to hold bignums? but under the new interpretation
asks the question, Could the array \cdf{foo} have resulted from
giving \cdf{bignum} as the \cd{:element-type} argument
to \cdf{make-array}?
\end{new}
\end{defun}

\begin{defun}[Function]
subtypep type1 type2

The arguments must be type specifiers that are acceptable to \cdf{typep}.
The two type specifiers are compared; this predicate is true
if \emph{type1} is definitely a (not necessarily proper) subtype of \emph{type2}.
If the result is {\false}, however, then \emph{type1} may or may not be a subtype of
\emph{type2} (sometimes it is impossible to tell, especially when
\cdf{satisfies} type specifiers are involved).
A second returned value indicates the certainty of the result;
if it is true, then the first value is an accurate indication
of the subtype relationship.  Thus there are three possible
result combinations:
\begin{tabbing}
~~~~~~~~\=~~~~~~~~\=\kill
{\true}\>{\true}\>\emph{type1} is definitely a subtype of \emph{type2} \\
{\false}\>{\true}\>\emph{type1} is definitely not a subtype of \emph{type2} \\
{\false}\>{\false}\>\cdf{subtypep} could not determine the relationship
\end{tabbing}

Аргументы должны быть спецификаторами типов, но только те которые могут
использоваться и для \cdf{typep}.
Два спецификатора типа сравниваются. Данные предикат истенен, если
тип \emph{type1} точно является () подтипом типа \emph{type2}.
Если результат {\false}, тогда тип \emph{type1} может быть, а может и не быть
подтипом типа \emph{type2} (иногда это невозможно оределить, особенно когда
используется тип \cdf{satisfies}).
Второе возвращаемое значение указывает на точность результата. Если оно является
истиной, значит первое значение указывает на точную принадлежность типов. Таким
образом возможны следующие комбинации результатов:
\begin{tabbing}
~~~~~~~~\=~~~~~~~~\=\kill
{\true}\>{\true}\>\emph{type1} точно является подтипом \emph{type2} \\
{\false}\>{\true}\>\emph{type1} точно не является подтипом \emph{type2} \\
{\false}\>{\false}\>\cdf{subtypep} не может определить отношение
\end{tabbing}

\begin{new}
X3J13 voted in January 1989
\issue{SUBTYPEP-TOO-VAGUE}
to place certain requirements upon the implementation of \cdf{subtypep},
for it noted that implementations in many cases simply ``give up''
and return the two values \cdf{nil} and \cdf{nil} when in fact it would have been
possible to determine the relationship between the given types.
The requirements are as follows, where it is understood that a type specifier \emph{s}
\emph{involves} a type specifier \emph{u} if either \emph{s} contains an occurrence of \emph{u}
directly or \emph{s} contains a type specifier \emph{w} defined by \cdf{deftype} whose
expansion involves \emph{u}.
\begin{itemize}
\item \cdf{subtypep} is not permitted to return a second value of \cdf{nil}
unless one or both of its arguments involves \cdf{satisfies},
\cdf{and}, \cdf{or}, \cdf{not}, or \cdf{member}.
\item \cdf{subtypep} should signal an error when one or both of its arguments
involves \cdf{values} or the list form of the \cdf{function} type specifier.
\item \cdf{subtypep} must always return the two values \cdf{t} and \cdf{t}
in the case where its arguments, after expansion of specifiers
defined by \cdf{deftype}, are \cdf{equal}.
\end{itemize}
In addition, X3J13 voted to clarify that in some cases
the relationships between types
as reflected by \cdf{subtypep} may be implementation-specific.
For example, in an implementation supporting only one type of
floating-point number, \cd{(subtypep 'float 'long-float)} would return
\cdf{t} and \cdf{t}, since the two types would be identical.

Note that \cdf{satisfies} is an exception because relationships between
types involving \cdf{satisfies} are undecidable in general, but (as X3J13 noted)
\cdf{and}, \cdf{or}, \cdf{not}, and \cdf{member} are merely very messy to deal
with.  In all likelihood these will not be addressed unless and
until someone is willing to write a careful specification that covers
all the cases for the processing of these type
specifiers by \cdf{subtypep}.  The requirements stated above were easy
to state and probably suffice for most cases of interest.
\end{new}

\begin{new}
X3J13 voted in January 1989
\issue{ARRAY-TYPE-ELEMENT-TYPE-SEMANTICS}
to change \cdf{subtypep} to give specialized
\cdf{array} and \cdf{complex} type specifiers the same meaning for
purposes of type discrimination as they have for declaration purposes.
Of course, this also applies to such type specifiers as \cdf{vector}
and \cdf{simple-array}
(see section~\ref{SPECIALIZED-TYPE-SPECIFIER-SECTION}).

If \emph{A} and \emph{B} are type specifiers (other than \cdf{*}, which technically
is not a type specifier anyway), then \cd{(array~\emph{A})}
and \cd{(array~\emph{B})} represent the same type in a given implementation
if and only if they denote arrays
of the same specialized representation in that implementation;
otherwise they are disjoint.
To put it another way, they represent the same type
%(and otherwise are disjoint)
if and only if
\cd{(upgraded-array-element-type~'\emph{A})} and
\cd{(upgraded-array-element-type~'\emph{B})} are the same type.
Therefore
\begin{lisp}
(subtypep '(array \emph{A}) '(array \emph{B}))
\end{lisp}
is true if and only if
\cd{(upgraded-array-element-type~'\emph{A})}
is the same type as
\cd{(upgraded-array-element-type~'\emph{B})}.

The \cdf{complex} type specifier is treated in a similar but subtly different
manner.
If \emph{A} and \emph{B} are two type specifiers (but not \cdf{*}, which technically
is not a type specifier anyway), then \cd{(complex~\emph{A})}
and \cd{(complex~\emph{B})} represent the same type in a given implementation
if and only if they refer to complex numbers
of the same specialized representation in that implementation;
otherwise they are disjoint.
Note, however, that there is no function called \cdf{make-complex} that
allows one to specify a particular element type (then to be upgraded);
instead, one must describe specialized complex numbers in terms of
the actual types of the parts from which they were constructed.
There is no number of type (or rather, \emph{representation\/})
\cdf{float} as such; there are only numbers of type \cdf{single-float},
numbers of type \cdf{double-float},
and so on.  Therefore we want \cd{(complex single-float)} to
be a subtype of \cd{(complex float)}.

The rule, then, is that \cd{(complex~\emph{A})}
and \cd{(complex~\emph{B})} represent the same type (and otherwise are disjoint)
in a given implementation
if and only if \emph{either} the type \emph{A} is a subtype of \emph{B}, \emph{or}
\cd{(upgraded-complex-part-type~'\emph{A})} and
\cd{(upgraded-complex-part-type~'\emph{B})} are the same type.
In the latter case \cd{(complex~\emph{A})}
and \cd{(complex~\emph{B})} in fact refer to the same specialized representation.
Therefore
\begin{lisp}
(subtypep '(complex \emph{A}) '(complex \emph{B}))
\end{lisp}
is true if and only if the results of
\cd{(upgraded-complex-part-type~'\emph{A})} and
\cd{(upgraded-complex-part-type~'\emph{B})} are the same type.

Under this interpretation
\begin{lisp}
(subtypep '(complex single-float) '(complex float))
\end{lisp}
must be true in all implementations; but
\begin{lisp}
(subtypep '(array single-float) '(array float))
\end{lisp}
is true only in implementations that do not have a specialized array representation
for \cdf{single-float} elements distinct from that for \cdf{float} elements in
general.
\end{new}
\end{defun}

\subsection{Specific Data Type Predicates Специальные предикаты типов}

The following predicates test for individual data types.

Следующие предикаты осуществляют проверку определенных типов данных.

\begin{defun}[Function]
null object

\cdf{null} is true if its argument is {\emptylist},
and otherwise is false.
This is the same operation performed by the function \cdf{not};
however, \cdf{not} is normally used to invert a Boolean value,
whereas \cdf{null} is normally used to test for an empty list.  The programmer
can therefore express \emph{intent} by the choice of function name.
\begin{lisp}
(null x) \EQ\ (typep x 'null) \EQ\ (eq x '{\emptylist})
\end{lisp}

\cdf{null} является истиной, если аргумент является {\emptylist}, иначе является
ложью. Похожая опреация производится \cdf{not}, однако \cdf{not} испольуется для
инвертации булевых значение, тогда как \cdf{null} используется для проверки
того, пустой ли список. Таким образом программист может выразить цели выбрав
нужное имя функции.
\begin{lisp}
(null x) \EQ\ (typep x 'null) \EQ\ (eq x '{\emptylist})
\end{lisp}
\end{defun}

\begin{defun}[Function]
symbolp object

\cdf{symbolp} is true if its argument is a symbol,
and otherwise is false.
\begin{lisp}
(symbolp x) \EQ\ (typep x 'symbol)
\end{lisp}

\cdf{symbolp} is true if its argument is a symbol,
and otherwise is false.
\begin{lisp}
(symbolp x) \EQ\ (typep x 'symbol)
\end{lisp}

\cdf{symbolp} является истиной, если ее аргумент является символом, в противном
случае является ложью.
\begin{lisp}
(symbolp x) \EQ\ (typep x 'symbol)
\end{lisp}

\beforenoterule
\begin{incompatibility}
The Interlisp equivalent of \cdf{symbolp} is
called \cdf{litatom}.
\end{incompatibility}
\afternoterule
\end{defun}

\begin{defun}[Function]
atom object

The predicate \cdf{atom} is true if its argument is not a cons,
and otherwise is false.
Note that \cd{(atom '{\emptylist})} is true, because {\emptylist}$\;\equiv\;${\nil}.
\begin{lisp}
(atom x) \EQ\ (typep x 'atom) \EQ\ (not (typep x 'cons))
\end{lisp}

Предикат \cdf{atom} является истиной, если аргумент не является cons-ячейкой, в
противном случае является ложью.
Следует отметить \cd{(atom '{\emptylist})} являет истиной, потому что
{\emptylist}$\;\equiv\;${\nil}.
\begin{lisp}
(atom x) \EQ\ (typep x 'atom) \EQ\ (not (typep x 'cons))
\end{lisp}

\beforenoterule
\begin{incompatibility}
In some Lisp dialects, notably Interlisp,
only symbols and numbers are considered to be atoms; arrays
and strings are considered to be neither atoms nor lists (conses).
\end{incompatibility}
\afternoterule
\end{defun}

\begin{defun}[Function]
consp object

The predicate \cdf{consp} is true if its argument is a cons,
and otherwise is false.
Note that the empty list is not a cons, so
\cd{(consp '{\emptylist})} \EQ\ \cd{(consp '{\nil})} \EV\ {\nil}.
\begin{lisp}
(consp x) \EQ\ (typep x 'cons) \EQ\ (not (typep x 'atom))
\end{lisp}

Предикат \cdf{consp} является истиной, если его аргумент является cons-ячейкой,
в противном случае является ложью.
Следует отметить, пустой список не является cons-ячейкой, так 
\cd{(consp '{\emptylist})} \EQ\ \cd{(consp '{\nil})} \EV\ {\nil}. 
\begin{lisp}
(consp x) \EQ\ (typep x 'cons) \EQ\ (not (typep x 'atom))
\end{lisp}

\beforenoterule
\begin{incompatibility}
Some Lisp implementations call this function
\cdf{pairp} or \cdf{listp}.  The name \cdf{pairp} was rejected for Common Lisp
because it emphasizes too strongly the dotted-pair notion rather than the
usual usage of conses in lists.  On the other hand, \cdf{listp} too strongly
implies that the cons is in fact part of a list, which after all it might
not be; moreover, {\emptylist} is a list, though not a cons.
The name \cdf{consp} seems to be the appropriate compromise.
\end{incompatibility}
\afternoterule
\end{defun}

\begin{defun}[Function]
listp object

\cdf{listp} is true if its argument is a cons or the empty list {\emptylist},
and otherwise is false.  It does not check for whether the list
is a ``true list'' (one terminated by {\nil}) or a ``dotted list''
(one terminated by a non-null atom).
\begin{lisp}
(listp x) \EQ\ (typep x 'list) \EQ\ (typep x '(or cons null))
\end{lisp}

\cdf{listp} является истиной, если его аргумент является cons-ячейкой или пустым
список {\emptylist}, в противном случае является ложью. Она не проверяет
является ли <<список Ъ (true list)>> (завершающийся {\nil}) или <<dotted>>
(заверщающийся не-null атомом).
\begin{lisp}
(listp x) \EQ\ (typep x 'list) \EQ\ (typep x '(or cons null))
\end{lisp}
\end{defun}

\begin{defun}[Function]
numberp object

\cdf{numberp} is true if its argument is any kind of number,
and otherwise is false.
\begin{lisp}
(numberp x) \EQ\ (typep x 'number)
\end{lisp}

\cdf{numberp} является истиной, если аргумент любой вид числа, в
противном случае является ложью.
\begin{lisp}
(numberp x) \EQ\ (typep x 'number)
\end{lisp}
\end{defun}

\begin{defun}[Function]
integerp object

\cdf{integerp} is true if its argument is an integer, and otherwise
is false.
\begin{lisp}
(integerp x) \EQ\ (typep x 'integer)
\end{lisp}

\emph{integerp} является истиной, если аргумент целое число, в противном
случае является ложью.
\begin{lisp}
(integerp x) \EQ\ (typep x 'integer)
\end{lisp}

\beforenoterule
\begin{incompatibility}
In MacLisp this is called \cdf{fixp}.
Users have been confused as to whether this meant \cdf{integerp}
or \cdf{fixnump}, and so the name \cdf{integerp} has been adopted here.
\end{incompatibility}
\afternoterule
\end{defun}

\begin{defun}[Function]
rationalp object

\cdf{rationalp} is true if its argument is a rational number (a ratio or
an integer), and otherwise is false.
\begin{lisp}
(rationalp x) \EQ\ (typep x 'rational)
\end{lisp}

\cdf{rationalp} является истиной, если аргумент рациональное число (дробь или
целое), в противном случае является ложью.
\begin{lisp}
(rationalp x) \EQ\ (typep x 'rational)
\end{lisp}
\end{defun}

\begin{defun}[Function]
floatp object

\cdf{floatp} is true if its argument is a floating-point number,
and otherwise is false.
\begin{lisp}
(floatp x) \EQ\ (typep x 'float)
\end{lisp}
\cdf{floatp} является истиной, если аргумент число с плавающей точкой, в
противном случае является ложью.
\begin{lisp}
(floatp x) \EQ\ (typep x 'float)
\end{lisp}
\end{defun}


\begin{newer}
\begin{defun}[Function]
realp object

X3J13 voted in March 1989 \issue{REAL-NUMBER-TYPE} to add the function \cdf{realp}.
\cdf{realp} is true if its argument is a real number,
and otherwise is false.
\begin{lisp}
(realp x) \EQ\ (typep x 'real)
\end{lisp}
\end{defun}
\end{newer}

\begin{defun}[Function]
complexp object

\cdf{complexp} is true if its argument is a complex number,
and otherwise is false.
\begin{lisp}
(complexp x) \EQ\ (typep x 'complex)
\end{lisp}

\emph{complexp} является истиной, если аргумент комплексное число, в противном
случае является ложью.
\begin{lisp}
(complexp x) \EQ\ (typep x 'complex)
\end{lisp}
\end{defun}

\begin{defun}[Function]
characterp object

\cdf{characterp} is true if its argument is a character,
and otherwise is false.
\begin{lisp}
(characterp x) \EQ\ (typep x 'character)
\end{lisp}

\cdf{characterp} является истиной, если аргумент строковый символ, иначе
является ложью.
\begin{lisp}
(characterp x) \EQ\ (typep x 'character)
\end{lisp}
\end{defun}

\begin{defun}[Function]
stringp object

\cdf{stringp} is true if its argument is a string,
and otherwise is false.
\begin{lisp}
(stringp x) \EQ\ (typep x 'string)
\end{lisp}

\cdf{stringp} является истиной, если аргумент строка, иначе является ложью.
\begin{lisp}
(stringp x) \EQ\ (typep x 'string)
\end{lisp}
\end{defun}

\begin{defun}[Function]
bit-vector-p object

\cdf{bit-vector-p} is true if its argument is a bit-vector,
and otherwise is false.
\begin{lisp}
(bit-vector-p x) \EQ\ (typep x 'bit-vector)
\end{lisp}

\cdf{bit-vector-p} является истиной, если аргумет битовый вектор, иначе является ложью.
\begin{lisp}
(bit-vector-p x) \EQ\ (typep x 'bit-vector)
\end{lisp}
\end{defun}

\begin{defun}[Function]
vectorp object

\cdf{vectorp} is true if its argument is a vector,
and otherwise is false.
\begin{lisp}
(vectorp x) \EQ\ (typep x 'vector)
\end{lisp}

\cdf{vectorp} является истиной, если аргумент вектор, иначе является ложью.
\begin{lisp}
(vectorp x) \EQ\ (typep x 'vector)
\end{lisp}
\end{defun}

\begin{defun}[Function]
simple-vector-p object

\cdf{vectorp} is true if its argument is a simple general vector,
and otherwise is false.
\begin{lisp}
(simple-vector-p x) \EQ\ (typep x 'simple-vector)
\end{lisp}

\cdf{vectorp} является истиной, если аргумент простой общий вектор, иначе
является ложью.
\begin{lisp}
(simple-vector-p x) \EQ\ (typep x 'simple-vector)
\end{lisp}
\end{defun}

\begin{defun}[Function]
simple-string-p object

\cdf{simple-string-p} is true if its argument is a simple string,
and otherwise is false.
\begin{lisp}
(simple-string-p x) \EQ\ (typep x 'simple-string)
\end{lisp}

\cdf{simple-string-p} является истиной, если аргумент простая строка, иначе
является ложью.
\begin{lisp}
(simple-string-p x) \EQ\ (typep x 'simple-string)
\end{lisp}
\end{defun}

\begin{defun}[Function]
simple-bit-vector-p object

\cdf{simple-bit-vector-p} is true if its argument is a simple bit-vector,
and otherwise is false.
\begin{lisp}
(simple-bit-vector-p x) \EQ\ (typep x 'simple-bit-vector)
\end{lisp}

\cdf{simple-bit-vector-p} является истиной, если аргумент простой битовый
вектор, иначе является ложью.
\begin{lisp}
(simple-bit-vector-p x) \EQ\ (typep x 'simple-bit-vector)
\end{lisp}
\end{defun}

\begin{defun}[Function]
arrayp object

\cdf{arrayp} is true if its argument is an array,
and otherwise is false.
\begin{lisp}
(arrayp x) \EQ\ (typep x 'array)
\end{lisp}

\cdf{arrayp} является истиной, если аргумент массив, иначе является ложью.
\begin{lisp}
(arrayp x) \EQ\ (typep x 'array)
\end{lisp}
\end{defun}

\begin{defun}[Function]
packagep object

\cdf{packagep} is true if its argument is a package,
and otherwise is false.
\begin{lisp}
(packagep x) \EQ\ (typep x 'package)
\end{lisp}

\cdf{packagep} является истиной, если аргумент является пакетом, иначе является
ложью.
\begin{lisp}
(packagep x) \EQ\ (typep x 'package)
\end{lisp}
\end{defun}

\begin{defun}[Function]
functionp object

\begin{obsolete}
\cdf{functionp} is true if its argument is suitable for applying
to arguments, using for example the \cdf{funcall} or \cdf{apply} function.
Otherwise \cdf{functionp} is false.

\cdf{functionp} is always true of symbols, lists whose \emph{car}
is the symbol \cdf{lambda}, any value returned by the \cdf{function}
special form, and any values returned by the function \cdf{compile}
when the first argument is {\nil}.
\end{obsolete}
\begin{newer}
X3J13 voted in June 1988 \issue{FUNCTION-TYPE}
to define
\begin{lisp}
(functionp x) \EQ\ (typep x 'function)
\end{lisp}
Because the vote also specifies that types \cdf{cons} and \cdf{symbol} are disjoint
from the type \cdf{function}, this is an incompatible change;
now \cdf{functionp} is in fact always false of symbols and lists.
\end{newer}
\end{defun}

\begin{defun}[Function]
compiled-function-p object

\cdf{compiled-function-p} is true if its argument is any compiled code object,
and otherwise is false.
\begin{lisp}
(compiled-function-p x) \EQ\ (typep x 'compiled-function)
\end{lisp}

\cdf{compiled-function-p} является истиной, если аргумент скомпилированный
объект кода,  иначе является ложью.
\begin{lisp}
(compiled-function-p x) \EQ\ (typep x 'compiled-function)
\end{lisp}
\end{defun}

\begin{obsolete}
\begin{defun}[Function]
commonp object

\cdf{commonp} is true if its argument is any standard Common Lisp data type,
and otherwise is false.
\begin{lisp}
(commonp x) \EQ\ (typep x 'common)
\end{lisp}

\cdf{commonp} является истиной, если аргумент какой-либо стандартный тип данных
Common Lisp'а, иначе является ложью.
\begin{lisp}
(commonp x) \EQ\ (typep x 'common)
\end{lisp}
\end{defun}
\end{obsolete}

\begin{newer}
X3J13 voted in March 1989
\issue{COMMON-TYPE}
to remove the predicate \cdf{commonp} (and the type \cdf{common}) from the
language.
\end{newer}

\medskip

See also \cdf{standard-char-p}, \cdf{string-char-p},
\cdf{streamp}, \cdf{random-state-p},
\cdf{readtablep},
\cdf{hash-table-p}, and \cdf{pathnamep}.

Смотрите также \cdf{standard-char-p}, \cdf{string-char-p},
\cdf{streamp}, \cdf{random-state-p},
\cdf{readtablep},
\cdf{hash-table-p} и \cdf{pathnamep}.

\section{Equality Predicates Предикаты равенства}

Common Lisp provides a spectrum of predicates for testing for equality of
two objects: \cdf{eq} (the most specific), \cdf{eql}, \cdf{equal}, and \cdf{equalp}
(the most general).  \cdf{eq} and \cdf{equal} have the meanings traditional
in Lisp.  \cdf{eql} was added because it is frequently needed, and
\cdf{equalp} was added primarily in order to have a version of \cdf{equal}
that would ignore type differences when comparing numbers
and case differences when comparing characters.
If two objects satisfy any one of these equality predicates,
then they also satisfy all those that are more general.

Common Lisp предоставляет спектр предикатов для проверки равенства двух
объектов:  \cdf{eq} (наиболее частный), \cdf{eql}, \cdf{equal} и \cdf{equalp}
(наиболее общий). \cdf{eq} и \cdf{equal} имеют значения традиционные в
Lisp'е. \cdf{eql} был добавлен, потому что он часто необходим, и \cdf{equalp}
был добавлен преимущественно, как версия \cdf{equal}, которая игнорирует
различия типов при сравнении двух чисел и различия регистров при сравнении
строковых символов.
Если два объекта удовлетворяют любому из этих предикатов, то они
также удовлетворяют всем тем, которые носят более общий характер.

\begin{defun}[Function]
eq x y

\cd{(eq \emph{x} \emph{y})} is true
if and only if \emph{x} and \emph{y} are the same identical object.
(Implementationally, \emph{x} and \emph{y} are usually
\cdf{eq} if and only if they address the same identical memory location.)

\cd{(eq \emph{x} \emph{y})} является истиной тогда и только тогда, когда,
\emph{x} и \emph{y} являются идентичными объектами.
(В реализациях, \emph{x} и \emph{y} обычно равны \cdf{eq} тогда и только
тогда, когда обращаются к одной ячейке памяти.)

It should be noted that things that print the same are not necessarily \cdf{eq}
to each other.  Symbols with the same print name usually are \cdf{eq} to
each other because of the use of the \cdf{intern} function.
However, numbers with the same value
need not be \cdf{eq}, and two similar lists are usually not \cdf{eq}.
For example:

\begin{lisp}
(eq 'a 'b) {\rm is false.} \\
(eq 'a 'a) {\rm is true.} \\
(eq 3 3) {\rm might be true or false, depending on the implementation.} \\
(eq 3 3.0) {\rm is false.} \\
(eq 3.0 3.0) {\rm might be true or false, depending on the implementation.} \\
(eq \#c(3 -4) \#c(3 -4)) \\
~~{\rm might be true or false, depending on the implementation.} \\
(eq \#c(3 -4.0) \#c(3 -4)) {\rm is false.} \\
(eq (cons 'a 'b) (cons 'a 'c)) {\rm is false.} \\
(eq (cons 'a 'b) (cons 'a 'b)) {\rm is false.} \\
(eq '(a . b) '(a . b)) {\rm might be true or false.} \\
(progn (setq x (cons 'a 'b)) (eq x x)) {\rm is true.} \\
(progn (setq x '(a . b)) (eq x x)) {\rm is true.} \\
(eq \#{\Xbackslash}A \#{\Xbackslash}A) {\rm might be true or false, depending on the implementation.} \\
(eq "Foo" "Foo") {\rm might be true or false.} \\
(eq "Foo" (copy-seq "Foo")) {\rm is false.} \\
(eq "FOO" "foo") {\rm is false.}
\end{lisp}

Необходимо отметить, что вещи, которые выводят одно и то же, необязательно равны
\cdf{eql} друг другу. Символы с одинаковым именем обычно равны \cdf{eq} друг
другу, потому что используется функция \cdf{intern}.
Однако, одинаковые значения чисел могут быть не равны \cdf{eq}, и два похожих
списка обычно не равны \cdf{eq}.
Например:

\begin{lisp}
(eq 'a 'b) \textrm{ложь} \\
(eq 'a 'a) \textrm{истина} \\
(eq 3 3) \textrm{может быть истина или ложь, в зависимости от реализации} \\
(eq 3 3.0) \textrm{ложь} \\
(eq 3.0 3.0) \textrm{может быть истина или ложь, в зависимости от реализации} \\
(eq \#c(3 -4) \#c(3 -4)) \\
~~\textrm{может быть истина или ложь, в зависимости от реализации} \\
(eq \#c(3 -4.0) \#c(3 -4)) \textrm{ложь} \\
(eq (cons 'a 'b) (cons 'a 'c)) \textrm{ложь} \\
(eq (cons 'a 'b) (cons 'a 'b)) \textrm{ложь} \\
(eq '(a . b) '(a . b)) \textrm{может быть истина или ложь} \\
(progn (setq x (cons 'a 'b)) (eq x x)) \textrm{истина} \\
(progn (setq x '(a . b)) (eq x x)) \textrm{истина} \\
(eq \#{\Xbackslash}A \#{\Xbackslash}A) \textrm{может быть истина или ложь, в зависимости от реализации} \\
(eq "Foo" "Foo") \textrm{может быть истина или ложь} \\
(eq "Foo" (copy-seq "Foo")) \textrm{ложь} \\
(eq "FOO" "foo") \textrm{ложь}
\end{lisp}

In Common Lisp, unlike some other Lisp dialects, the implementation
is permitted to make ``copies'' of
characters and numbers at any time.  (This permission is granted
because it allows tremendous performance improvements in many
common situations.)  The net effect is that
Common Lisp makes no guarantee that \cdf{eq} will be true even when both
its arguments are ``the same thing'' if that thing is a character or number.
For example:
\begin{lisp}
(let ((x 5)) (eq x x)) \textrm{might be true or false.}
\end{lisp}

В Common Lisp'е, в отличие от других деалектов, реализация в любое время может
создавать <<копии>> строковых символов и чисел. (Это сделано для возможности в
повышении производительности во многих общих случаях.) Из этого следует правило,
что Common Lisp не гарантирует для строковых символов и чисел то, что \cdf{eq}
будет истенен, когда оба аргумента являются <<одним и тем же>>.
Например:
\begin{lisp}
(let ((x 5)) (eq x x)) \textrm{может быть истиной или ложью}
\end{lisp}

The predicate \cdf{eql} is the same as \cdf{eq}, except that if the
arguments are characters or numbers of the same type then their
values are compared.  Thus \cdf{eql} tells whether two objects
are \emph{conceptually} the same, whereas \cdf{eq} tells whether two
objects are \emph{implementationally} identical.  It is for this reason
that \cdf{eql}, not \cdf{eq}, is the default comparison predicate
for the sequence functions defined in chapter~\ref{KSEQUE}.

Предикат \cdf{eql} означает то же, что и \cdf{eq}, за исключением того, что если
аргументы являются строковыми символами или числами одинакового типа, тогда
сравниваются их значения. Таким образом \cdf{eql} говорит, являются ли два объекта
<<концептуально (conceptually)>> одинаковыми, тогда как \cdf{eq} указывает, являются ли два
объекта <<реализационно (implementationally)>> одинаковыми. По этой причине
сравнительным предикатом для функций работы с последовательностями, описанными в
главе~\ref{KSEQUE}, является \cdf{eql}, а не \cdf{eq}.

\beforenoterule
\begin{implementation}
\cdf{eq} simply compares the two given pointers,
so any kind of object that is represented in an ``immediate'' fashion
will indeed have like-valued instances satisfy \cdf{eq}.
In some implementations, for example,
fixnums and characters happen to ``work.''
However, no program should depend on this, as other implementations
of Common Lisp might not use an immediate representation for these data types.
\end{implementation}
\afternoterule

\begin{obsolete}
An additional problem with \cdf{eq} is that the implementation is permitted
to ``collapse'' constants (or portions thereof)
appearing in code to be compiled if they are
\cdf{equal}.  An object is considered to be a constant in code to be compiled
if it is a self-evaluating form or is contained in a \cdf{quote} form.
This is why \cd{(eq "Foo" "Foo")} might be true or false; in interpreted
code it would normally be false, because reading in the
form \cd{(eq "Foo" "Foo")} would construct distinct strings for the two
arguments to \cdf{eq}, but the compiler might choose to use the same
identical string or two distinct copies as the two arguments in the
call to \cdf{eq}.  Similarly, \cd{(eq '(a . b) '(a . b))} might be true
or false, depending on whether the constant conses appearing in the
\cdf{quote} forms were collapsed by the compiler.  However,
\cd{(eq (cons 'a 'b) (cons 'a 'b))} is always false, because every distinct
call to the \cdf{cons} function necessarily produces a new and distinct cons.
\end{obsolete}

\begin{newer}
X3J13 voted in March 1989 \issue{QUOTE-SEMANTICS} to clarify that
\cdf{eval} and \cdf{compile} are not permitted either to copy or
to coalesce (``collapse'') constants (see \cdf{eq})
appearing in the code they process; the resulting
program behavior must refer to objects that are \cdf{eql} to the
corresponding objects in the source code.
Only the \cdf{compile-file}/\cdf{load} process is permitted
to copy or coalesce constants (see section~\ref{COMPILER-SECTION}).
\end{newer}
\end{defun}

\begin{defun}[Function]
eql x y

The \cdf{eql} predicate is true if its arguments are \cdf{eq},
or if they are numbers of the same type with the same value,
or if they are character objects
that represent the same character.
For example:
\begin{lisp}
(eql 'a 'b) \textrm{is false.} \\
(eql 'a 'a) \textrm{is true.} \\
(eql 3 3) \textrm{is true.} \\
(eql 3 3.0) \textrm{is false.} \\
(eql 3.0 3.0) \textrm{is true.} \\
(eql \#c(3 -4) \#c(3 -4)) \textrm{is true.} \\
(eql \#c(3 -4.0) \#c(3 -4)) \textrm{is false.} \\
(eql (cons 'a 'b) (cons 'a 'c)) \textrm{is false.} \\
(eql (cons 'a 'b) (cons 'a 'b)) \textrm{is false.} \\
(eql '(a . b) '(a . b)) \textrm{might be true or false.} \\
(progn (setq x (cons 'a 'b)) (eql x x)) \textrm{is true.} \\
(progn (setq x '(a . b)) (eql x x)) \textrm{is true.} \\
(eql \#{\Xbackslash}A \#{\Xbackslash}A) \textrm{is true.} \\
(eql "Foo" "Foo") \textrm{might be true or false.} \\
(eql "Foo" (copy-seq "Foo")) \textrm{is false.} \\
(eql "FOO" "foo") \textrm{is false.}
\end{lisp}

Предикат \cdf{eql} является истиной, если его аргументы равны \cdf{eq}, или 
если это числого одинакового типа и с одинаковыми значениями, или если это
одинаковые строковые символы.
Например:
\begin{lisp}
(eql 'a 'b) \textrm{ложь} \\
(eql 'a 'a) \textrm{истина} \\
(eql 3 3) \textrm{истина} \\
(eql 3 3.0) \textrm{ложь} \\
(eql 3.0 3.0) \textrm{истина} \\
(eql \#c(3 -4) \#c(3 -4)) \textrm{истина} \\
(eql \#c(3 -4.0) \#c(3 -4)) \textrm{ложь} \\
(eql (cons 'a 'b) (cons 'a 'c)) \textrm{ложь} \\
(eql (cons 'a 'b) (cons 'a 'b)) \textrm{ложь} \\
(eql '(a . b) '(a . b)) \textrm{может быть истиной или ложью} \\
(progn (setq x (cons 'a 'b)) (eql x x)) \textrm{истина} \\
(progn (setq x '(a . b)) (eql x x)) \textrm{истина} \\
(eql \#{\Xbackslash}A \#{\Xbackslash}A) \textrm{истина} \\
(eql "Foo" "Foo") \textrm{может быть истиной или ложью} \\
(eql "Foo" (copy-seq "Foo")) \textrm{ложь} \\
(eql "FOO" "foo") \textrm{ложь}
\end{lisp}

Normally \cd{(eql 1.0s0 1.0d0)} would be false, under the assumption
that \cd{1.0s0} and \cd{1.0d0} are of distinct data types.
However, implementations that do not provide four distinct floating-point
formats are permitted to ``collapse'' the four formats into some
smaller number of them; in such an implementation \cd{(eql 1.0s0 1.0d0)}
might be true.  The predicate \cdf{=} will compare
the values of two numbers even if the numbers are of different types.

Обычно \cd{(eql 1.0s0 1.0d0)} будет ложью, так как \cd{1.0s0} и \cd{1.0d0} не
принадлежат одному типу данных. Однако реализация может не реализовывать полный
набор чисел с плавающей точкой, поэтому в такой ситуации \cd{(eql 1.0s0 1.0d0)}
может быть истиной. Предикат \cdf{=} будет сравнивать знчения двух чисел, даже
если числа принадлежат разным типам.

If an implementation supports positive and negative zeros as distinct
values (as in the IEEE proposed standard floating-point format),
then \cd{(eql 0.0 -0.0)} will be false.  Otherwise, when the syntax
\cd{-0.0} is read it will be interpreted as the value \cd{0.0},
and so \cd{(eql 0.0 -0.0)} will be true.  The predicate \cdf{=}
differs from \cdf{eql} in that \cd{(= 0.0 -0.0)} will always be true,
because \cdf{=} compares the mathematical values of its operands,
whereas \cdf{eql} compares the representational values, so to speak.

Если реализация поддерживает положительный и отрицательный нули, как различные
значения (так IEEE стандарт предлагает реализовывать формат числа с плавающей
точкой), тогда \cd{(eql 0.0 -0.0)} будет ложью. В противном случае, когда
синтаксис \cd{-0.0} интепретируется, как значение \cd{0.0}, тогда \cd{(eql 0.0
  -0.0)} будет истиной. Предикат \cdf{=} отличается от \cdf{eql}, в том что
\cd{(= 0.0 -0.0)} будет всегда истинно, потому что \cdf{=} сравнивает
математические значения операндов, тогда как \cdf{eql} сравнивает, так сказать,
репрезентативные (representational) значения. FIXME.

Two complex numbers are considered to be \cdf{eql}
if their real parts are \cdf{eql} and their imaginary parts are \cdf{eql}.
For example, \cd{(eql \#C(4 5) \#C(4 5))} is true and
\cd{(eql \#C(4 5) \#C(4.0 5.0))} is false.
Note that while \cd{(eql \#C(5.0 0.0) 5.0)} is false,
\cd{(eql \#C(5 0) 5)} is true.
In the case of \cd{(eql \#C(5.0 0.0) 5.0)} the
two arguments are of different types
and so cannot satisfy \cdf{eql}; that's all there is to it.
In the case of \cd{(eql \#C(5 0) 5)}, however,
\cd{\#C(5 0)} is not a complex number but
is always automatically reduced by the rule of complex
canonicalization to the integer \cd{5},
just as the apparent ratio \cd{20/4} is always simplified to \cd{5}.

Два комплексных числа будут равны \cdf{eql}, если их действительные части равны
\cd{eql} и мнимые части равны \cdf{eql}.
Например, \cd{(eql \#C(4 5) \#C(4 5))} является истиной и
\cd{(eql \#C(4 5) \#C(4.0 5.0))} является ложью.
Следует отметить, что \cd{(eql \#C(5.0 0.0) 5.0)} ложь,
а \cd{(eql \#C(5 0) 5)} истина.
В случае с \cd{(eql \#C(5.0 0.0) 5.0)}
два аргумента принадлежат разным типам и не равны \cdf{eql},
Однако, в случае \cd{(eql \#C(5 0) 5)},
\cd{\#C(5 0)} не является комплексным числом, и автоматически преобразуется, по
правилу канонизации комплексных чисел, в целое \cd{5}, так как дробное число
\cd{20/4} всегда упрощается до \cd{5}.

The case of \cd{(eql "Foo" "Foo")} is discussed above in the description
of \cdf{eq}.  While \cdf{eql} compares the values of numbers and
characters, it does not compare the contents of strings.  To compare
the characters of two strings, one should use \cdf{equal}, \cdf{equalp},
\cdf{string=}, or \cdf{string-equal}.

Cлучай \cd{(eql "Foo" "Foo")} обсуждался выше в описании \cdf{eq}. Тогда как
\cdf{eql} сравнивает значения чисел и строковых символов, он не сравнивает
содержимое строк. Сравнение символов двух строк может быть выполнено с помощью
\cdf{equal}, \cdf{equalp}, \cdf{string=} или \cdf{string-equal}.

\beforenoterule
\begin{incompatibility}
The Common Lisp function \cdf{eql} is similar to the
Interlisp function \cdf{eqp}.  However, \cdf{eql} considers \cd{3} and
\cd{3.0} to be different, whereas \cdf{eqp} considers them to be the same;
\cdf{eqp} behaves like the Common Lisp \cdf{=} function, not like \cdf{eql},
when both arguments are numbers.
\end{incompatibility}
\afternoterule
\end{defun}

\begin{defun}[Function]
equal x y

The \cdf{equal} predicate is true if its arguments are structurally similar
(isomorphic) objects.  A rough rule of thumb is that two objects
are \cdf{equal} if and only if their printed representations are the same.

Предикат \cdf{equal} является истиной, если его аргументы это структурно похожие
(изоморфные) объекты. Грубое правило такое, что два объекта равны \cdf{equal}
тогда и только тогда, когда одинаково их выводимое представление.

Numbers and characters are compared as for \cdf{eql}.
Symbols are compared as for \cdf{eq}.  This method
of comparing symbols can violate the rule
of thumb for \cdf{equal} and printed representations,
but only in the infrequently occurring case of two distinct
symbols with the same print name.

Числа и строковые символы сравниваются также как и в \cdf{eql}.
Символы сравниваются как в \cdf{eq}. Этот метод сравнения символов может
нарушать правило и сравнении выводимого представления, в случае если различия
двух символов с одинаковым выводимым представлением.

Certain objects that have components are \cdf{equal} if they are of the same
type and corresponding components are \cdf{equal}.
This test is implemented in a recursive manner and may fail to
terminate for circular structures.

Объекты, которые содержат другие элементы, будут равны \cdf{equal}, если они
принадлежат одному типу и содержащиеся элементы равны \cdf{equal}.
Эта проверка реализована в рекурсивном стиле и может быть зациклиться на
закольцованных структурах.

For conses, \cdf{equal} is defined recursively as
the two \emph{car}'s being \cdf{equal} and the two \emph{cdr}'s being
\cdf{equal}.

Для cons-ячеек, \cdf{equal} определен рекурсивно, как сравнение \cd{equal}
сначала \emph{car} элементов, а затем \emph{cdr}.

Two arrays are \cdf{equal} only if they are \cdf{eq},
with one exception:
strings and bit-vectors are compared element-by-element.
If either argument has a fill pointer, the fill pointer limits
the number of elements examined by \cdf{equal}.
Uppercase and lowercase letters in strings are considered by
\cdf{equal} to be distinct.  (In contrast, \cdf{equalp} ignores
case distinctions in strings.)

Два массива равны \cdf{equal} только, если они равны \cdf{eq}, с одним
исключением:
строки и битовые вектора сравниваются поэлементно.
Если какой-либо аргумент или оба содержат указатель заполнения (fill pointer),
данный указатель ограничит количество проверяемых с помощью \cd{equal}
элементов.
Буквы верхнего и нижнего регистров в строках рацениваются предикатом \cdf{equal}
как разные. (А \cdf{equalp} игнорирует различие в регистрах в строках.) 

\beforenoterule
\begin{incompatibility}
In Lisp Machine Lisp, \cdf{equal} ignores the difference between
uppercase and lowercase letters in strings.
This violates the rule of thumb about
printed representations, however, which is very useful, especially
to novices.  It is also inconsistent with the treatment of single characters,
which in Lisp Machine Lisp are represented as fixnums.
\end{incompatibility}
\afternoterule

Two pathname objects are \cdf{equal} if and only if
all the corresponding components
(host, device, and so on) are equivalent.  (Whether or not
uppercase and lowercase letters are considered equivalent
in strings appearing in components depends on the file
name conventions of the file system.)  Pathnames
that are \cdf{equal} should be functionally equivalent.

Два объекта имени файла (pathname objects) равны \cdf{equal} тогда и только
тогда, когда все элементы (хост, устройство, и т.д.) равны. (Будут ли равны
буквы разных регистров зависит от файловой системы.) Имена файлов, которые равны
\cdf{equal}, должны быть функционально эквивалентны.

\begin{new}
X3J13 voted in June 1989
\issue{EQUAL-STRUCTURE}
to clarify that \cdf{equal} never recursively
descends any structure or data type other than the ones explicitly
described above: conses, bit-vectors, strings, and pathnames.
Numbers and characters are compared as if by \cdf{eql}, and all other
data objects are compared as if by \cdf{eq}.
\end{new}

\begin{lisp}
(equal 'a 'b) \textrm{is false.} \\
(equal 'a 'a) \textrm{is true.} \\
(equal 3 3) \textrm{is true.} \\
(equal 3 3.0) \textrm{is false.} \\
(equal 3.0 3.0) \textrm{is true.} \\
(equal \#c(3 -4) \#c(3 -4)) \textrm{is true.} \\
(equal \#c(3 -4.0) \#c(3 -4)) \textrm{is false.} \\
(equal (cons 'a 'b) (cons 'a 'c)) \textrm{is false.} \\
(equal (cons 'a 'b) (cons 'a 'b)) \textrm{is true.} \\
(equal '(a . b) '(a . b)) \textrm{is true.} \\
(progn (setq x (cons 'a 'b)) (equal x x)) \textrm{is true.} \\
(progn (setq x '(a . b)) (equal x x)) \textrm{is true.} \\
(equal \#{\Xbackslash}A \#{\Xbackslash}A) \textrm{is true.} \\
(equal "Foo" "Foo") \textrm{is true.} \\
(equal "Foo" (copy-seq "Foo")) \textrm{is true.} \\
(equal "FOO" "foo") \textrm{is false.}
\end{lisp}
To compare a tree of conses using \cdf{eql}
(or any other desired predicate) on the leaves, use \cdf{tree-equal}.

\begin{lisp}
(equal 'a 'b) \textrm{ложь} \\
(equal 'a 'a) \textrm{истина} \\
(equal 3 3) \textrm{истина} \\
(equal 3 3.0) \textrm{ложь} \\
(equal 3.0 3.0) \textrm{истина} \\
(equal \#c(3 -4) \#c(3 -4)) \textrm{истина} \\
(equal \#c(3 -4.0) \#c(3 -4)) \textrm{ложь} \\
(equal (cons 'a 'b) (cons 'a 'c)) \textrm{ложь} \\
(equal (cons 'a 'b) (cons 'a 'b)) \textrm{истина} \\
(equal '(a . b) '(a . b)) \textrm{истина} \\
(progn (setq x (cons 'a 'b)) (equal x x)) \textrm{истина} \\
(progn (setq x '(a . b)) (equal x x)) \textrm{истина} \\
(equal \#{\Xbackslash}A \#{\Xbackslash}A) \textrm{истина} \\
(equal "Foo" "Foo") \textrm{истина} \\
(equal "Foo" (copy-seq "Foo")) \textrm{истина} \\
(equal "FOO" "foo") \textrm{ложь}
\end{lisp}
To compare a tree of conses using \cdf{eql}
(or any other desired predicate) on the leaves, use \cdf{tree-equal}.
Для сравнения дерева cons-ячеек применяя \cdf{eql} (или любой другой желаемый
предикат) для листьев, используйте \cdf{tree-equal}.

\end{defun}

\begin{defun}[Function]
equalp x y

Two objects are \cdf{equalp} if they are \cdf{equal};
if they are characters and satisfy \cdf{char-equal},
which ignores alphabetic case and certain other attributes of characters;
if they are numbers and have the same numerical value,
even if they are of different types;
or if they have components that are all \cdf{equalp}.

Два объекта равны \cdf{equalp}, если они равны \cdf{equal},
если они строковые символы и удовлетворяют предикату \cdf{char-equal}, который
игнорирует регистр и другие атрибуты символов,
если они числа и имеют одинаковое значение, даже если числа разных типов,
если они включает в себя элементы, которые также равны \cdf{equalp}.

Objects that have components are \cdf{equalp} if they are of the same
type and corresponding components are \cdf{equalp}.
This test is implemented in a recursive manner and may fail to
terminate for circular structures.
For conses, \cdf{equalp} is defined recursively as
the two \emph{car}'s being \cdf{equalp} and the two \emph{cdr}'s being
\cdf{equalp}.

Объекты, которые включают в себя элементы, равны \cdf{equalp}, если они
принадлежат одному типу и содержащиеся элементы равны \cdf{equalp}.
Проверка осуществляется в рекурсивном стиле и может не завершится на
заколцованных структурах.
Для cons-ячеек, предикат \cdf{equalp} определен рекурсивно и сравнивает сначала
\emph{car} элементы, а затем \emph{cdr}.

Two arrays are \cdf{equalp} if and only if they have the same
number of dimensions, the dimensions match,
and the corresponding components are \cdf{equalp}.
The specializations need not match; for example,
a string and a general array that happens to contain the same characters
will be \cdf{equalp} (though definitely not \cdf{equal}).
If either argument has a fill pointer, the fill pointer limits
the number of elements examined by \cdf{equalp}.
Because \cdf{equalp} performs element-by-element comparisons
of strings and ignores the alphabetic case of characters,
case distinctions are therefore also ignored when \cdf{equalp} compares
strings.

Два массива равны \cdf{equalp} тогда и только тогда, когда они имеют одинаковое
количество измерений, и размеры измерений совпадают, и все элементы равны
\cdf{equalp}. Специализация массива не сравнивается. Например,
строка и общий массив, случилось так, имеют одинаковые строковые символы,
тогда они будут равны \cdf{equalp} (но определенно не равны \cdf{equal}).
Если какой-либо аргумент содержит указатель заполнения, этот указатель
ограничивает число сравниваемых элементов. Так как \cdf{equalp} сравнивает
строки побуквенно, и не различает разных регистров букв, то сравнение строк регистронезависимо.

Two symbols can be \cdf{equalp} only if they are \cdf{eq}, that is, the same
identical object.

Два символа могут быть равны \cdf{equalp} только тогда, когда они \cdf{eq},
т.е. являеются идентичными объектами.

\begin{new}
X3J13 voted in June 1989
\issue{EQUAL-STRUCTURE}
to specify that \cdf{equalp} compares components
of hash tables (see below), and to
clarify that otherwise \cdf{equalp} never recursively
descends any structure or data type other than the ones explicitly
described above: conses, arrays (including bit-vectors and strings), and pathnames.
Numbers are compared for numerical equality (see \cdf{=}),
characters are compared as if by \cdf{char-equal}, and all other
data objects are compared as if by \cdf{eq}.

Two hash tables are considered the same by \cdf{equalp} if and only if
they satisfy a four-part test:
\begin{itemize}
\item They must be
of the same kind; that is, equivalent \cd{:test} arguments were given to
\cdf{make-hash-table} when the two hash tables were created.

\item They must have the same number of entries (see \cdf{hash-table-count}).

\item For every entry (\emph{key1}, \emph{value1\/}) in one hash table
there must be a corresponding entry (\emph{key2}, \emph{value2\/}) in the
other, such that \emph{key1} and \emph{key2} are considered to be the same
by the \cd{:test} function associated with the hash tables.

\item For every entry (\emph{key1}, \emph{value1\/}) in one hash table
and its corresponding entry (\emph{key2}, \emph{value2\/}) in the
other, such that \emph{key1} and \emph{key2} are the same,
\cdf{equalp} must be true of \emph{value1} and \emph{value2}.
\end{itemize}
The four parts of this test are carried out in the order shown, and
if some part of the test fails, \cdf{equalp} returns \cdf{nil} and
the other parts of the test are not attempted.

If \cdf{equalp} must compare two structures and the \cdf{defstruct}
definition for one used the \cd{:type} option and the other did not,
then \cdf{equalp} returns \cdf{nil}.

If \cdf{equalp} must compare two structures and neither \cdf{defstruct}
definition used the \cd{:type} option,
then \cdf{equalp} returns \cdf{t} if and only if the structures have the
same type (that is, the same \cdf{defstruct} name) and the values
of all corresponding slots (slots having the same name) are \cdf{equalp}.

As part of the X3J13 discussion of this issue
the following observations were made.
    Object equality is not a concept for which there is a uniquely
    determined correct algorithm. The appropriateness of an equality
    predicate can be judged only in the context of the needs of some
    particular program. Although these functions take any type of
    argument and their names sound very generic, \cdf{equal} and \cdf{equalp} are
    not appropriate for every application. Any decision to use or not
    use them should be determined by what they are documented to do
    rather than by any abstract characterization of their function. If
    neither \cdf{equal} nor \cdf{equalp} is found to be appropriate in a particular
    situation, programmers are encouraged to create another operator
    that is appropriate rather than blame \cdf{equal} or \cdf{equalp} for ``doing
    the wrong thing.''
\end{new}

\begin{new}
Note that one consequence
of the vote to change the rules of
floating-point contagion
\issue{CONTAGION-ON-NUMERICAL-COMPARISONS}
(described in section~\ref{PRECISION-CONTAGION-COERCION-SECTION})
is to make \cdf{equalp}
a true equivalence relation on numbers.
\end{new}

\begin{lisp}
(equalp 'a 'b) \textrm{is false.} \\
(equalp 'a 'a) \textrm{is true.} \\
(equalp 3 3) \textrm{is true.} \\
(equalp 3 3.0) \textrm{is true.} \\
(equalp 3.0 3.0) \textrm{is true.} \\
(equalp \#c(3 -4) \#c(3 -4)) \textrm{is true.} \\
(equalp \#c(3 -4.0) \#c(3 -4)) \textrm{is true.} \\
(equalp (cons 'a 'b) (cons 'a 'c)) \textrm{is false.} \\
(equalp (cons 'a 'b) (cons 'a 'b)) \textrm{is true.} \\
(equalp '(a . b) '(a . b)) \textrm{is true.} \\
(progn (setq x (cons 'a 'b)) (equalp x x)) \textrm{is true.} \\
(progn (setq x '(a . b)) (equalp x x)) \textrm{is true.} \\
(equalp \#{\Xbackslash}A \#{\Xbackslash}A) \textrm{is true.} \\
(equalp "Foo" "Foo") \textrm{is true.} \\
(equalp "Foo" (copy-seq "Foo")) \textrm{is true.} \\
(equalp "FOO" "foo") \textrm{is true.}
\end{lisp}

\begin{lisp}
(equalp 'a 'b) \textrm{ложь} \\
(equalp 'a 'a) \textrm{истина} \\
(equalp 3 3) \textrm{истина} \\
(equalp 3 3.0) \textrm{истина} \\
(equalp 3.0 3.0) \textrm{истина} \\
(equalp \#c(3 -4) \#c(3 -4)) \textrm{истина} \\
(equalp \#c(3 -4.0) \#c(3 -4)) \textrm{истина} \\
(equalp (cons 'a 'b) (cons 'a 'c)) \textrm{ложь} \\
(equalp (cons 'a 'b) (cons 'a 'b)) \textrm{истина} \\
(equalp '(a . b) '(a . b)) \textrm{истина} \\
(progn (setq x (cons 'a 'b)) (equalp x x)) \textrm{истина} \\
(progn (setq x '(a . b)) (equalp x x)) \textrm{истина} \\
(equalp \#{\Xbackslash}A \#{\Xbackslash}A) \textrm{истина} \\
(equalp "Foo" "Foo") \textrm{истина} \\
(equalp "Foo" (copy-seq "Foo")) \textrm{истина} \\
(equalp "FOO" "foo") \textrm{истина}
\end{lisp}
\end{defun}

\section{Logical Operators Логические операторы}

Common Lisp provides three operators on Boolean values: \cdf{and}, \cdf{or},
and \cdf{not}.  Of these, \cdf{and} and \cdf{or}
are also control structures because their arguments are evaluated
conditionally.
The function \cdf{not} necessarily examines its single argument, and so
is a simple function.

Common Lisp предоставляет три логических операторы для булевых значений:
\cdf{and}, \cdf{or} и \cdf{not} (и, или, не, соответственно). \cdf{and} и
\cdf{or} являются управляющими структурами, потому что их аргументы
вычисляются в зависимости от условия.
Функции \cdf{not} необходимо инвертировать ее один аргумент, поэтому она может
быть простой функцией.

\begin{defun}[Function]
not x

\cdf{not} returns {\true} if \emph{x} is {\false}, and otherwise returns {\false}.
It therefore inverts its argument considered as a Boolean value.

\cdf{null} is the same as \cdf{not}; both functions are included for the sake
of clarity.  As a matter of style,
it is customary to use \cdf{null} to check whether something is the empty list
and to use \cdf{not} to invert the sense of a logical value.

\cdf{not} возвращает {\true}, если \emph{x} является {\false}, иначе
возвращает {\false}.
Таким образом она инвертирует аргумент как булево значение.

\cdf{null} то же, что и \cdf{not}, обе функции включены для ясности. По
соглашению принято использовать \cdf{null}, когда надо проверить пустой ли
список, и \cdf{not}, когда надо инвертировать булево значение.
\end{defun}

\begin{defmac}
and {\,form}*

\cd{(and \emph{form1} \emph{form2} ... )} evaluates each \emph{form}, one at a time,
from left to right.  If any \emph{form} evaluates to {\false}, the value {\nil}
is immediately returned without evaluating the remaining
\emph{form\/}s.  If every \emph{form} but the last evaluates to a non-{\false} value,
\cdf{and} returns whatever the last \emph{form} returns.
Therefore in general \cdf{and} can be used both for logical operations,
where {\false} stands for \emph{false} and non-{\false} values stand for \emph{true},
and as a conditional expression.
An example follows.
\begin{lisp}
(if (and (>= n 0) \\
~~~~~~~~~(< n (length a-simple-vector)) \\
~~~~~~~~~(eq (elt a-simple-vector n) 'foo)) \\
~~~~(princ "Foo!"))
\end{lisp}
The above expression prints \cd{Foo!} if element \cd{n} of \cd{a-simple-vector}
is the symbol \cd{foo}, provided also that \cdf{n} is indeed a valid index
for \cdf{a-simple-vector}.  Because \cdf{and} guarantees left-to-right testing
of its parts, \cdf{elt} is not called if \cd{n} is out of range.

\cd{(and \emph{form1} \emph{form2} ... )} последовательно слева направо
вычисляет формы. Если какая-либо форма \emph{formN} вычислилась в {\false},
тогд немедленно возвращается значение {\nil} без выполнения оставшихся форм. Если все
формы кроме последней вычисляются в не-{\false} значение, \cdf{and} возвращает
то, что вернула последняя форма.
Таким образом, \cdf{and} может использоваться, как для логических операций, где
{\false} обозначает ложь и не-{\false} значения истину, так и для условных
выражений.
Например:
\begin{lisp}
(if (and (>= n 0) \\
~~~~~~~~~(< n (length a-simple-vector)) \\
~~~~~~~~~(eq (elt a-simple-vector n) 'foo)) \\
~~~~(princ "Foo!"))
\end{lisp}
Выражение выше выводит \cd{Foo!}, если \cd{n}-ый элемент вектора
\cd{a-simple-vector} является символом \cd{foo}, проверяя при этом вхождния
\cd{n} в границы вектора \cd{a-simple-vector}. \cdf{elt} не будет вызвано с
аргументом \cd{n} выходящим за границы вектора, так как \cdf{and} гарантирует
ленивую проверку аргументов слева направо.

To put it another way,
the \cdf{and} special form does \emph{short-circuit} Boolean evaluation,
like the \textbf{and then} operator in Ada
and what in some Pascal-like languages is called \textbf{cand} (for ``conditional
and''); the Lisp \cdf{and} special form is
unlike the Pascal or Ada \textbf{and} operator,
which always evaluates both arguments.

Специальная форма Lisp'а \cdf{and} отличается тем, что не
обязательно вычисляет все аргументы.

In the previous example writing
\begin{lisp}
(and (>= n 0) \\
~~~~~(< n (length a-simple-vector)) \\
~~~~~(eq (elt a-simple-vector n) 'foo) \\
~~~~~(princ "Foo!"))
\end{lisp}
would accomplish the same thing.  The difference is purely stylistic.
Some programmers never use expressions containing side effects
within \cdf{and}, preferring to use \cdf{if} or \cdf{when} for that purpose.

Запись предыдущего примера
\begin{lisp}
(and (>= n 0) \\
~~~~~(< n (length a-simple-vector)) \\
~~~~~(eq (elt a-simple-vector n) 'foo) \\
~~~~~(princ "Foo!"))
\end{lisp}
будет выполнять ту же функцию. Разница в них только стилистическая. Некоторые
программисты никогда не используют в форме \cdf{and} выражения с побочными
эффектами, предпочитая для этих целей использовать \cdf{if} или \cdf{when}. 

From the general definition, one can deduce that
\cd{(and \emph{x})} \EQ\ \emph{x}.  Also,
\cd{(and)} evaluates to {\true}, which is an identity for this operation.

Из общего определения можно сделать дедуктивный вывод о том, что 
\cd{(and \emph{x})} \EQ\ \emph{x}. Также \cd{(and)} выполняется в {\true},
который тождественнен этой операции.

One can define \cdf{and} in terms of \cdf{cond} in this way:
\begin{lisp}
(and \emph{x} \emph{y} \emph{z} ... \emph{w}) \EQ\ (cond \=((not \emph{x}) {\false}) \\
\>((not \emph{y}) {\false}) \\
\>((not \emph{z}) {\false}) \\
\>$\ldots$ \\
\>({\true} \emph{w}))
\end{lisp}

Можно определить \cdf{and} в терминах \cdf{cond} таким образом:
\begin{lisp}
(and \emph{x} \emph{y} \emph{z} ... \emph{w}) \EQ\ (cond \=((not \emph{x}) {\false}) \\
\>((not \emph{y}) {\false}) \\
\>((not \emph{z}) {\false}) \\
\>$\ldots$ \\
\>({\true} \emph{w}))
\end{lisp}

See \cdf{if} and \cdf{when}, which are sometimes stylistically
more appropriate than \cdf{and} for conditional purposes.
If it is necessary to test whether a predicate is true
of all elements of a list or vector (element 0 \emph{and} element 1 \emph{and}
element 2 \emph{and} $\ldots$), then the function \cdf{every} may be useful.

Смотрите \cdf{id} и \cdf{when}, которые иногда являются стилистически более
удобными, чем \cdf{and} в целях ветвления.
Если необходимо проверить истинность предиката для всех элементов списка или
вектора (element 0 \emph{and} element 1 \emph{and}
element 2 \emph{and} $\ldots$), можно использовать функцию \cdf{every}.
\end{defmac}

\begin{defmac}
or {\,form}*

\cd{(or \emph{form1} \emph{form2} ... )} evaluates each \emph{form}, one at a time,
from left to right.  If any \emph{form} other than the last
evaluates to something other than {\false},
\cdf{or}
immediately returns that non-{\false} value without evaluating the remaining
\emph{form\/}s.  If every \emph{form} but the last evaluates to {\false},
\cdf{or} returns whatever evaluation of the last of the \emph{form\/}s returns.
Therefore in general \cdf{or} can be used both for logical operations,
where {\false} stands for \emph{false} and non-{\false} values stand for \emph{true},
and as a conditional expression.

\cd{(or \emph{form1} \emph{form2} ... )} последовательно выполняет каждую
форму слева направо. Если какая-либо непоследняя форма выполняется в что-либо
отличное от {\false}, \cdf{or} немендленно возвращает это не-{\false} значение
без выполнения оставшихся форм. Если все формы кроме последней, вычисляются в
{\false}, \cdf{or} возвращает то, что вернула последняя форма.
Таким образом \cdf{or} может быть использована как для логических операций, 
в который {\false} обозначает ложь, и не-{\false} истину,
так и для условного выполнения форм.

To put it another way,
the \cdf{or} special form does \emph{short-circuit} Boolean evaluation,
like the \textbf{or else} operator in Ada
and what in some Pascal-like languages is called \textbf{cor} (for ``conditional
or''); the Lisp \cdf{or} special form is
unlike the Pascal or Ada \textbf{or} operator,
which always evaluates both arguments.

Специальная форма Lisp'а \cdf{or} тем, что не обязательно вычисляет все
аргументы. 

From the general definition, one can deduce that
\cd{(or \emph{x})} \EQ\ \emph{x}.  Also,
\cd{(or)} evaluates to {\nil}, which is the identity for this operation.

Из общего определения, можно сделать дедуктивный вывод о том, что \cd{(or
  \emph{x})} \EQ\ \emph{x}. Также, \cd{(or)} выполняется в {\nil}, который
тождественнен этой операции.

One can define \cdf{or} in terms of \cdf{cond} in this way:
\begin{lisp}
(or \emph{x} \emph{y} \emph{z} ... \emph{w}) \EQ\ (cond (\emph{x}) (\emph{y}) (\emph{z}) ... ({\true} \emph{w}))
\end{lisp}

Можно определить \cdf{or} в терминах \cdf{cond} таким образом:
\begin{lisp}
(or \emph{x} \emph{y} \emph{z} ... \emph{w}) \EQ\ (cond (\emph{x}) (\emph{y}) (\emph{z}) ... ({\true} \emph{w}))
\end{lisp}

See \cdf{if} and \cdf{unless}, which are sometimes
stylistically more appropriate than \cdf{or} for conditional purposes.
If it is necessary to test whether a predicate is true of
one or more elements of a list or vector (element 0 \emph{or} element 1 \emph{or}
element 2 \emph{or} $\ldots$), then the function \cdf{some} may be useful.

Смотрите \cdf{id} и \cdf{unless}, которые иногда являются стилистически более
удобными, чем \cdf{or} в целях ветвления.
Если необходимо проверить истинность предиката для всех элементов списка или
вектора (element 0 \emph{or} element 1 \emph{or}
element 2 \emph{or} $\ldots$), можно использовать функцию \cdf{some}.
\end{defmac}

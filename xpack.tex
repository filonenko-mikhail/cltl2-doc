%Part{XPACK, Root = "CLM.MSS"}
%Chapter of Common Lisp Manual.  Copyright 1984, 1988, 1989 Guy L. Steele Jr.

\clearpage\def\pagestatus{ULTIMATE}

\ifx \rulang\Undef

\chapter{Packages}
\label{XPACK}

One problem with earlier Lisp systems is the use of a single name space
for all symbols.  In large Lisp systems, with modules written by many
different programmers, accidental name collisions become a serious
problem.  Common Lisp addresses this problem through the \emph{package system},
derived from an earlier package system developed for
Lisp Machine Lisp \cite{BLUE-LISPM}.
In addition to preventing name-space conflicts, the
package system makes the modular structure of large Lisp systems more
explicit.

A \emph{package} is a data structure that establishes a mapping from print
names (strings) to symbols.  The package thus replaces the ``oblist'' or
``obarray'' machinery of earlier Lisp systems.  At any given time one
package is current, and this package is used by the Lisp reader in
translating strings into symbols.  The current package is, by definition,
the one that is the
value of the global variable \cdf{*package*}.  It is possible to refer to
symbols in packages other than the current one through the use of
\emph{package qualifiers} in the printed representation of the symbol.
For example, \cd{foo:bar}, when seen by the reader,
refers to the symbol whose name is
\cdf{bar} in the package whose name is \cdf{foo}.
(Actually, this is true only if \cdf{bar} is an external symbol of \cdf{foo},
that is, a symbol that is supposed to be visible outside of \cdf{foo}.
A reference to an internal symbol requires the intentionally
clumsier syntax \cd{foo::bar}.)

The string-to-symbol mappings available in a given package are divided
into two classes, \emph{external} and \emph{internal}.  We refer to the
symbols accessible via these mappings as being \emph{external} and
\emph{internal} symbols of the package in question, though really it is the
mappings that are different and not the symbols themselves.  Within a
given package, a name refers to one symbol or to none; if it does refer
to a symbol, then it is either external or internal in that
package, but not both.

External symbols are part of the package's public interface to other
packages.  External symbols are supposed to be chosen with some care and are
advertised to users of the package.  Internal symbols are for internal
use only, and these symbols are normally hidden from other packages.
Most symbols are created as internal symbols; they become external only
if they appear explicitly in an \cdf{export} command for the package.

A symbol may appear in many packages.  It will always have the same
name wherever it appears, but it may be external in some packages
and internal in others.  On the other hand,
the same name (string) may refer to different symbols in
different packages.

Normally, a symbol that appears in one or more packages
will be \emph{owned} by one particular package, called the \emph{home package}
of the symbol; that package is said to \emph{own} the symbol.
Every symbol has a component called the \emph{package cell}
that contains a pointer to its home package.
A symbol that is owned by some package is said to be \emph{interned}.
Some symbols are not owned by any package; such a symbol
is said to be \emph{uninterned}, and its package cell contains {\false}.

Packages may be built up in layers.  From the point of view of a
package's user, the package is a single collection of mappings from
strings into internal and external symbols.  However, some of these
mappings may be established within the package itself, while other
mappings are inherited from other packages via the \cdf{use-package}
construct.  (The mechanisms responsible for this inheritance are
described below.)  In what follows, we will refer to a symbol as being
\emph{accessible} in a package if it can be referred to
without a package qualifier when that package is current,
regardless of whether the mapping occurs within
that package or via inheritance.   We will refer to a symbol as being
\emph{present} in a package if the mapping is in the package itself and is
not inherited from somewhere else.  Thus a symbol present in a package is accessible,
but an accessible symbol is not necessarily present.

A symbol is said to be \emph{interned in a package} if it is
accessible in that package and also is owned (by either that package
or some other package).  Normally all the symbols accessible in
a package will in fact be owned by some package,
but the terminology is useful when
discussing the pathological case of an accessible but unowned (uninterned)
symbol.

As a verb, to \emph{intern} a symbol in a package means to cause the
symbol to be interned in the package if it was not already;
this process is performed by the function \cdf{intern}.
If the symbol was previously unowned, then the package it is being
interned in becomes its owner (home package); but
if the symbol was previously owned by another package, that other package
continues to own the symbol.

To \emph{unintern} a symbol from the package means to cause it to be not
present in the package
and, additionally, to cause the symbol to be uninterned if the
package was the home package (owner) of the symbol.
This process is performed by the function \cdf{unintern}.

\section{Consistency Rules}

Package-related bugs can be very subtle and confusing: things are not
what they appear to be.  The Common Lisp package system is designed with
a number of safety features to prevent most of the common bugs that
would otherwise occur in normal use.  This may seem over-protective, but
experience with earlier package systems has shown that such safety
features are needed.

In dealing with the package system, it is useful to keep in mind the
following consistency rules, which remain in force as long as the value
of \cdf{*package*} is not changed by the user:

\begin{itemize}
\item
\emph{Read-read consistency:} Reading the same print name always results in
the same (\cdf{eq}) symbol.

\item
\emph{Print-read consistency:} An interned symbol always prints as a
sequence of characters that, when read back in, yields the same (\cdf{eq})
symbol.

\item
\emph{Print-print consistency:} If two interned symbols are not \cdf{eq}, then
their printed representations will be different sequences of
characters.
\end{itemize}

These consistency rules remain true in spite of any amount of implicit
interning caused by typing in Lisp forms, loading files, etc.  This has
the important implication that, as long as the current package
is not changed, results are reproducible regardless of
the order of loading files or the exact history of what symbols were
typed in when.  The rules can only be violated by explicit action:
changing the value of \cdf{*package*}, forcing some action by continuing
from an error, or calling one of the ``dangerous'' functions
\cdf{unintern}, \cdf{unexport}, \cdf{shadow},
\cdf{shadowing-import}, or \cdf{unuse-package}.

\section{Package Names}
\label{PACKAGE-NAMES-SECTION}

Each package has a name (a string) and perhaps some nicknames.  These
are assigned when the package is created, though they can be changed
later.  A package's name should be something long and self-explanatory,
like \cdf{editor}; there might be a nickname that is shorter and easier to
type, such as \cdf{ed}.

There is a single name space for packages.  The function
\cdf{find-package} translates a package name or nickname into the
associated package.  The function \cdf{package-name} returns the name of a
package.  The function \cdf{package-nicknames} returns a list of all
nicknames for a package.  The function \cdf{rename-package} removes a
package's current name and nicknames and replaces them with new ones
specified by the user.  Package renaming is occasionally useful when, for
development purposes, it is desirable to load two versions of a package
into the same Lisp.  One can load the first version, rename it,
and then load the other version, without getting a lot of name conflicts.

When the Lisp reader sees a qualified symbol, it handles the package-name
part in the same way as the symbol part with respect to capitalization.
Lowercase characters in the package name are converted to corresponding
uppercase characters
unless preceded by the escape character \cd{{\Xbackslash}} or
surrounded by \cd{|} characters.  The lookup done by the
\cdf{find-package} function is case-sensitive, like that done for
symbols.  Note that \cd{|Foo|:|Bar|} refers to a symbol whose name is
\cdf{Bar} in a package whose name is \cdf{Foo}.  By contrast,
\cd{|Foo:Bar|} refers to a seven-character symbol that has a colon in its name
(as well as two uppercase letters and four lowercase letters)
and is interned in the current package.  Following the convention used
in this book for symbols, we show ordinary package names using
lowercase letters, even though the name string is internally represented
with uppercase letters.

Most of the functions that require a package-name argument from the
user accept either a symbol or a string.  If a symbol is supplied,
its print name will be used; the print name will already have undergone
case-conversion by the usual rules.  If a string is supplied, it
must be so capitalized as to match exactly the
string that names the package.

\begin{new}
X3J13 voted in January 1989
\issue{PACKAGE-FUNCTION-CONSISTENCY}
to clarify that one may use either a package object or
a package name (symbol or string) in any of the following
situations:
\begin{itemize}
\item the \cd{:use} argument to \cdf{make-package}
\item the first argument to \cdf{package-use-list}, \cdf{package-used-by-list},
\cdf{package-name}, \cdf{package-nicknames},
\cdf{in-package}, \cdf{find-package},
\cdf{rename-package}, or \cdf{delete-package},

\item the second argument to \cdf{intern}, \cdf{find-symbol},
\cdf{unintern}, \cdf{export}, \cdf{unexport}, \cdf{import}, \cdf{shadowing-import},
or \cdf{shadow}
\item the first argument, or a member of the list that is the first argument,
to \cdf{use-package} or \cdf{unuse-package}
\item the value of the \emph{package} given to \cdf{do-symbols},
\cdf{do-external-symbols}, or \cdf{do-all-symbols}
\item a member of the \emph{package-list} given to \cdf{with-package-iterator}
\end{itemize}
Note that the first argument to \cdf{make-package} must still be a package
name and not an actual package; it makes no sense to create an already
existing package.  Similarly, package nicknames must always be expressed
as package names and not as package objects.  If \cdf{find-package} is
given a package object instead of a name, it simply returns that package.
\end{new}

\section{Translating Strings to Symbols}
\label{STRING-TO-SYMBOL-SECTION}

The value of the special variable \cdf{*package*} must always be a package
object (not a name).  Whatever package object is currently the
value of \cdf{*package*} is referred to as the \emph{current package}.

When the Lisp reader has, by parsing, obtained a string of characters
thought to name a symbol, that name is looked up in the current package.
This lookup may involve looking in other packages whose external symbols
are inherited by the current package.  If the name is found,
the corresponding symbol is returned.  If the name is not found
(that is, there is no symbol of that name accessible in the current package),
a new symbol is created for it and is placed in the current package as an
internal symbol.  Moreover, the current package becomes the owner
(home package) of the symbol, and so the symbol becomes interned
in the current package.
If the name is later read again while this same package is
current, the same symbol will then be found and returned.

Often it is desirable to refer to an external symbol in some package
other than the current one.  This is done through the use of a
\emph{qualified name}, consisting of a package name, then a colon, then the
name of the symbol.  This causes the symbol's name to be looked up
in the specified package, rather than in the current one.  For example,
\cd{editor:buffer} refers to the external symbol named \cdf{buffer}
accessible in the package named \cdf{editor}, regardless of whether
there is a symbol named \cdf{buffer} in the current package.  If there
is no package named \cdf{editor}, or if no symbol named \cdf{buffer}
is accessible in \cdf{editor}, or if \cdf{buffer} is an internal
symbol in \cdf{editor}, the Lisp reader will signal
a correctable error to ask the user for instructions.

On rare occasions, a user may need to refer to an \emph{internal} symbol of
some package other than the current one.  It is illegal to do this with
the colon qualifier, since accessing an internal symbol of some other
package is usually a mistake.  However, this operation is legal if
a doubled colon
\cd{::} is used as the separator in place of the usual single colon.  If
\cd{editor::buffer} is seen, the effect is exactly the same as
reading \cdf{buffer} with \cdf{*package*} temporarily rebound to the
package whose name is \cdf{editor}.  This special-purpose qualifier
should be used with caution.

The package named \cdf{keyword} contains all keyword symbols used by the
Lisp system itself and by user-written code.  Such symbols must be
easily accessible from any package, and name conflicts are not an issue
because these symbols are used only as labels and never to carry
package-specific values or properties.  Because keyword symbols are used
so frequently, Common Lisp provides a special reader syntax for them.
Any symbol preceded by a colon but no package name (for example
\cd{:foo}) is added to (or looked up in) the \cdf{keyword} package as
an \emph{external} symbol.  The \cdf{keyword} package is also treated
specially in that whenever a symbol is added to the \cdf{keyword} package
the symbol is always made external; the symbol
is also automatically declared to be a constant
(see \cdf{defconstant}) and made to
have itself as its value.  This is why every keyword evaluates to
itself.  As a matter of style, keywords should always be accessed using
the leading-colon convention; the user should never import or inherit
keywords into any other package.  It is an error to try to apply
\cdf{use-package} to the \cdf{keyword} package.

Each symbol contains a package cell that is used to record the home
package of the symbol, or {\false} if the symbol is uninterned.  This cell
may be accessed by using the function \cdf{symbol-package}.
When an interned
symbol is printed, if it is a symbol in the keyword package,
then it is printed with a preceding colon; otherwise, if it is accessible
(directly or by inheritance) in the current package, it is printed
without any qualification; otherwise, it is printed with the name of the
home package as the qualifier, using \cd{:} as the separator if the
symbol is external and \cd{::} if not.

A symbol whose package slot contains {\false} (that is, has no home
package)
is printed preceded by \cd{\#:}.  It is possible, by the
use of \cdf{import} and \cdf{unintern}, to create a symbol that has no
recorded home package but that in fact is accessible in some package.
The system does not check for this pathological case, and such symbols
will always be printed preceded by \cd{\#:}.

In summary, the following four uses of symbol qualifier syntax are defined.

\begin{flushdesc}
\item[\cd{foo:bar}]
When read, looks up \cd{BAR} among the external symbols of
the package named \cd{FOO}.  Printed when symbol \cd{bar} is external in its
home package \cd{foo} and is not accessible in the current package.

\item[\cd{foo::bar}]
When read, interns \cd{BAR} as if \cd{FOO} were the
current package.  Printed when symbol \cd{bar} is internal in its home package
\cd{foo} and is not accessible in the current package.

\item[\cd{:bar}]
When read, interns \cd{BAR} as an external symbol in the
\cd{keyword} package and makes it evaluate to itself.  Printed when
the home package of symbol \cd{bar} is \cd{keyword}.
    
\item[\cd{\#:bar}]
When read, creates a new uninterned symbol named \cd{BAR}.
Printed when the symbol \cd{bar} is uninterned (has no home package),
even in the pathological case that \cd{bar} is uninterned but
nevertheless somehow accessible in the current package.
\end{flushdesc}

All other uses of colons within names of symbols are not defined by
Common Lisp but are reserved for implementation-dependent use; this
includes names that end in a colon, contain two or more colons, or
consist of just a colon.

\section{Exporting and Importing Symbols} 
\label{EXPORT-IMPORT-SECTION}

Symbols from one package may be made accessible in another package in
two ways.

First, any individual symbol may be added to a package by use
of the function \cdf{import}.  The form \cd{(import 'editor:buffer)} takes
the external symbol named \cdf{buffer} in the \cdf{editor} package (this
symbol was located when the form was read by the Lisp reader) and adds
it to the current package as an internal symbol.  The symbol is then
present in the current package.  The imported symbol is
not automatically exported from the current package, but if it is
already present and external, then the fact that it
is external is not changed.  After the call to
\cdf{import} it is possible to refer to \cdf{buffer} in the importing package
without any qualifier.  The status of \cdf{buffer} in the package named
\cdf{editor} is unchanged, and \cdf{editor} remains the home package for
this symbol.  Once imported, a symbol is \emph{present} in the
importing package and can be removed only by calling \cdf{unintern}.

If the symbol is already present in the importing package, \cdf{import}
has no effect.  If a distinct symbol with the name \cdf{buffer} is
accessible in the importing package (directly or by inheritance), then a
correctable error is signaled, as described in
section~\ref{NAME-CONFLICTS-SECTION}, because \cdf{import} avoids letting
one symbol shadow another.

A symbol is said to be \emph{shadowed} by another symbol in
some package if the first symbol would be accessible by inheritance
if not for the presence of the second symbol.
To import a symbol without the possibility
of getting an
error because of shadowing,
use the function \cdf{shadowing-import}.  This inserts
the symbol into the specified package as an internal symbol, regardless
of whether another symbol of the same name will be shadowed by this
action.
If a different symbol of the same name is already present
in the package, that symbol will first be uninterned from the package
(see \cdf{unintern}).  The new symbol is
added to the package's shadowing-symbols list.  \cdf{shadowing-import}
should be used with caution.  It changes the state of the package system
in such a way that the consistency rules do not hold across the change.

The second mechanism is provided by the function \cdf{use-package}.  This
causes a package to inherit all of the external symbols of some other
package.  These symbols become accessible as \emph{internal} symbols of the
using package.  That is, they can be referred to without a qualifier
while this package is current, but they are not passed along to any
other package that uses this package.  Note that \cdf{use-package},
unlike \cdf{import}, does not cause any new symbols to be \emph{present}
in the current package but only makes them \emph{accessible} by inheritance.
\cdf{use-package} checks carefully for
name conflicts between the newly imported symbols and those already
accessible in the importing package.  This is described in detail in
section~\ref{NAME-CONFLICTS-SECTION}.

Typically a user, working by default in the \cdf{user} package, will
load a number of packages into Lisp to provide an augmented working
environment, and then call \cdf{use-package} on each of these packages
to allow easy access to their external symbols.
\cdf{unuse-package} undoes the effects of a previous \cdf{use-package}.  The
external symbols of the used package are no longer inherited.  However,
any symbols that have been imported into the using package continue to
be present in that package.

There is no way to inherit the \emph{internal} symbols of another package;
to refer to an internal symbol, the user must either make that symbol's home
package current, use a qualifier, or import that symbol into the current
package.

\begin{newer}
The distinction between
external and internal symbols is a primary means of hiding names
so that one program does not tread on the namespace of another.
\end{newer}

When \cdf{intern} or some other function wants to look up a symbol in a
given package, it first looks for the symbol among the external and
internal symbols of the package itself; then it looks through the
external symbols of the used packages in some unspecified order.  The
order does not matter; according to the rules for handling name
conflicts (see below), if conflicting symbols appear in two or more
packages inherited by package \emph{X}, a symbol of this name must also appear
in \emph{X} itself as a shadowing symbol.  Of course, implementations are free
to choose other, more efficient ways of implementing this search, as
long as the user-visible behavior is equivalent to what is described
here.

The function \cdf{export} takes a symbol that is accessible in some
specified package (directly or by inheritance) and makes it an external
symbol of that package.  If the symbol is already accessible as an
external symbol in the package, \cdf{export} has no effect.  If the symbol
is directly present in the package as an internal symbol, it is simply
changed to external status.  If it is accessible as an internal symbol
via \cdf{use-package}, the symbol is first imported into the package, then
exported.  (The symbol is then present in the specified package
whether or not the package
continues to use the package through which the symbol was originally
inherited.)  If the symbol is not
accessible at all in the specified package, a correctable error is
signaled that, upon continuing, asks the user whether the symbol
should be imported.

The function \cdf{unexport} is provided mainly as a way to undo erroneous
calls to \cdf{export}.  It works only on symbols directly present
in the current package, switching them back to internal status.  If
\cdf{unexport} is given a symbol already accessible as an internal
symbol in the current package, it does nothing; if it is given a symbol
not accessible in the package at all, it signals an error.

\section{Name Conflicts}
\label{NAME-CONFLICTS-SECTION}

A fundamental invariant of the package system is that within one package
any particular name can refer to at most one symbol.  A \emph{name conflict}
is said to occur when there is more than one candidate symbol and it is
not obvious which one to choose.  If the system does not always choose
the same way, the read-read consistency rule would be violated.  For
example, some programs or data might have been read in under a certain
mapping of the name to a symbol.  If the mapping changes to a different
symbol, and subsequently additional programs or data are read,
then the two programs will
not access the same symbol even though they use the same name.  Even if
the system did always choose the same way, a name conflict is likely to
result in a mapping from names to symbols different from what was expected by
the user, causing programs to execute incorrectly.  Therefore, any time
a name conflict is about to occur,
an error is signaled.  The user may continue
from the error and tell the package system how to resolve the conflict.

It may be that the same symbol is accessible to a package through more than
one path.  For example, the symbol might be
an external symbol of more than one used package, or the symbol
might be directly present in a package and also inherited from
another package.
In such cases there is no name conflict.
The same identical symbol cannot conflict with itself.
Name conflicts occur only between distinct symbols with
the same name.

The creator of a package can tell the system in advance how to resolve a
name conflict through the use of \emph{shadowing}.  Every package has a
list of shadowing symbols.  A shadowing symbol takes precedence over any
other symbol of the same name that would otherwise be accessible to the
package.  A name conflict involving a shadowing symbol is always
resolved in favor of the shadowing symbol, without signaling an error
(except for one instance involving \cdf{import} described below).  The
functions \cdf{shadow} and \cdf{shadowing-import} may be used to declare
shadowing symbols.

Name conflicts are detected when they become possible, that is, when the
package structure is altered.  There is no need to check for name
conflicts during every name lookup.

The functions \cdf{use-package}, \cdf{import}, and \cdf{export} check for name
conflicts.  \cdf{use-package} makes the external symbols of the package
being used accessible to the using package; each of these symbols is
checked for name conflicts with the symbols already accessible.
\cdf{import} adds a single symbol to the internals of a package, checking
for a name conflict with an existing symbol either present in the
package or accessible to it.  \cdf{import} signals a name conflict error
even if the conflict is with a shadowing symbol, the rationale being
that the user has given two explicit and inconsistent directives.
\cdf{export} makes a single
symbol accessible to all the packages that use the package from which
the symbol is exported.  All of these packages are checked for
name conflicts:  \cd{(export \emph{s} \emph{p})} does
\cd{(find-symbol (symbol-name \emph{s}) \emph{q})} for each package \emph{q}
in \cd{(package-used-by-list \emph{p})}.  Note that in the usual case of
an \cdf{export} during the initial definition of a package, the
result of \cdf{package-used-by-list}
will be {\false} and the name-conflict checking
will take negligible time.

The function \cdf{intern}, which is the one used most
frequently by the Lisp reader for looking up names of symbols,
does not need to do any name-conflict checking, because it
never creates a new symbol if there is already an accessible symbol with
the name given.

\cdf{shadow} and \cdf{shadowing-import} never signal a name-conflict error
because the user, by calling these functions, has specified how any
possible conflict is to be resolved.  \cdf{shadow} does name-conflict
checking to the extent that it checks whether a distinct existing symbol with
the specified name is accessible and, if so, whether it is directly
present in the package or inherited.  In the latter case, a new symbol
is created to shadow it.  \cdf{shadowing-import} does name-conflict
checking to the extent that it checks whether a distinct existing
symbol with the same name is accessible; if so, it is shadowed by
the new symbol, which implies that it must be uninterned
if it was directly present in the package.

\cdf{unuse-package}, \cdf{unexport}, and \cdf{unintern} (when the symbol being
uninterned is not a shadowing symbol) do not need to do any
name-conflict checking because they only remove symbols from a package;
they do not make any new symbols accessible.

Giving a shadowing symbol to \cdf{unintern} can uncover a name conflict that had
previously been resolved by the shadowing.  If package A uses packages
B and C, A contains a shadowing symbol \cdf{x}, and B and C each contain external
symbols named \cdf{x}, then removing the shadowing symbol \cdf{x}
from A will reveal a name
conflict between \cd{b:x} and \cd{c:x} if those two symbols are distinct.
In this case \cdf{unintern} will signal an error.

Aborting from a name-conflict error leaves the original symbol accessible.
Package functions always signal name-conflict errors before making any
change to the package structure.  When multiple changes are to be made,
however, for example when \cdf{export} is given a list of symbols, it is
permissible for the implementation to process each change separately,
so that aborting from a name
conflict caused by the second symbol in the list will not unexport the
first symbol in the list.  However, aborting from a name-conflict error
caused by \cdf{export} of a single symbol will not leave that symbol accessible
to some packages and inaccessible to others; with respect to
each symbol processed, \cdf{export}
behaves as if it were an atomic operation.

Continuing from a name-conflict error should offer the user a chance to
resolve the name conflict in favor of either of the candidates.  The
package structure should be altered to reflect the resolution of the
name conflict, via \cdf{shadowing-import}, \cdf{unintern}, or \cdf{unexport}.

A name conflict in \cdf{use-package} between a symbol directly present in the
using package and an external symbol of the used package may be resolved
in favor of the first symbol by making it a shadowing symbol, or in favor
of the second symbol by uninterning the first symbol from the using
package.  The latter resolution is dangerous if the symbol to be
uninterned is an external symbol of the using package, since it
will cease to be an external symbol.

A name conflict in \cdf{use-package} between two external symbols inherited
by the using package from other packages may be resolved in favor of
either symbol by importing it into the using package and making it a
shadowing symbol.

A name conflict in \cdf{export} between the symbol being exported and a
symbol already present in a package that would inherit the
newly exported symbol may be resolved in favor of the exported symbol
by uninterning the other one, or in favor of the already-present
symbol by making it a shadowing symbol.

A name conflict in \cdf{export} or \cdf{unintern} due to a package
inheriting two distinct symbols with the same name from two other
packages may be resolved in favor of either symbol by importing it into
the using package and making it a shadowing symbol, just as with
\cdf{use-package}.

A name conflict in \cdf{import} between the symbol being imported and a
symbol inherited from some other package may be resolved in favor of the
symbol being imported by making it a shadowing symbol, or in favor
of the symbol already accessible by not doing the \cdf{import}.  A
name conflict in \cdf{import} with a symbol already present in the
package may be resolved by uninterning that symbol, or by not
doing the \cdf{import}.

Good user-interface style dictates that \cdf{use-package} and \cdf{export},
which can cause many name conflicts simultaneously, first check for
all of the name conflicts before presenting any of them to the user.
The user may then choose to resolve all of them wholesale or to resolve
each of them individually, the latter requiring a lot of
interaction but permitting
different conflicts to be resolved different ways.

Implementations may offer other ways of resolving name conflicts.
For instance, if the symbols that conflict are not being used as
objects but only as names for functions, it may be possible to ``merge''
the two symbols by putting the function definition onto both symbols.
References to either symbol for purposes of calling a function would be
equivalent.  A similar merging operation can be done for variable values
and for things stored on the property list.  In Lisp Machine Lisp, for example, one can
also \emph{forward} the value, function, and property cells so that future
changes to either symbol will propagate to the other one.  Some other
implementations are able to do this with value cells but not with
property lists.  Only the user can know whether this way of resolving
a name conflict is adequate, because it will work only if
the use of two non-\cdf{eq}
symbols with the same name will not prevent the correct operation of
the program.  The value of offering symbol merging as a way of resolving
name conflicts is that it can avoid the need to throw away the whole
Lisp world, correct the package-definition forms
that caused the error, and start over from scratch.

\section{Built-in Packages}

\begin{flushdesc}
\item[\cdf{common-lisp}]
The package named \cdf{common-lisp} contains the primitives of the
ANSI Common Lisp system (as opposed to a Common Lisp system based
on the 1984 specification).  Its external symbols include all of the
user-visible functions and global variables that are present in the
ANSI Common Lisp system, such as \cdf{car}, \cdf{cdr}, and \cdf{*package*}.
Note, however, that the home package of such symbols is not
necessarily the \cdf{common-lisp} package (this makes it easier for
symbols such as \cdf{t} and \cdf{lambda} to be shared between
the \cdf{common-lisp} package and another package, possibly one named \cdf{lisp}).
Almost all other packages ought to use \cdf{common-lisp} so that these
symbols will be accessible without qualification.
This package has the nickname \cdf{cl}.

\item[\cdf{common-lisp-user}]
The \cdf{common-lisp-user} package is, by default,
the current package at the time an ANSI Common Lisp system starts up.
This package uses the \cdf{common-lisp} package
and has the nickname \cdf{cl-user}.
It may contain other implementation-dependent symbols
and may use other implementation-specific packages.
\end{flushdesc}

\begin{flushdesc}
\item[\cd{keyword}]
This package contains all of the keywords used by built-in
or user-defined Lisp functions.  Printed symbol representations
that start with a colon are interpreted as referring to symbols
in this package, which are always external symbols.  All symbols in this
package are treated as constants that evaluate to themselves, so that the
user can type \cd{:foo} instead of \cd{':foo}.
\end{flushdesc}

\begin{new}
X3J13 voted in January 1989
\issue{PACKAGE-CLUTTER}
to modify the requirements on the built-in packages
so as to limit what may appear in the \cdf{common-lisp} package
and to lift the requirement that every implementation have a package
named \cdf{system}.  The details are as follows.

Not only must the \cdf{common-lisp} package in any given implementation
contain all the external symbols prescribed by the standard;
the \cdf{common-lisp} package moreover may not contain any external symbol
that is not prescribed by the standard.  However, the \cdf{common-lisp}
package may contain additional internal symbols, depending on the
implementation.

An external symbol of the \cdf{common-lisp} package may not have a function,
macro, or special form definition, or a top-level value,
or a \cdf{special} proclamation, or a type definition, unless specifically
permitted by the standard.  Programmers may validly rely on this fact;
for example, \cdf{fboundp} is guaranteed to be false for all
external symbols of the \cdf{common-lisp} package except those explicitly
specified in the standard to name functions, macros, and special forms.
Similarly, \cdf{boundp} will be false of all such external symbols
except those documented to be variables or constants.

Portable programs
may use external symbols in the \cdf{common-lisp} package that are not documented
to be constants or variables as names of local lexical
variables with the presumption that the implementation has not
proclaimed such variables to be special; this legitimizes the common
practice of using such names as \cdf{list} and \cdf{string} as names
for local variables.

A valid implementation may initially have properties on any symbol,
or dynamically put new properties on symbols (even user-created symbols),
as long as no property indicator used for this purpose is
an external symbol of any package defined by the standard
or a symbol that is accessible from the \cdf{common-lisp-user} package or any
package defined by the user.

This vote eliminates the requirement that every implementation have
a predefined package named \cdf{system}.  An implementation may
provide any number of predefined packages; these should be described
in the documentation for that implementation.

The \cdf{common-lisp-user} package may contain symbols not described by the standard
and may use other implementation-specific packages.
\end{new}

\begin{newer}
X3J13 voted in March 1989 \issue{LISP-SYMBOL-REDEFINITION}
to restrict user programs from performing certain actions that
might interfere with built-in facilities or interact badly
with them.
Except where explicitly allowed, the consequences are undefined if any
of the following actions are performed on a symbol in the \cdf{common-lisp}
package.
\begin{itemize}
\item binding or altering its value (lexically or dynamically)
\item defining or binding it as a function
\item defining or binding it as a macro
\item defining it as a type specifier (\cdf{defstruct}, \cdf{defclass}, \cdf{deftype})
\item defining it as a structure (\cdf{defstruct})
\item defining it as a declaration
\item design it as a symbol macro FIXME
\item altering its print name
\item altering its package
\item tracing it
\item declaring or proclaiming it special or lexical
\item declaring or proclaiming its \cdf{type} or \cdf{ftype}
\item removing it from the package \cdf{common-lisp}
\end{itemize}
X3J13 also voted in June 1989 \issue{DEFINE-COMPILER-MACRO}
to add to this list the item
\begin{itemize}
\item defining it as a compiler macro
\end{itemize}

If such a symbol is not globally defined as a variable or a constant,
a user program is allowed to lexically bind it and declare the \cdf{type} of
that binding.

If such a symbol is not defined as a function, macro, or special form,
a user program is allowed to (lexically) bind it as a function and to declare the
\cdf{ftype} of that binding and to trace that binding.

If such a symbol is not defined as a function, macro, or special form,
a user program is allowed to (lexically) bind it as a macro.

As an example, the behavior of the code fragment
\begin{lisp}
(flet ((open (filename \&key direction) \\*
~~~~~~~~~(format t "{\Xtilde}\%OPEN was called.")  \\*
~~~~~~~~~(open filename :direction direction))) \\*
~~(with-open-file (x "frob" :direction ':output)  \\*
~~~~(format t "{\Xtilde}\%Was OPEN called?")))
\end{lisp}
is undefined.  Even in a ``reasonable'' implementation,
for example, the macro expansion of \cdf{with-open-file} might refer
to the \cdf{open} function and might not.  However, the preceding rules eliminate
the burden of deciding whether an implementation is reasonable. The code
fragment violates the rules; officially its behavior is therefore
completely undefined, and that's that.

Note that ``altering the property list'' is not in the list of
proscribed actions, so a user program \emph{is} permitted to
add properties to or remove properties from
symbols in the \cdf{common-lisp} package.
\end{newer}

\section{Package System Functions and Variables}
\label{PACKAGE-FUNCTIONS-SECTION}

\beforenoterule
\begin{implementation}
In the past, some Lisp compilers have read
the entire file into Lisp before processing any of the forms.  
Other compilers have arranged for
the loader to do all of its intern operations before evaluating any of the
top-level forms.  Neither of these techniques will work in a
straightforward way in Common Lisp because of the presence of multiple
packages.
\end{implementation}
\afternoterule

For the functions described here, all optional arguments named
\emph{package} default to the current value of \cdf{*package*}.  Where a
function takes an argument that is either a symbol or a list of symbols,
an argument of {\false} is treated as an empty list of symbols.  Any
argument described as a package name may be either a string or a symbol.
If a symbol is supplied, its print name will be used as the package
name; if a string is supplied, the user must take care to specify the
same capitalization used in the package name, normally all uppercase.

\begin{defun}[Variable]
*package*

The value of this variable must be a package; this package is said to be
the current package.  The initial value of \cdf{*package*} is the \cdf{user}
package.

The functions \cdf{load} and \cdf{compile-file} rebind \cdf{*package*} to its current value.  If
some form in the file changes the value of \cdf{*package*} during loading or
compilation, the old value will be restored when the loading is completed. 
\end{defun}

\begin{defun}[Function]
make-package package-name &key :nicknames :use

This creates and returns a new package with the specified package name.  As
described above, this argument may be either a string or a symbol.  The
\cd{:nicknames} argument must be a list of strings to be used as
alternative names for the package.  Once again, the user may supply
symbols in place of the strings, in which case the print names of the
symbols are used.  These names and nicknames must not conflict with
any existing package names; if they do, a correctable error is
signaled.

The \cd{:use} argument is a list of packages or the names (strings or
symbols) of packages whose external symbols are to be inherited by the
new package.  These packages must already exist.  If not supplied,
\cd{:use} defaults to a list of one package, the \cdf{lisp} package.
\end{defun}

\begin{defmac}
in-package name

This macro causes \cdf{*package*} to be set to the package named \emph{name},
    which must be a symbol or string.  The \emph{name} is not evaluated.
    An error is signaled if the
    package does not already exist.  Everything this macro does is also
    performed at compile time if the call appears at top level.

\cdf{in-package} returns the new package, that is, the
value of \cdf{*package*} after the operation has been executed.
\end{defmac}

\begin{defun}[Function]
find-package name

The \emph{name} must be a string that is the name or nickname for a
package.  This argument may also be a symbol, in which case the symbol's
print name is used.  The package with that name or nickname
is returned; if no such package exists, \cdf{find-package} returns {\false}.
The matching of names observes case (as in \cdf{string=}).

\emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
package-name package

The argument must be a package.  This function returns the string that
names that package.

\emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).

\cdf{package-name} returns \cdf{nil} instead of the package if the package has been
removed. See \cdf{delete-package}.
\end{defun}

\begin{defun}[Function]
package-nicknames package

The argument must be a package.  This function returns the list of
nickname strings for that package, not including the primary name.

\emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
rename-package package new-name &optional new-nicknames

The old name and all of the old nicknames of \emph{package} are eliminated
and are replaced by \emph{new-name} and \emph{new-nicknames}.  The
\emph{new-name} argument is a string or symbol; the \emph{new-nicknames}
argument, which defaults to {\false}, is a list of strings or symbols.

\emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
package-use-list package

A list of other packages used by the argument package is returned.

\emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
package-used-by-list package

A list of other packages that use the argument package is returned.

\emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
package-shadowing-symbols package

A list is returned of symbols that have been declared as shadowing
symbols in this package by \cdf{shadow} or \cdf{shadowing-import}.  All
symbols on this list are present in the specified package.

\emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
list-all-packages 

This function returns a list of all packages that currently exist in the
Lisp system.
\end{defun}

\begin{defun}[Function]
delete-package package

The \cdf{delete-package} function 
deletes the specified \emph{package} from all package system data structures.
The \emph{package} argument may be either a package or the name of a package.

If \emph{package} is a name but there is currently no package of that name,
a correctable error is signaled.  Continuing from the error makes
no deletion attempt but merely returns \cdf{nil} from the call to
\cdf{delete-package}.

If \emph{package} is a package object that has already been deleted,
no error is signaled and no deletion is attempted; instead,
\cdf{delete-package} immediately returns \cdf{nil}.

If the package specified for deletion is currently used by other packages,
a correctable error is signaled.  Continuing from this error,
the effect of the function \cdf{unuse-package} is performed on all
such other packages so as to remove their dependency on the
specified package, after which \cdf{delete-package} proceeds to
delete the specified package as if no other package had been using it.

If any symbol had the specified package as its home package before
the call to \cdf{delete-package}, then its home package is unspecified
(that is, the contents of its package cell are unspecified)
after the \cdf{delete-package} operation has been completed.
Symbols in the deleted package are not modified in any other way.

The name and nicknames of the \emph{package} cease to be recognized package
names.  The package object is still a package, but anonymous; \cdf{packagep} will
be true of it, but \cdf{package-name} applied to it will return \cdf{nil}.

The effect of any other package operation on a deleted package object
is undefined.  In particular, an attempt to locate a symbol within a
deleted package (using \cdf{intern} or \cdf{find-symbol}, for example)
will have unspecified results.

\cdf{delete-package} returns \cdf{t} if the deletion succeeds,
and \cdf{nil} otherwise.
\end{defun}

\begin{defun}[Function]
intern string &optional package

The \emph{package}, which defaults to the current package, is
searched for a symbol with the name specified by the \emph{string}
argument.  This search will include inherited symbols, as described
in section~\ref{EXPORT-IMPORT-SECTION}.
If a symbol with the specified name is found, it is returned.
If no such symbol is found, one is created and is installed in the
specified package as an internal symbol (as an external symbol
if the package is the \cdf{keyword} package); the specified package becomes the
home package of the created symbol.

\begin{newer}
X3J13 voted in March 1989 \issue{CHARACTER-PROPOSAL}
to specify that \cdf{intern} may in effect perform the
search using a copy of the argument string in which
some or all of the implementation-defined
attributes have been removed from the characters of the string.
It is implementation-dependent which attributes are removed.
\end{newer}

Two values are returned.  The first is the symbol that was found or
created.  The second value is {\false} if no pre-existing symbol was found,
and takes on one of three values if a symbol was found:
\begin{indentdesc}{6pc}
\item[\cd{:internal}]
The symbol was directly present in the package as an internal symbol.

\item[\cd{:external}]
The symbol was directly present as an external symbol.

\item[\cd{:inherited}]
The symbol was inherited via \cdf{use-package} (which
implies that the symbol is internal).
\end{indentdesc}

\emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
find-symbol string &optional package

This is identical to \cdf{intern}, but it never creates a new symbol.  If
a symbol with the specified name is found in the specified package,
directly or by inheritance, the symbol found is returned as the first
value and the second value is as specified for \cdf{intern}.  If the
symbol is not accessible in the specified package, both values are
{\false}.

\emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
unintern symbol &optional package

If the specified symbol is present in the specified \emph{package}, it is
removed from that package and also from the package's shadowing-symbols
list if it is present there.  Moreover, if the \emph{package} is the home
package for the symbol, the symbol is made to have no home package.
Note that in some circumstances the symbol may continue to be accessible
in the specified package by inheritance.
\cdf{unintern} returns {\true} if it actually removed a symbol,
and {\false} otherwise.

\cdf{unintern} should be used with caution.  It changes the state of the
package system in such a way that the consistency rules do not hold
across the change.

\emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
export symbols &optional package

The \emph{symbols} argument should be a list of symbols, or possibly a single
symbol.  These symbols become accessible as external symbols in
\emph{package} (see section~\ref{EXPORT-IMPORT-SECTION}).
\cdf{export} returns {\true}.

By convention, a call to \cdf{export} listing all exported symbols is
placed near the start of a file to advertise which of the symbols
mentioned in the file are intended to be used by other programs.

\emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
unexport symbols &optional package

The \emph{symbols} argument should be a list of symbols, or possibly a single symbol.
These symbols become internal symbols in \emph{package}.
It is an error to unexport a symbol from the \cdf{keyword} package
(see section~\ref{EXPORT-IMPORT-SECTION}).
\cdf{unexport} returns {\true}.

The \emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
import symbols &optional package

The argument should be a list of symbols, or possibly a single symbol.
These symbols become internal symbols in \emph{package} and can therefore
be referred to without having to use qualified-name (colon) syntax.
\cdf{import} signals a
correctable error if any of the imported symbols has the same name as
some distinct symbol already accessible in the package
(see section~\ref{EXPORT-IMPORT-SECTION}).
\cdf{import} returns {\true}.

If any symbol to be imported has no home package
then \cdf{import} sets the home package of the symbol to the
\emph{package} to which the symbol is being imported.

The \emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
shadowing-import symbols &optional package

This is like \cdf{import}, but it does not signal an error even if the
importation of a symbol would shadow some symbol already accessible in
the package.  In addition to being imported, the symbol is placed on the
shadowing-symbols list of \emph{package}
(see section~\ref{NAME-CONFLICTS-SECTION}).
\cdf{shadowing-import} returns {\true}.

\cdf{shadowing-import} should be used with
caution.  It changes the state of the package system in such a way that
the consistency rules do not hold across the change.

The \emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
shadow symbols &optional package

The argument should be a list of symbols, or possibly a single symbol.
The print name of each symbol is extracted, and the specified \emph{package} is
searched for a symbol of that name.  If such a symbol is present in this
package (directly, not by inheritance), then nothing is done.  Otherwise,
a new symbol is created with this print name, and it is inserted in the
\emph{package} as an internal symbol.  The symbol is also placed on the
shadowing-symbols list of the \emph{package}
(see section~\ref{NAME-CONFLICTS-SECTION}).
\cdf{shadow} returns {\true}.

\cdf{shadow} should be used with
caution.  It changes the state of the package system in such a way that
the consistency rules do not hold across the change.

The \emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
use-package packages-to-use &optional package

The \emph{packages-to-use} argument should be a list of packages or package
names, or possibly a single package or package name.  These packages are
added to the use-list of \emph{package} if they are not there already.  All
external symbols in the packages to use become accessible in \emph{package}
as internal symbols
(see section~\ref{EXPORT-IMPORT-SECTION}).
It is an error to try to use the \cdf{keyword} package.
\cdf{use-package} returns {\true}.

The \emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defun}[Function]
unuse-package packages-to-unuse &optional package

The \emph{packages-to-unuse} argument should be a list of packages or
package names, or possibly a single package or package name.  These
packages are removed from the use-list of \emph{package}.
\cdf{unuse-package} returns {\true}.

The \emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).
\end{defun}

\begin{defmac}
defpackage defined-package-name {option}*

This creates a new package, or modifies an existing one, whose name
is \emph{defined-package-name}.  The \emph{defined-package-name}
may be a string or a symbol;
if it is a symbol, only its print name matters, and not what package, if any,
the symbol happens to be in.
The newly created or modified package is returned as the value of
the \cdf{defpackage} form.

Each standard \emph{option} is a list of a keyword (the name of the option)
and associated arguments.  No part of a \cdf{defpackage} form is evaluated.
Except for the \cd{:size} option, more than one option of the same
kind may occur within the same \cdf{defpackage} form.

The standard options for \cdf{defpackage} are as follows.
In every case, any option argument called \emph{package-name}
or \emph{symbol-name}
may be a string or a symbol;
if it is a symbol, only its print name matters, and not what package, if any,
the symbol happens to be in.

\begin{flushdesc}
\item[\cd{(:size \emph{integer})}]
This specifies approximately the number of symbols expected to be in the
package.  This is purely an efficiency hint to the storage allocator,
so that implementations using hash tables as part
of the package data structure (the usual technique) will not
have to incrementally expand the package as new symbols are added to it
(for example, as a large file is read while ``in'' that package).

\item[\cd{(:nicknames \Mstar\emph{package-name})}]
The specified names become nicknames of the package being defined.
If any of the specified nicknames already refers to an existing
package, a continuable error is signaled exactly as for the
function \cdf{make-package}.

\item[\cd{(:shadow \Mstar\emph{symbol-name})}]
Symbols with the specified names are created as shadows
in the package being defined, just as with the function \cdf{shadow}.

\item[\cd{(:shadowing-import-from \emph{package-name} \Mstar\emph{symbol-name})}]
Symbols with the specified names are located in the specified package.
These symbols are imported into the package being defined, shadowing
other symbols if necessary, just as with the function \cdf{shadowing-import}.
In no case will symbols be created in a package other than
the one being defined;
a continuable error is signaled if for any \emph{symbol-name} there
is no symbol of that name accessible in the package named \emph{package-name}.

\item[\cd{(:use \Mstar\emph{package-name})}]
The package being defined is made to ``use'' (inherit from)
the packages specified by this option, just as with
the function \cdf{use-package}.
If no \cd{:use} option is supplied, then option is unspecified.

\item[\cd{(:import-from \emph{package-name} \Mstar\emph{symbol-name})}]
Symbols with the specified names are located in the specified package.
These symbols are imported into the package being defined,
just as with the function \cdf{import}.
In no case will symbols be created in a package other than
the one being defined;
a continuable error is signaled if for any \emph{symbol-name} there
is no symbol of that name accessible in the package named \emph{package-name}.

\item[\cd{(:intern \Mstar\emph{symbol-name})}]
Symbols with the specified names are located or created
in the package being defined, just as with the function
\cdf{intern}.  Note that the action of this option may be
affected by a \cd{:use}
option, because an inherited symbol will be used in preference
to creating a new one.

\item[\cd{(:export \Mstar\emph{symbol-name})}]
Symbols with the specified names are located or created
in the package being defined and then exported, just as with the function
\cdf{export}.  Note that the action of this option may be
affected by a \cd{:use}, \cd{:import-from}, or \cd{:shadowing-import-from}
option, because an inherited or imported symbol will be used in preference
to creating a new one.
\end{flushdesc}

The order in which options appear in a \cdf{defpackage} form does not matter;
part of the convenience of \cdf{defpackage} is that it sorts out the options
into the correct order for processing.
Options are processed in the following order:
\begin{tabbing}
1.~~\cd{:shadow} and \cd{:shadowing-import-from} \\
2.~~\cd{:use} \\
3.~~\cd{:import-from} and \cd{:intern} \\
4.~~\cd{:export}
\end{tabbing}
Shadows are established first in order to avoid spurious name conflicts
when use links are established.  Use links must occur before importing
and interning so that those operations may refer to normally inherited
symbols rather than creating new ones.  Exports are performed last so that
symbols created by any of the other options, in particular,
shadows and imported symbols, may be exported.  Note that exporting an
inherited symbol implicitly imports it first
(see section~\ref{EXPORT-IMPORT-SECTION}).

If no package named \emph{defined-package-name} already exists,
\cdf{defpackage} creates it.  If such a package does already exist,
then no new package is created.  The existing package is
modified, if possible, to reflect the new definition.  The results are
undefined if the new definition is not consistent with the current
state of the package.

An error is signaled if more than one \cd{:size} option appears.
  \cd{:size}      .

An error is signaled if the same \cdf{symbol-name} argument (in the sense
of comparing names with \cdf{string=}) appears more than once among
the arguments to all the \cd{:shadow}, \cd{:shadowing-import-from},
\cd{:import-from}, and \cd{:intern} options.

An error is signaled if the same \cdf{symbol-name} argument (in the sense
of comparing names with \cdf{string=}) appears more than once among
the arguments to all the \cd{:intern} and \cd{:export} options.

Other kinds of name conflicts are handled in the same manner that
the underlying operations \cdf{use-package}, \cdf{import}, and \cdf{export}
would handle them.

Implementations may support other \cdf{defpackage} options.
Every implementation should signal an error on encountering
a \cdf{defpackage} option it does not support.

The function \cdf{compile-file} should treat top-level \cdf{defpackage}
forms in the same way it would treat top-level calls to package-affecting
functions (as described at the beginning of
section~\ref{PACKAGE-FUNCTIONS-SECTION}).

Here is an example of a call to \cdf{defpackage} that ``plays it safe''
by using only strings as names.
\begin{lisp}
(cl:defpackage "MY-VERY-OWN-PACKAGE" \\*
~~(:size 496) \\*
~~(:nicknames "MY-PKG" "MYPKG" "MVOP") \\*
~~(:use "COMMON-LISP") \\
~~(:shadow "CAR" "CDR") \\*
~~(:shadowing-import-from "BRAND-X-LISP" "CONS") \\*
~~(:import-from "BRAND-X-LISP" "GC" "BLINK-FRONT-PANEL-LIGHTS") \\*
~~(:export "EQ" "CONS" "MY-VERY-OWN-FUNCTION"))
\end{lisp}
The preceding \cdf{defpackage} example is designed to operate correctly
even if the package current when the form is read happens not to
``use'' the \cdf{common-lisp} package.  (Note the use in this example
of the nickname \cdf{cl} for the \cdf{common-lisp} package.)
Moreover, neither reading in nor evaluating
this \cdf{defpackage} form will ever create any symbols in the
current package.  Note too the use of uppercase letters in the strings.

Here, for the sake of contrast, is a rather similar use of
\cdf{defpackage} that ``plays the whale'' by using all sorts of
permissible syntax.
\begin{lisp}
(defpackage my-very-own-package \\*
~~(:export :EQ common-lisp:cons my-very-own-function) \\*
~~(:nicknames "MY-PKG" \#:MyPkg) \\*
~~(:use "COMMON-LISP") \\
~~(:shadow "CAR") \\*
~~(:size 496) \\*
~~(:nicknames mvop) \\
~~(:import-from "BRAND-X-LISP" "GC" Blink-Front-Panel-Lights) \\
~~(:shadow common-lisp::cdr) \\*
~~(:shadowing-import-from "BRAND-X-LISP" CONS))
\end{lisp}
This example has exactly the same effect on the newly created package
but may create useless symbols in other packages.
The use of explicit package tags is particularly confusing;
for example, this \cdf{defpackage} form will cause the symbol
\cdf{cdr} to be shadowed \emph{in the new package}; it will not be
shadowed in the package \cdf{common-lisp}.  The fact that the name ``\cdf{CDR}''
was specified by a package-qualified reference to a symbol in the
\cdf{common-lisp} package is a red herring.
The moral is that the syntactic flexibility of \cdf{defpackage},
as in other parts of Common Lisp,
yields considerable convenience when used with commonsense competence,
but unutterable confusion when used with Malthusian profusion.

\beforenoterule
\begin{implementation}
An implementation of \cdf{defpackage} might choose to transform
all the \emph{package-name} and \emph{symbol-name} arguments
into strings at macro expansion time, rather than at the time
the resulting expansion is executed, so that even if source code
is expressed in terms of strange symbols in the \cdf{defpackage} form,
the binary file resulting from compiling the source code would
contain only strings.  The purpose of this is simply to minimize
the creation of useless symbols in production code.  This technique
is permitted as an implementation strategy but is not a
behavior required by the specification of \cdf{defpackage}.
\end{implementation}
\afternoterule

Note that \cdf{defpackage} is not capable by itself of defining
mutually recursive packages, for example two packages each of
which uses the other.  However, nothing prevents one from using
\cdf{defpackage} to perform much of the initial setup and then
using functions such as \cdf{use-package}, \cdf{import}, and \cdf{export}
to complete the links.

The purpose of \cdf{defpackage} is to encourage the user to
put the entire definition of a package and its relationships to
other packages in a single place.  It may also encourage the designer
of a large system to place the definitions of all relevant packages
into a single file (say) that can be loaded before loading or compiling
any code that depends on those packages.  Such a file, if carefully
constructed, can simply be loaded into the \cdf{common-lisp-user} package.

Implementations and programming environments may also be better able
to support the programming process (if only by providing better
error checking) through global knowledge of the intended package setup.
\end{defmac}

\begin{defun}[Function]
find-all-symbols string-or-symbol

\cdf{find-all-symbols}
searches every package in the Lisp system to find
every symbol whose print name is the
specified string.  A list of all such symbols found is returned.
This search is case-sensitive.
If the argument is a symbol, its print name supplies
the string to be searched for.
\end{defun}

\begin{defmac}
do-symbols (var [package [result-form]])
           {declaration}* {tag | statement}*

\cdf{do-symbols} provides straightforward iteration over the symbols of a
package.  The body is performed once for each symbol accessible in the
\emph{package}, in no particular order, with the variable \emph{var} bound to
the symbol.  Then \emph{result-form} (a single form, \emph{not} an implicit
\cdf{progn}) is evaluated, and the result is the value of the
\cdf{do-symbols} form.  (When the \emph{result-form} is evaluated, the control
variable \emph{var} is still bound and has the value {\false}.)  If the
\emph{result-form} is omitted, the result is {\false}.  \cdf{return} may be used
to terminate the iteration prematurely.  If execution of the body affects
which symbols are contained in the \emph{package}, other than possibly to
remove the symbol currently the value of \emph{var} by using \cdf{unintern},
the effects are unpredictable.

The \emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).

\begin{new}
X3J13 voted in March 1988
\issue{DO-SYMBOLS-DUPLICATES}
to specify that the body of a \cdf{do-symbols}
form may be executed more than once for the same accessible symbol, and users
should take care to allow for this possibility.

The point is that the same symbol might be accessible via more than one
chain of inheritance, and it is implementationally costly to eliminate
such duplicates.  Here is an example:
\begin{lisp}
(setq *a* (make-package 'a))~~~~~~;\textrm{Implicitly uses package \cdf{common-lisp}} \\*
(setq *b* (make-package 'b))~~~~~~;\textrm{Implicitly uses package \cdf{common-lisp}} \\*
(setq *c* (make-package 'c :use '(a b))) \\
\\
(do-symbols (x *c*) (print x))~~~~;\textrm{Symbols in package \cdf{common-lisp}} \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;~\textrm{might be printed once or twice here}
\end{lisp}

X3J13 voted in January 1989
\issue{MAPPING-DESTRUCTIVE-INTERACTION}
to restrict user side effects; see section~\ref{STRUCTURE-TRAVERSAL-SECTION}.
\end{new}
\begin{new}
Note that the \cdf{loop} construct provides a kind of \cdf{for} clause that
can iterate over the symbols of a package (see chapter~\ref{LOOP}).
\end{new}
\end{defmac}

\begin{defmac}
do-external-symbols (var [package [result]])
                    {declaration}* {tag | statement}*

\cdf{do-external-symbols} is just like \cdf{do-symbols}, except that only
the external symbols of the specified package are scanned.

\begin{new}
The clarification voted by X3J13
in March 1988 for \cdf{do-symbols}
\issue{DO-SYMBOLS-DUPLICATES},
regarding redundant executions of the body for the same symbol,
applies also to \cdf{do-external-symbols}.
\end{new}

The \emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).

\begin{new}
X3J13 voted in January 1989
\issue{MAPPING-DESTRUCTIVE-INTERACTION}
to restrict user side effects; see section~\ref{STRUCTURE-TRAVERSAL-SECTION}.
\end{new}
\end{defmac}

\begin{defmac}
do-all-symbols (var [result-form])
               {declaration}* {tag | statement}*

This is similar to \cdf{do-symbols} but executes the body once for every
symbol contained in every package.  (This will not process every symbol
whatsoever, because a symbol not accessible in any package will not
be processed.  Normally, uninterned symbols are not accessible in any package.)
It is \emph{not} in general
the case that each symbol is processed only once, because a symbol may
appear in many packages.

\begin{new}
The clarification voted by X3J13
in March 1988 for \cdf{do-symbols}
\issue{DO-SYMBOLS-DUPLICATES},
regarding redundant executions of the body for the same symbol,
applies also to \cdf{do-all-symbols}.
\end{new}

The \emph{package} argument may be either a package object
or a package name (see section~\ref{PACKAGE-NAMES-SECTION}).

\begin{new}
X3J13 voted in January 1989
\issue{MAPPING-DESTRUCTIVE-INTERACTION}
to restrict user side effects; see section~\ref{STRUCTURE-TRAVERSAL-SECTION}.
\end{new}
\end{defmac}

\begin{new}
X3J13 voted in January 1989
\issue{HASH-TABLE-PACKAGE-GENERATORS}
to add a new macro \cdf{with-package-iterator} to the language.

\begin{defmac}
with-package-iterator (mname package-list {symbol-type}+)
                      {\,form}*

The name \emph{mname} is bound and defined as if by \cdf{macrolet},
with the body \emph{form\/}s as its lexical scope, to be a ``generator macro''
such that each invocation of \cd{(\emph{mname})} will
return a symbol and that successive invocations
will eventually deliver, one by one, all the symbols
from the packages that are elements of the list that is the value of the
expression \emph{package-list} (which is evaluated exactly once).

Each element of the \emph{package-list} value
may be either a package or the name of a package.
As a further convenience, if the \emph{package-list} value
is itself a package or the name of a package, it is treated
as if a singleton list containing that value had been provided.
If the \emph{package-list} value is \cdf{nil}, it is considered
to be an empty list of packages.

At each invocation of the generator macro, there are two possibilities.
If there is yet another unprocessed symbol, then
four values are returned: \cdf{t}, the symbol,
a keyword
indicating the accessibility of the symbol within the package (see below), and
the package from which the symbol was accessed.
If there are no more unprocessed symbols in the
list of packages, then one value is returned: \cdf{nil}.

When the generator macro returns a symbol as its second value, the
fourth value is always one of the packages present or named in the
\emph{package-list} value, and the third value is a keyword indicating
accessibility:
\cd{:internal} means present in the package and not exported;
\cd{:external} means present and exported;
and \cd{:inherited} means not present (thus not shadowed) but inherited
from some package used by the package that is the fourth value.

Each \emph{symbol-type} in an invocation of \cdf{with-package-iterator}
is not evaluated.  More than one may be present; their order does not
matter.  They indicate the accessibility types of interest.
A symbol is not returned by the generator macro unless its actual
accessibility matches one of the \emph{symbol-type} indicators.
The standard \emph{symbol-type} indicators are \cd{:internal},
\cd{:external}, and \cd{:inherited}, but implementations are permitted
to extend the syntax of \cdf{with-package-iterator} by recognizing
additional symbol accessibility types.  An error is signaled
if no \emph{symbol-type} is supplied, or if any supplied \emph{symbol-type}
is not recognized by the implementation.

The order in which symbols are produced by successive invocations
of the generator macro is not necessarily correlated in any way
with the order of the packages in the \emph{package-list}.
When more than one package is in the \emph{package-list},
symbols accessible from more than one package may be produced
once or more than once.  Even when only one package is specified,
symbols inherited in multiple ways via used packages may be
produced once or more than once.

The implicit interior state of the iteration over the list of packages
and the symbols within them has dynamic extent.
It is an error to invoke the generator macro
once the \cdf{with-package-iterator} form has been exited.

Any number of invocations of \cdf{with-package-iterator}
and related macros may be nested, and the generator macro of an
outer invocation may be called from within an inner invocation
(provided, of course, that its name is visible or otherwise made available).

X3J13 voted in January 1989
\issue{MAPPING-DESTRUCTIVE-INTERACTION}
to restrict user side effects; see section~\ref{STRUCTURE-TRAVERSAL-SECTION}.

\beforenoterule
\begin{rationale}
This facility is a bit more flexible in some ways than \cdf{do-symbols}
and friends.
In particular, it makes it possible to implement \cdf{loop}
clauses for iterating over packages in a way that is both portable
and efficient (see chapter~\ref{LOOP}).
\end{rationale}
\afternoterule
\end{defmac}
\end{new}

\section{An Example}
\label{PACKAGE-EXAMPLE-SECTION}

\begin{newer}
X3J13 voted in March 1989 \issue{LISP-PACKAGE-NAME} to specify that
the forthcoming ANSI Common Lisp will use the package name \cdf{common-lisp-user}
instead of \cdf{user}.
\end{newer}

\begin{table}[t]
\caption{An Initialization File}
\label{INIT-FILE-TABLE}
\begin{lisp}
;;;; Lisp init file for I. Newton. \\
 \\
;;; Set up the USER package the way I like it. \\
 \\
(require 'calculus)~~~~~~~~~~~~~;I use CALCULUS a lot; load it. \\
(use-package 'calculus)~~~~~~~~~;Get easy access to its \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; exported symbols. \\
 \\
(require 'newtonian-mechanics)~~;Same thing for NEWTONIAN-MECHANICS \\
(use-package 'newtonian-mechanics) \\
 \\
;;; I just want a few things from RELATIVITY, \\
;;; and other things conflict. \\
;;; Import only what I need into the USER package. \\
 \\
(require 'relativity) \\
(import '(relativity:speed-of-light \\
~~~~~~~~~~relativity:ignore-small-errors)) \\
 \\
;;; These are worth loading, but I will use qualified names, \\
;;; such as PHLOGISTON:MAKE-FIRE-BOTTLE, to get at any symbols \\
;;; I might need from these packages. \\
 \\
(require 'phlogiston) \\
(require 'alchemy) \\
 \\
;;; End of Lisp init file for I. Newton.
\end{lisp}
\end{table}

When each of two files uses some symbols from the other, the author
of those files must be
careful to arrange the contents of the file in the proper order.
Typically each file contains a single package that is a complete module.
The contents of such a file should include the following items, in
order:

\begin{enumerate}
\item
A call to \cdf{provide} that announces the module name.

\item
A call to \cdf{in-package} that establishes the package.

\item
A call to \cdf{shadow} that establishes any local symbols that will shadow
symbols that would otherwise be inherited from packages that this
package will use.

\item
A call to \cdf{export} that establishes all of this package's external
symbols.

\item
Any number of calls to \cdf{require} to load other modules that the
contents of this file might want to use or refer to.  (Because the
calls to \cdf{require} follow the calls to \cdf{in-package},
\cdf{shadow}, and \cdf{export}, it is possible for the packages that may
be loaded to refer to external symbols in this package.)

\item
Any number of calls to \cdf{use-package}, to make external
symbols from other packages accessible in this package.

\item
Any number of calls to \cdf{import}, to make
symbols from other packages present in this package.

\item
Finally, the definitions making up the contents of this package/module.
\end{enumerate}

The following mnemonic sentence may be helpful in remembering
the proper order of these calls:
\begin{center}
\textbf{Put in seven extremely random user interface commands.}
\end{center}
Each word of the sentence corresponds to one item in the above ordering:
\begin{tabbing}
\hskip 6pc\=\hskip 8pc\=\kill
\>Put\>\cdf{Provide} \\*
\>IN\>\cdf{IN-package} \\*
\>Seven\>\cdf{Shadow} \\*
\>EXtremely\>\cdf{EXport} \\*
\>Random\>\cdf{Require} \\*
\>USEr\>\cdf{USE-package} \\*
\>Interface\>\cdf{Import} \\*
\>COmmands\>COntents of package/module
\end{tabbing}


\begin{table}
\caption{File \protect\cdf{alchemy}}
\label{ALCHEMY-FILE-TABLE}
\begin{lisp}
;;;; Alchemy functions, written and maintained by Merlin, Inc. \\
 \\[4pt]
(provide 'alchemy)~~~~~~~~~~~~~~~~~~;The module is named ALCHEMY. \\
(in-package 'alchemy)~~~~~~~~~~~~~~~;So is the package. \\
 \\[4pt]
;;; There is nothing to shadow. \\
 \\[4pt]
;;; Here is the external interface. \\
 \\[4pt]
(export '(lead-to-gold gold-to-lead  \\
~~~~~~~~~~antimony-to-zinc elixir-of-life)) \\
 \\[4pt]
;;; This package/module needs a function from \\
;;; the PHLOGISTON package/module. \\
 \\[4pt]
(require 'phlogiston) \\
 \\[4pt]
;;; We don't frequently need most of the external symbols from \\
;;; PHLOGISTON, so it's not worth doing a USE-PACKAGE on it. \\
;;; We'll just use qualified names as needed.~~But we use \\
;;; one function, MAKE-FIRE-BOTTLE, a lot, so import it. \\
;;; It's external in PHLOGISTON and so can be referred to \\
;;; here using ":" qualified-name syntax. \\
 \\[4pt]
(import '(phlogiston:make-fire-bottle)) \\
 \\[4pt]
;;; Now for the real contents of this file. \\
 \\[4pt]
(defun lead-to-gold (x) \\
~~"Takes a quantity of lead and returns gold." \\
~~(when (> (phlogiston:heat-flow 5 x x)~~;Using a qualified symbol \\
~~~~~~~~~~~3) \\
~~~~(make-fire-bottle x))~~~~~~~~~~~~~~~~;Using an imported symbol \\
~~(gild x)) \\
 \\[4pt]
;;; And so on ...
\end{lisp}
\vfill
\end{table}

\begin{table}
\caption{File \protect\cdf{phlogiston}}
\label{PHLOGISTON-FILE-TABLE}
\begin{lisp}
;;;; Phlogiston functions, by Thermofluidics, Ltd. \\
 \\[4pt]
(provide 'phlogiston)~~~~~~~~~~~~~;The module is named PHLOGISTON. \\
(in-package 'phlogiston)~~~~~~~~~~;So is the package. \\
 \\[4pt]
;;; There is nothing to shadow. \\
 \\[4pt]
;;; Here is the external interface. \\
 \\[4pt]
(export '(heat-flow cold-flow mix-fluids separate-fluids \\
~~~~~~~~~~burn make-fire-bottle)) \\
 \\[4pt]
;;; This file uses functions from the ALCHEMY package/module. \\
 \\[4pt]
(require 'alchemy) \\
 \\[4pt]
;;; We use alchemy functions a lot, so use the package. \\
;;; This will allow symbols exported from the ALCHEMY package \\
;;; to be referred to here without the need for qualified names. \\
 \\[4pt]
(use-package 'alchemy) \\
 \\[4pt]
;;; No calls to IMPORT are needed here. \\
 \\[4pt]
;;; The real contents of this package/module. \\
\\[4pt]
(defvar *feeling-weak* nil) \\
 \\[4pt]
(defun heat-flow (amount x y) \\
~~"Make some amount of heat flow from x to y." \\
~~(when *feeling-weak* \\
~~~~(quaff (elixir-of-life)))~~~~~;No qualifier is needed. \\
~~(push-heat amount x y)) \\
 \\[4pt]
;;; And so on ...
\end{lisp}
\vfill
\end{table}

The sentence says what it helps you to do.

\begin{new}
The most distressing aspect of the X3J13 vote to eliminate
\cdf{provide} and \cdf{require}
\issue{REQUIRE-PATHNAME-DEFAULTS}
is of course that it completely ruins the mnemonic sentence.
\end{new}


Now, suppose for the sake of example
that the \cdf{phlogiston} and \cdf{alchemy} packages are
single-file, single-package modules as described above.  The \cdf{phlogiston}
package needs to use the \cdf{alchemy} package, and the \cdf{alchemy} package
needs to use several
external symbols from the \cdf{phlogiston} package.
The definitions in the \cdf{alchemy} and \cdf{phlogiston} files
(see tables~\ref{ALCHEMY-FILE-TABLE} and~\ref{PHLOGISTON-FILE-TABLE})
allow a
user to specify \cdf{require} statements for either of these modules, or for
both of them in either order, and all relevant information will be
loaded automatically and in the correct order.

\begin{obsolete}
For very large modules whose contents are spread over several files
(the \cdf{lisp} package is an example), it is recommended that the user
create the package and declare all of the shadows and external symbols
in a separate file, so that this can be loaded before anything that
might use symbols from this package.
\end{obsolete}

\begin{new}
Indeed, the \cdf{defpackage} macro
approved by X3J13 in January 1989
\issue{DEFPACKAGE}
encourages the use of such a separate file.
(By the way,
X3J13 voted in March 1989 \issue{LISP-PACKAGE-NAME} to specify that
the forthcoming ANSI Common Lisp will use the package name \cdf{common-lisp}
instead of \cdf{lisp}.)
Let's take a look at a revision
of I.~Newton's files using \cdf{defpackage}.
\end{new}

\begin{table}[t]
\caption{An Initialization File When \protect\cdf{defpackage} Is Used}
\label{DEFPACKAGE-INIT-FILE-TABLE}
\begin{lisp}
;;;; Lisp init file for I. Newton. \\
 \\
;;; Set up the USER package the way I like it. \\
 \\
(load "calculus")~~~~~~~~~~~~~~~;I use CALCULUS a lot; load it. \\
(use-package 'calculus)~~~~~~~~~;Get easy access to its \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; exported symbols. \\
 \\
(load "newtonian-mechanics")~~~~;Ditto for NEWTONIAN-MECHANICS \\
(use-package 'newtonian-mechanics) \\
 \\
;;; I just want a few things from RELATIVITY, \\
;;; and other things conflict. \\
;;; Import only what I need into the USER package. \\
 \\
(load "relativity") \\
(import '(relativity:speed-of-light \\
~~~~~~~~~~relativity:ignore-small-errors)) \\
 \\
;;; These are worth loading, but I will use qualified names, \\
;;; such as PHLOGISTON:MAKE-FIRE-BOTTLE, to get at any symbols \\
;;; I might need from these packages. \\
 \\
(load "phlogiston") \\
(load "alchemy") \\
 \\
;;; End of Lisp init file for I. Newton.
\end{lisp}
\end{table}
\begin{new}
The new version of the initialization file avoids using \cdf{require};
instead, we assume that \cdf{load} will do the job
(see table~\ref{DEFPACKAGE-INIT-FILE-TABLE}).

The other files have each been split into two parts, one that
establishes the package and one that defines the contents.
This example uses a simple convention that for any file
named, say, ``\cdf{foo}'' the file named ``\cdf{foo-package}''
contains the necessary \cdf{defpackage} and/or other package-establishing
code.  The idiom
\begin{lisp}
(unless (find-package "FOO") \\
~~(load "foo-package"))
\end{lisp}
is conventionally used to load a package definition but only if the package
has not already been defined.  (This is a bit clumsy, and there are other
ways to arrange things so that a package is defined no more than once.)

The file \cdf{alchemy-package} is shown in
table~\ref{DEFPACKAGE-ALCHEMY-PACKAGE-TABLE}.
The tricky point here is that the \cdf{alchemy} and \cdf{phlogiston}
packages contain mutual references (each imports from the other),
and so \cdf{defpackage} alone cannot do the job.  Therefore
the \cdf{phlogiston} package is not mentioned in a \cd{:use} option
in the \cdf{defpackage} for the \cdf{alchemy} package.  Instead,
the function \cdf{use-package} is called explicitly, after the package definition
for \cdf{phlogiston} has been loaded.  Note that this file has
been coded with excruciating care so as to operate correctly even if
the package current when the file is loaded does not inherit from
the \cdf{common-lisp} package. In particular, the standard load-package-definition
idiom has been peppered with package qualifiers:
\begin{lisp}
(cl:unless (cl:find-package "PHLOGISTON") \\
~~(cl:load "phlogiston-package"))
\end{lisp}
Note the use of the nickname \cdf{cl} for the \cdf{common-lisp} package.

The \cdf{alchemy} file, shown in table~\ref{DEFPACKAGE-ALCHEMY-FILE-TABLE},
simply loads the \cdf{alchemy} package definition,
makes that package current, and then defines the ``real contents''
of the package.
\end{new}
\begin{table}[t]
\caption{File \protect\cdf{alchemy-package} Using \protect\cdf{defpackage}}
\label{DEFPACKAGE-ALCHEMY-PACKAGE-TABLE}
\begin{lisp}
;;;; Alchemy package, written and maintained by Merlin, Inc. \\
 \\
(cl:defpackage "ALCHEMY" \\
~~(:export "LEAD-TO-GOLD" "GOLD-TO-LEAD" \\
~~~~~~~~~~~"ANTIMONY-TO-ZINC" "ELIXIR-OF-LIFE") \\
~~) \\
 \\
;;; This package needs a function from the PHLOGISTON package. \\
;;; Load the definition of the PHLOGISTON package if necessary. \\
 \\
(cl:unless (cl:find-package "PHLOGISTON") \\
~~(cl:load "phlogiston-package")) \\
 \\
;;; We don't frequently need most of the external symbols from \\
;;; PHLOGISTON, so it's not worth doing a USE-PACKAGE on it. \\
;;; We'll just use qualified names as needed.  But we use \\
;;; one function, MAKE-FIRE-BOTTLE, a lot, so import it. \\
;;; It's external in PHLOGISTON and so can be referred to \\
;;; here using ":" qualified-name syntax. \\
 \\
(cl:import '(phlogiston:make-fire-bottle))
\end{lisp}
\vskip\ruletonoteskip
\hrule
\vskip\ruletonoteskip\null
\caption{File \protect\cdf{alchemy} Using \protect\cdf{defpackage}}
\label{DEFPACKAGE-ALCHEMY-FILE-TABLE}
\begin{lisp}
;;;; Alchemy functions, written and maintained by Merlin, Inc. \\
 \\
(unless (find-package "ALCHEMY") \\
~~(load "alchemy-package")) \\
 \\
(in-package 'alchemy) \\
 \\
(defun lead-to-gold (x) \\
~~"Takes a quantity of lead and returns gold." \\
~~(when (> (phlogiston:heat-flow 5 x x)~~;Using a qualified symbol \\
~~~~~~~~~~~3) \\
~~~~(make-fire-bottle x))~~~~~~~~~~~~~~~~;Using an imported symbol \\
~~(gild x)) \\
 \\
;;; And so on ...
\end{lisp}
\end{table}



\begin{table}[t]
\caption{File \protect\cdf{phlogiston-package} Using \protect\cdf{defpackage}}
\label{DEFPACKAGE-PHLOGISTON-PACKAGE-TABLE}
\begin{lisp}
;;;; Phlogiston package definition, by Thermofluidics, Ltd. \\
 \\
;;; This package uses functions from the ALCHEMY package. \\
 \\
(cl:unless (cl:find-package "ALCHEMY") \\
~~(cl:load "alchemy-package")) \\
 \\
(cl:defpackage "PHLOGISTON" \\
~~(:use "COMMON-LISP" "ALCHEMY") \\
~~(:export "HEAT-FLOW" \\
~~~~~~~~~~~"COLD-FLOW" \\
~~~~~~~~~~~"MIX-FLUIDS" \\
~~~~~~~~~~~"SEPARATE-FLUIDS" \\
~~~~~~~~~~~"BURN" \\
~~~~~~~~~~~"MAKE-FIRE-BOTTLE") \\
~~)
\end{lisp}
\end{table}

\begin{table}[b]
\caption{File \protect\cdf{phlogiston} Using \protect\cdf{defpackage}}
\label{DEFPACKAGE-PHLOGISTON-FILE-TABLE}
\begin{lisp}
;;;; Phlogiston functions, by Thermofluidics, Ltd. \\
 \\
(unless (find-package "PHLOGISTON") \\
~~(load "phlogiston-package")) \\
 \\
(in-package 'phlogiston) \\
\\
(defvar *feeling-weak* nil) \\
\\
(defun heat-flow (amount x y) \\
~~"Make some amount of heat flow from x to y." \\
~~(when *feeling-weak* \\
~~~~(quaff (elixir-of-life)))~~~~~;No qualifier is needed. \\
~~(push-heat amount x y)) \\
 \\
;;; And so on ...
\end{lisp}
\end{table}
\begin{new}

The file \cdf{phlogiston-package} is shown in
table~\ref{DEFPACKAGE-PHLOGISTON-PACKAGE-TABLE}.
This one is a little more straightforward than the file \cdf{alchemy-package},
because the latter bears the responsibility for breaking the
circular package references.
This file simply makes sure that the \cdf{alchemy} package is defined
and then performs a \cdf{defpackage} for the \cdf{phlogiston} package.

The \cdf{phlogiston} file, shown in table~\ref{DEFPACKAGE-PHLOGISTON-FILE-TABLE},
simply loads the \cdf{phlogiston} package definition,
makes that package current, and then defines the ``real contents''
of the package.



Let's look at the question of package circularity in
this example a little more closely.
Suppose that the file \cdf{alchemy-package} is loaded first.
It defines the \cdf{alchemy} package and then loads
file \cdf{phlogiston-package}.  That file in turn finds that the
package \cdf{alchemy} has already been defined and therefore does
not attempt to load file \cdf{alchemy-package} again; it merely
defines package \cdf{phlogiston}.  The file \cdf{alchemy-package}
then has a chance to import \cd{phlogiston:make-fire-bottle} and everything
is fine.

On the other hand, suppose that the file \cdf{phlogiston-package} is
loaded first.  It finds that the
package \cdf{alchemy} has \emph{not} already been defined, and therefore
it immediately loads file \cdf{alchemy-package}.
That file in turn defines the \cdf{alchemy} package; then it
finds that package \cdf{phlogiston} is not yet defined and so
loads file \cdf{phlogiston-package} \emph{again} (indeed, in nested fashion).
This time file \cdf{phlogiston-package} \emph{does} find that the
package \cdf{alchemy} has already been defined, so it simply defines
package \cdf{phlogiston} and terminates.
The file \cdf{alchemy-package} then imports \cd{phlogiston:make-fire-bottle}
and terminates.
Finally, the outer loading of file \cdf{phlogiston-package}
\emph{re-defines} package \cdf{phlogiston}.  Oh, dear.  Fortunately the
two definitions of package \cdf{phlogiston} agree in every detail, so
everything ought to be all right.  Still, it looks a bit dicey; \emph{I}
certainly don't have the same warm, fuzzy feeling that I would if
no package were defined more than once.

\clearpage%manual

Conclusion: \cdf{defpackage} goes a long way, but it certainly doesn't
solve all the possible problems of package and file management.
Neither did \cdf{require} and \cdf{provide}.  Perhaps further experimentation
will yield facilities appropriate for future standardization.
\end{new}

%RUSSIAN
\else

\chapter{}
\label{XPACK}

   Lisp'      
.   Lisp' ,  
,   ,    
 . Common Lisp      \emph{
 },    ,   Lisp
Machine \cite{BLUE-LISPM}.
        Lisp  
.

\emph{} ---   ,    
  ()  .      
 ,     Lisp' 
     .    
  \cdf{*package*}.   
\emph{ }      
    .
,  \cd{foo:bar}   Common Lisp',    
 \cd{bar}   \cd{foo}.
(  ,  \cd{bar}    
\cd{foo},   ,      \cd{foo}.  
    : \cd{foo::bar}.)

   ,    ,    :
\emph{}  \emph{}.       
 ,   \emph{}  \emph{}  , 
    ,   .
        .  
  ,         , 
.

        
.        
    .  
    ,     
  .     .  
 ,      \cdf{export}.

     .        
,       ,    .  
,      ()      
 .

, ,       ,   
  ,  \emph{ } . ,
    .
   ,  \emph{ },  
   .
,    ,  \emph{}.
     .  
\emph{}.      {\false}.

     .    ,  
         
.       
 .       
  \cdf{use-package}. (   
.)  ,     \emph{}  , 
       ,   
          . 
    \emph{}  ,   
 ,   .  , \emph{}   
 \emph{},  \emph{}    
\emph{}.

  \emph{  },     
     .   
       ,  
      (\emph{})
.

<<\emph{}   !>>   , 
   ,      .
    \cdf{intern}.
     (  ),   
  ( ).      -, 
   .

<<\emph{}   >>     . 
   \cdf{unintern}. FIXME

\section{ }

         . 
 Common Lisp'      
   ,     
 .  ,    ,
     ,    .

    ,      .
    ,      \cdf{*package*}.

\begin{itemize}
\item
\emph{ -:}        
     (\cdf{eq}  ).

\item
\emph{ -:}    
   ,     
  (\cdf{eq}  ).

\item 
\emph{ -:}      
\cdf{eq},       
 .
\end{itemize}

     ,     
   Lisp' ,     . 
   ,      
     .    
  :   \cdf{*package*}, 
  ,     <<>> 
\cdf{unintern}, \cdf{unexport}, \cdf{shadow}, \cdf{shadowing-import} 
\cdf{unuse-package}.

\section{ }
\label{PACKAGE-NAMES-SECTION}

    () , ,  . 
   ,    
.       , 
\cdf{editor}.        , 
\cdf{ed}.

       . 
\cdf{find-package}       
.  \cdf{package-name}   . 
\cdf{package-nicknames}      . 
\cdf{rename-package}       
 .     .  
 , ,  ,     
   Lisp .    ,  , 
   ,    .

 Lisp     ,   
 ,      ,   
    .   
    \cd{{\Xbackslash}}  \cd{|}. ,
  \cdf{find-package},  , 
   .  ,  \cd{|Foo|:|Bar|}   ,
  \cd{Bar},   \cd{Foo}.   \cd{|Foo:Bar|} 
  ,     (    
  )     .     
        
,    Lisp       .

 ,    ,    ,
 .   ,     , 
     .   ,  
        . 

\section{   }
\label{STRING-TO-SYMBOL-SECTION}

   \cdf{*package*}    
 ( ).    \emph{ }.

 Lisp'     ,     
 .
        ,  
   .   ,  
 .     ( ,    
   ),     
   .  ,     
( ) .
            ,  
   .

        ,  
.       \emph{ },  
,  , , ,  .     
 ,    . , \cd{editor:buffer}  
    \cdf{buffer}      \cdf{editor},
   ,          .
    \cdf{editor}     \cdf{buffer}  
  , Lisp'    .

         \emph{}
    .      ,
         . , 
      \cd{::},  
.   \cd{editor::buffer},    ,  
       \cdf{buffer}  \cdf{*package*} 
     \cd{editor}.    
 .

   \cdf{keyword}     
Lisp'    .     
   ,      ,   
         .  
   ,  Common Lisp   
 .          
( \cd{:foo})  ( )   \cdf{keyword} 
\emph{} .  \cdf{keyword}   ,  
   ,    . 
     ( \cdf{defconstant}) 
    .
  ,         
  .       
    .   \cdf{use-package} 
\cdf{keyword}   .

    ,     
 ,  {\false},   .   
   \cdf{symbol-package}.
   ,      
,       , ,   
(  )   ,     ,
   ,   ,    \cd{:} 
    ,  \cd{::}  .

,    ()   {\false} ( , 
 )   \cd{\#:}   .  
\cdf{import}  \cdf{unintern}   ,   
 ,      .
Lisp      ,    
    \cd{\#:}.

 ,          .

\begin{flushdesc}
\item[\cd{foo:bar}]
 ,    \cd{BAR}    
\cd{FOO}.  ,   \cd{bar}     
\cd{foo}     .

\item[\cd{foo::bar}]
 ,   \cd{BAR},     \cd{FOO} 
.  ,   \cd{bar}     
 \cd{foo}     .

\item[\cd{:bar}]
 ,  \cd{BAR}      \cd{keyword} 
    .  ,  \cd{keyword}  
  .

\item[\cd{\#:bar}]
 ,       \cd{BAR}.
 ,   \cd{bar}    .
\end{flushdesc}

         Common
Lisp',    .      
,          
.

\section{   } 
\label{EXPORT-IMPORT-SECTION}

           .

 ,         
  \cdf{import}.  \cd{(import 'editor:buffer)}
  
   \cd{buffer}   \cd{editor} (   Lisp
)         
.   \emph{}   . 
      ,    
  
   ,     .   \cdf{import}
       \cdf{buffer} 
  .  \cdf{buffer}   \cdf{editor}  ,
\cdf{editor}       . 
,          
   \cdf{unintern}.

      , \cdf{import}  
.        \cdf{buffer}   
  (  ),  
 ,   
~\ref{NAME-CONFLICTS-SECTION}. \cdf{import}   
  .

       ,  
     ,     
.
     ,  
\cdf{shadowing-import}.      ,  
,    ,        
.
         ,   
    \cdf{unintern}.     
  FIXME. \cdf{shadowing-import}  
.      ,   
  .

    \cdf{use-package}.   
,         . 
  ,  \emph{} , 
.  ,         
,        , 
.  ,  \cdf{use-package},    \cdf{import}, 
   \emph{}   ,    
\emph{}       .
\cdf{use-package}        
   .    
~\ref{NAME-CONFLICTS-SECTION}.

 , -    \cdf{common-lisp-user}, 
 
   Lisp      , 
  \cdf{use-package}       
    .
\cdf{unuse-package}    
\cdf{use-package}.     
. ,   ,  .

    \emph{}   . 
   ,      
   ,     (  ), 
     .

         
,          
.

 \cdf{intern}         
,          
,         
 .    .    
   ( ),    
    ,   \emph{X},    
    \emph{X},   . ,  
 ,       , 
    .

 \cdf{export}  ,     
 (     )     
 .      , \cdf{export}  
.   ,   \emph{} , 
    .   ,   ,
   \cdf{use-package},     , 
  . (      
   ,       
\cdf{unuse-package}  ).       ,
      , , , 
   .

 \cdf{unexport}    . 
     
   ,     <<>>.
 \cdf{unexport}  ,      
,    .     , 
 .

\section{ }
\label{NAME-CONFLICTS-SECTION}

       ,   
      ,    .
\emph{ }  ,    
          .   
    ,   - 
. ,        
    .     
,       ,  
          ,  
  .        
,           ,
  ,     . 
,       
.     ,   , 
 .

  ,          
 . ,        
 ,         
    .
      .
          .
         .

     ,    ,
 \emph{}.     
.          
 .    
         
 (    \cdf{import} 
).  \cdf{shadow}  \cdf{shadowing-import}   
  .

  ,    ,  , 
  .       
   .

 \cdf{use-package}, \cdf{import}  \cdf{export}  
 . \cdf{use-package}      
   .       
      .
\cdf{import}       ,  
   \emph{}  \emph{
 }. \cdf{import}     ,  
    .   ,  
     .
\cdf{export}       ,  
,     .     
 : \cd{(export \emph{s} \emph{p})}  \cd{(find-symbol
  (symbol-name \emph{s} \emph{q})}    \emph{q} 
\cd{(package-used-by-list \emph{p})}.  ,    
 \cdf{export}     , 
\cdf{package-used-by-list}  {\false}      
  .

 \cdf{intern},       Lisp' 
   ,      ,   
    ,      
\emph{}. 

\cdf{shadow}  \cdf{shadowing-import}     
,   ,  , ,   
 . \cdf{shadow}     ,  
      ,  ,  
\emph{}  .   ,  
,   . \cdf{shadowing-import}   
  ,         ,
 ,    ,  ,    
,       .

\cdf{unuse-package}, \cdf{unexport}  \cdf{unintern} ( , 
,    )   
 ,        .   
-   .

     \cdf{unintern}   
,       .   A 
 B  C, A    \cdf{x},  B,  C,  
    \cdf{x},      \cdf{x}
 A     \cd{b:x}  \cd{c:x},    
.
   \cdf{unintern}   .

       .
         
   .       ,
,  \cdf{export}   ,  
    ,    ,
   ,     ,  
 . ,       
\cdf{export}          
    .      
\cdf{export}     .

        
     -  .  
       ,  
\cdf{shadowing-import}, \cdf{unintern}  \cdf{unexport}.

   \cdf{use-package}  \emph{}  
         
         ,  
        
 .   ,    
    ,     
.

   \cdf{use-package}    ,
      ,       
,           
 .

   \cdf{export}       
  ,     
,         
  ,      ,
   .

   \cdf{export}  \cdf{unintern} - ,  
        ,  
           
     ,     
\cdf{use-package}.

   \cdf{import}      
         
          
     \cdf{import}.    \cdf{import} 
         
  ,   \cdf{import}.

     ,  \cdf{use-package} 
\cdf{export},        , 
     ,     
.
          
.   ,     
 .

       .
,   ,    ,   
 ,    <<>>     
  .         
.   <<>>     
   ,    .  Lisp Machine Lisp',
,    \emph{ (forward)} ,   
 ,         
.         ,
     .       
    ,     
,    -\cdf{eq}     
    .   
,    ,  ,    
   Lisp' ,   
,       .

\section{ }

\begin{flushdesc}
\item[\cdf{common-lisp}]
   \cdf{common-lisp}     ANSI Common
Lisp.          
,    ANSI Common Lisp ,  
\cdf{car}, \cdf{cdr}  \cdf{*package*}.
  ,       
   \cdf{common-lisp} ( ,  \cdf{t} 
\cdf{lambda}       \cdf{common-lisp},   
,    \cdf{lisp} FIXME).
      \cdf{common-lisp},   
       ( ).
    \cdf{cl}.

\item[\cdf{common-lisp-user}]
 \cdf{common-lisp-user} , -,    
 ANSI Common Lisp .
    \cdf{common-lisp}    \cdf{cl-user}.
          
  .
\end{flushdesc}

\begin{flushdesc}
\item[\cdf{keyword}]
     ,   
 Lisp' .  ,   ,
,       ,   
.       ,  
  ,     \cd{:foo}  \cd{':foo}.
\end{flushdesc}

\begin{newer}
X3J13    1989 \issue{LISP-SYMBOL-REDEFINITION}
     , 
        .
     \cdf{common-lisp}     ,
     ,   .
\begin{itemize}
\item      (  )
\item      
\item      
\item      (\cdf{defstruct}, \cdf{defclass}, \cdf{deftype})
\item     (\cdf{defstruct})
\item    
\item    
\item    
\item   
\item  
\item        
\item      (\cdf{type}, \cdf{ftype})
\item     \cdf{common-lisp}
\item    
\end{itemize}

         ,
        
\cdf{type}  .

      ,    ,
       ,
  \cdf{ftype}      . 

      ,    ,
       .

  ,    
\begin{lisp}
(flet ((open (filename \&key direction) \\*
~~~~~~~~~(format t "{\Xtilde}\%OPEN was called.")  \\*
~~~~~~~~~(open filename :direction direction))) \\*
~~(with-open-file (x "frob" :direction ':output)  \\*
~~~~(format t "{\Xtilde}\%Was OPEN called?")))
\end{lisp}
 .   <<>> , ,  
\cdf{with-open-file}     \cdf{open}.   ,
      <<>>.
    .   ,  ,
  ,  .

 ,  <<  >>     
,        
    \cdf{common-lisp} .
\end{newer}

\section{     }
\label{PACKAGE-FUNCTIONS-SECTION}

   ,     
\emph{package}   - \cdf{*package*}. ,  
 ,       , 
{\false} ,    .  , 
  ,     .
  ,     .  , 
        
,   .

\begin{defun}[]
*package*

      .   
.   \cdf{*package*}   \cdf{common-lisp-user}.

 \cdf{load}  \cdf{compile-file}  \cdf{*package*}   . 
         \cdf{*package*},
      .

 \cdf{compile-file}  \cdf{*package*}  
.           
 \cdf{*package*},       .


\begin{defun}[]
make-package package-name &key :nicknames :use

         .  
 ,     ,  . 
\cd{:nicknames}    ,   .  
     ,    
  .        
   .   ,  
  .

 \cd{:use}      (  )
,       .   
   . 
\end{defun}

\begin{defmac}
in-package name

    \cdf{*package*}  ,  
   \emph{name}.  \emph{name}    
.  \emph{name}  .
   ,  .
 ,        ,  
    .

\cdf{in-package}   ,    \cdf{*package*} 
 .
\end{defmac}

\begin{defun}[]
find-package name

 \emph{name}   ,    
  .      ,  
   .      
   .     , 
\cdf{find-package}  {\false}.
   (  \cdf{string=}).

 \emph{package}    ,    
  .  ~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[]
package-name package

    .     
 .

       ,    
   .  ~\ref{PACKAGE-NAMES-SECTION}.

\cdf{package-name}  \cdf{nil}   ,   
.  \cdf{delete-package}.
\end{defun}

\begin{defun}[]
package-nicknames package

    .     
  ,    .

       ,    
   .  ~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[]
rename-package package new-name &optional new-nicknames

       \emph{package}   
 \emph{new-name}  \emph{new-nicknames}.  \emph{new-name}  
  .  \emph{new-nicknames},  -
{\false},     .

 \emph{package}     ,   
.  ~\ref{PACKAGE-NAMES-SECTION}.

\cdf{rename-package}  \emph{package}.
\end{defun}

\begin{defun}[]
package-use-list package

    ,    
.

 \emph{package}     ,   
.  ~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[]
package-used-by-list package

    ,    
.

 \emph{package}     ,   
.  ~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[]
package-shadowing-symbols package

    ,   , 
 ,   \cdf{shadow}  \cdf{shadowing-import}. 
     \emph{}  .

 \emph{package}     ,   
.  ~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[]
list-all-packages 

     ,    Lisp'
. 
\end{defun}

\begin{defun}[]
delete-package package

 \cdf{delete-package}     \emph{package} ,
     .
 \emph{package}    ,    .

 \emph{package}  ,       ,
  .       
,   \cdf{nil}   \cdf{delete-package}.

 \emph{package}  ,     ,
       .  
\cdf{delete-package}   \cdf{nil}.

 ,   ,      ,
  .      , 
  \cdf{unuse-package}       
 ,     \cdf{delete-package}  
.

       ,  
 \cdf{delete-package},     
.  -      .

    \emph{package}    .  
,  : \cdf{packagep}  ,  \cdf{package-name}
     \cdf{nil}.

         . 
,       (,  \cdf{intern}
 \cdf{find-symbol})    .

   , \cdf{delete-package}  \cdf{t},  \cdf{nil}.
\end{defun}

\begin{defun}[]
intern string &optional package

  \emph{package},  -   ,
    ,    \emph{string}. 
    ,   
~\ref{EXPORT-IMPORT-SECTION}.
     ,      
      (  ,  
\cdf{keyword}).        .
  .   ,    
.   {\false},     ,   
 :
\begin{indentdesc}{6pc}
\item[\cd{:internal}]
       .

\item[\cd{:external}]
       .

\item[\cd{:inherited}]
    \cdf{use-package} (   
).
\end{indentdesc}

 \emph{package}     ,   
.  ~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[]
find-symbol string &optional package

   \cdf{intern},       . 
        ,   
,        
     \cdf{intern}.       ,
   {\false}.

 \emph{package}     ,   
.  ~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[]
unintern symbol &optional package

       \emph{package}, 
         ,   
.  ,  \emph{package}     , 
    .
 ,       
      .
   , \cdf{unintern}  {\true}, 
{\false}.

\cdf{unintern}    .   
  ,     .

 \emph{package}     ,   
.  ~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[]
export symbols &optional package

 \emph{symbols}      
.         
\emph{package} ( ~\ref{EXPORT-IMPORT-SECTION}).
\cdf{export}  {\true}.

 ,  \cdf{export}     
    ,   ,  
      . 

 \emph{package}     ,   
.  ~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[]
unexport symbols &optional package

 \emph{symbols}       . 
      \emph{package}. 
      \cdf{keyword}  .
( ~\ref{EXPORT-IMPORT-SECTION}).
\cdf{unexport}  {\true}.

 \emph{package}     ,   
.  ~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[]
import symbols &optional package

 \emph{symbols}       .
       \emph{package} , 
,        ( ).
\cdf{import}   ,    
    ,        
( ~\ref{EXPORT-IMPORT-SECTION}).
\cdf{import}  {\true}.

       ,  \cdf{import}
   ,    . 

 \emph{package}     ,   
.  ~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[]
shadowing-import symbols &optional package

    \cdf{import},    ,  
      , 
  .       
    \emph{package} (
~\ref{NAME-CONFLICTS-SECTION}).
\cdf{shadowing-import}  {\true}.

\cdf{shadowing-import}    .  
   ,     .

 \emph{package}     ,   
.  ~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[]
shadow symbols &optional package

           .
     (  )   
 \emph{package}      .   
    (,    ),  
    . ,    
  ,     \emph{package}  
.        
\emph{package} ( ~\ref{NAME-CONFLICTS-SECTION}).
\cdf{shadow}  {\true}.

\cdf{shadowing}    .  
   ,     .

 \emph{package}     ,   
.  ~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[]
use-package packages-to-use &optional package

 \emph{packages-to-use}        
    .      
\emph{package},     .      
   \emph{package}    (
~\ref{EXPORT-IMPORT-SECTION}).
  \cdf{keyword}  .
\cdf{use-package}  {\true}.

 \emph{package}     ,   
.  ~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defun}[]
unuse-package packages-to-unuse &optional package

 \emph{packages-to-use}        
    .      
\emph{package},    .
\cdf{unuse-package}  {\true}.

 \emph{package}     ,   
.  ~\ref{PACKAGE-NAMES-SECTION}.
\end{defun}

\begin{defmac}
defpackage defined-package-name {option}*

    ,    ,  
 \emph{defined-package-name}.  \emph{define-package-name} 
   .
   ,     ,   , 
     .
       
\cdf{defpackage}.

\begin{flushdesc}

\item[\cd{(:size \emph{integer})}]
        . 
      ,   
-        , 
     (,     
    ).

\item[\cd{(:nicknames \Mstar\emph{package-name})}]
    .
        ,  
 ,    \cdf{make-package}.

\item[\cd{(:shadow \Mstar\emph{symbol-name})}]
  ,     
.   \cdf{shadow}.

\item[\cd{(:shadowing-import-from \emph{package-name} \Mstar\emph{symbol-name})}]
  ,      .
    ,    ,  
  \cdf{shadowing-import}.
      .
    \emph{symbol-name}     
   \emph{package-name},    .

\item[\cd{(:use \Mstar\emph{package-name})}]
   <<>> ( ) 
   .  ,   \cdf{use-package}.
 \cdf{:use}  ,     .

\item[\cd{(:import-from \emph{package-name} \Mstar\emph{symbol-name})}]
 ,      .
    ,     \cdf{shadowing-import}.
      .
    \emph{symbol-name}     
   \emph{package-name},    .

\item[\cd{(:intern \Mstar\emph{symbol-name})}]
       , 
   \cdf{intern}.  ,   
     \cd{:use},    
 ,   .

\item[\cd{(:export \Mstar\emph{symbol-name})}]
         
,     \cdf{export}.  ,
        \cd{:use}, \cd{import-from} 
\cd{shadowing-import-from}      
   ,   .
\end{flushdesc}

,       \cdf{defpackage},  
.    ,  \cdf{defpackage}   
.
    :
\begin{tabbing}
1.~~\cd{:shadow} and \cd{:shadowing-import-from} \\
2.~~\cd{:use} \\
3.~~\cd{:import-from} and \cd{:intern} \\
4.~~\cd{:export}
\end{tabbing}
  ,     
   use.  use    
 ,        
 ,    .  
,       ,  ,
   ,   . 
,       
 ( ~\ref{EXPORT-IMPORT-SECTION}).

    \emph{defined-package-name}  , 
\cdf{defpackage}  .     ,   
  .   ,  ,  
 .   ,     
   .

   \cdf{symbol-name} (     
\cdf{string=})       \cd{:shadow},
\cd{:shadowing-import-from}, \cd{:import-from}  \cd{:intern}, 
.

   \cdf{symbol-name} (     
\cdf{string=})       \cd{:intern} 
\cd{:export},  .

       ,   
 \cdf{use-package}, \cdf{import}  \cdf{export}.

      \cdf{defpackage}.
        
  \cdf{defpackage}.

 \cdf{compile-file}     
\cdf{defpackage}   ,       
   (    ~\ref{PACKAGE-FUNCTIONS-SECTION}).

   \cdf{defpackage},  <<  (plays it safe)>>,  
   .
\begin{lisp}
(cl:defpackage "MY-VERY-OWN-PACKAGE" \\*
~~(:size 496) \\*
~~(:nicknames "MY-PKG" "MYPKG" "MVOP") \\*
~~(:use "COMMON-LISP") \\
~~(:shadow "CAR" "CDR") \\*
~~(:shadowing-import-from "BRAND-X-LISP" "CONS") \\*
~~(:import-from "BRAND-X-LISP" "GC" "BLINK-FRONT-PANEL-LIGHTS") \\*
~~(:export "EQ" "CONS" "MY-VERY-OWN-FUNCTION"))
\end{lisp}
\cdf{defpackage}     ,   
    \cdf{common-lisp}. ( , 
     \cdf{cl}   \cdf{common-lisp}.)
 ,    \cdf{defpackage}     
.           
.

     \cdf{defpackage},  <<   (plays
the whale)>>      .
\begin{lisp}
(defpackage my-very-own-package \\*
~~(:export :EQ common-lisp:cons my-very-own-function) \\*
~~(:nicknames "MY-PKG" \#:MyPkg) \\*
~~(:use "COMMON-LISP") \\
~~(:shadow "CAR") \\*
~~(:size 496) \\*
~~(:nicknames mvop) \\
~~(:import-from "BRAND-X-LISP" "GC" Blink-Front-Panel-Lights) \\
~~(:shadow common-lisp::cdr) \\*
~~(:shadowing-import-from "BRAND-X-LISP" CONS))
\end{lisp}
         ,   
     .
     .
,   \cdf{defpackage}  ,   \cdf{cdr} 
  \emph{ }.       
\cdf{common-lisp}. ,   <<\cdf{CDR}>>     (
)   .
  ,    \cdf{defpackage},    
Common Lisp',         , 
       .

 ,  \cdf{defpackage}      
  , ,     . ,
    \cdf{defpackage}   
,     ,  \cdf{use-package},
\cdf{import}  \cdf{export}   .

 \cdf{defpackage}       
   .      
      ()   ,
        , 
   .  ,   ,  
    \cdf{common-lisp-user}.

        
 (     )   
     .
\end{defmac}

\begin{defun}[]
find-all-symbols string-or-symbol

\cdf{find-all-symbols}     Lisp'   
,      .   
    .
  .
   ,       
.
\end{defun}

\begin{defmac}
do-symbols (var [package [result-form]])
           {declaration}* {tag | statement}*

\cdf{do-symbols}      .  
       \emph{package}. 
   \emph{var}.
   \emph{result-form} ( , \emph{} 
\cdf{progn}),      \cdf{do-symbols}. (
  \emph{result-form},  \emph{var}  
    {\false}.)  \emph{result-form} , 
{\false}.      
\cdf{return}.      ,    
 \emph{package},       
 \emph{var}   \cdf{unintern},  
 .

 \emph{package}     ,   
.  ~\ref{PACKAGE-NAMES-SECTION}.
\end{defmac}

\begin{defmac}
do-external-symbols (var [package [result]])
                    {declaration}* {tag | statement}*

\cdf{do-external-symbols}   \cdf{do-symbols}   , 
    .

 \emph{package}     ,   
.  ~\ref{PACKAGE-NAMES-SECTION}.
\end{defmac}

\begin{defmac}
do-all-symbols (var [result-form])
               {declaration}* {tag | statement}*

    \cdf{do-symbols},      
  . (     ,  
       . ,  
     .)
          ,  
      .

 \emph{package}     ,   
.  ~\ref{PACKAGE-NAMES-SECTION}.
\end{defmac}

\fi
%Part{Intro, Root = "CLM.MSS"}
% Chapter of Common Lisp Manual.  Copyright 1984, 1988, 1989 Guy L. Steele Jr.

\clearpage\def\pagestatus{FINAL PROOF}

\ifx \rulang\Undef

\chapter{Introduction}

Common Lisp is a new dialect of Lisp, a
successor to MacLisp \cite{MOONUAL,PITMANUAL}, influenced strongly by
Zetalisp \cite{BLUE-LISPM,GREEN-LISPM} and to some extent by Scheme
\cite{SCHEME-REVISED-REPORT} and Interlisp \cite{INTERLISP}.

\section{Purpose}

Common Lisp is intended to meet these goals:

\begin{flushdesc}
\item[\emph{Commonality}]
Common Lisp originated in an attempt to focus the
work of several implementation groups, each of which was constructing successor
implementations of MacLisp for different computers.  These
implementations had begun to diverge because of the differences in the
implementation environments: microcoded personal computers (Zetalisp,
Spice Lisp), commercial timeshared computers (NIL---the ``New Implementation of
Lisp''), and supercomputers (S-1 Lisp).  While the differences among the several
implementation environments of necessity will continue to force
certain incompatibilities among the
implementations, Common Lisp serves as a common dialect to
which each implementation makes any necessary extensions.

\item[\emph{Portability}]
\begingroup\looseness=1
Common Lisp intentionally excludes features
that cannot be implemented easily on a broad class of machines.
On the one hand, features that are difficult or expensive
to implement on hardware without special microcode are avoided
or provided in a more abstract and efficiently implementable form.
(Examples of this are the invisible forwarding pointers
and locatives of Zetalisp.  Some of the problems that they solve
are addressed in different ways in Common Lisp.)
On the other hand, features that are useful only on certain ``ordinary''
or ``commercial'' processors are avoided or made optional.  (An example of
this is the type declaration facility, which is useful in some
implementations and completely ignored in others.  Type declarations are
completely optional and for correct programs
affect only efficiency, not semantics.)
Common Lisp is designed to make it easy to write programs
that depend as little as possible on machine-specific
characteristics, such as word length, while allowing some variety of
implementation \hbox{techniques}.
\par\endgroup

\item[\emph{Consistency}]
Most Lisp implementations are internally inconsistent
in that by default the interpreter and compiler may assign different
semantics to correct programs.
This semantic difference stems primarily from the fact
that the interpreter assumes all variables to be dynamically scoped,
whereas the compiler assumes all variables to be local unless explicitly
directed otherwise.  This difference has been the usual practice in Lisp
for the sake of convenience
and efficiency but can lead to very subtle bugs.  The definition of
Common Lisp avoids such anomalies by explicitly requiring the interpreter
and compiler to impose identical semantics on correct programs
so far as possible.

\item[\emph{Expressiveness}]
Common Lisp culls what
experience has shown to be the most useful and understandable constructs
from not only MacLisp but also
Interlisp, other Lisp dialects, and other programming languages.
Constructs judged to be awkward or less useful have been
excluded.   (An example is the \cdf{store} construct of MacLisp.)

\item[\emph{Compatibility}]
Unless there is a good reason to the contrary,
Common Lisp strives to be compatible with Lisp Machine Lisp, MacLisp, and
Interlisp, roughly in that order.

\item[\emph{Efficiency}]
Common Lisp has a number of features designed to
facilitate the production of high-quality compiled code in those
implementations whose developers
care to invest effort in an optimizing compiler.
One implementation of Common Lisp, namely S-1 Lisp, already has a compiler
that produces code for numerical computations that is competitive
in execution speed to that produced by a Fortran compiler \cite{S1-COMPILER}.
The S-1 Lisp compiler
extends the work done in MacLisp to produce extremely efficient
numerical code \cite{MACLISP-BEATS-FORTRAN}.

\item[\emph{Power}]
Common Lisp is a descendant of MacLisp, which has
traditionally placed emphasis on providing system-building tools.
Such tools may in turn be used to build the user-level packages
such as Interlisp provides; these packages are not, however, part
of the Common Lisp core specification.  It is expected such packages will
be built on top of the Common Lisp core.

\item[\emph{Stability}]
It is intended that Common Lisp
will change only slowly and with due deliberation.  The various dialects
that are supersets of Common Lisp may serve as laboratories within which to
test language extensions, but such extensions will be added to
Common Lisp only after careful examination and experimentation.
\end{flushdesc}

The goals of Common Lisp are thus very close to those of Standard Lisp
\cite{STANDARD-LISP-REPORT} and Portable Standard Lisp \cite{PSL-MANUAL}.
Common Lisp differs from Standard Lisp
primarily in incorporating more features, including a
richer and more complicated set of data types and more complex
control structures.

This book is intended to be a language specification
rather than an implementation specification
(although implementation notes are scattered throughout the text).
It defines a set of
standard language concepts and constructs that may be used
for communication of data structures and algorithms in the Common Lisp
dialect.  This set of concepts
and constructs is sometimes referred to as the ``core Common Lisp language''
because it contains conceptually necessary or important features.
It is not necessarily implementationally minimal.
While many features could be defined in terms of others
by writing Lisp code, and indeed may be implemented that way,
it was felt that these features should be conceptually primitive
so that there might be agreement among all users as to their usage.
(For example, bignums and rational numbers could be implemented as
Lisp code given operations on fixnums.  However, it is important
to the conceptual integrity of the language that they be regarded
by the user as primitive, and they are useful enough to warrant
a standard definition.)

For the most part, this book defines a programming language, not a
programming environment.  A few interfaces are defined for
invoking such standard programming tools as a compiler, an editor,
a program trace facility, and a debugger, but very little is said
about their nature or operation.  It is expected that one or more
extensive programming environments will be built using Common Lisp as a
foundation, and will be documented separately.

There are now many implementations of Common Lisp,
some programmed by research groups in universities
and some by companies that sell them commercially,
and a number of useful
programming environments have indeed grown up around
these implementations.
What is more, all the goals stated above have been achieved,
most notably that of portability.  Moving large bodies
of Lisp code from one computer to another is now routine.

\section{Notational Conventions}

A number of special notational conventions are used throughout this book
for the sake of conciseness.

\subsection{Decimal Numbers}

All numbers in this book are in decimal notation unless
there is an explicit indication to the contrary.
(Decimal notation is normally taken for granted, of course.
Unfortunately, for certain other dialects of Lisp, MacLisp in particular,
the default notation for numbers is octal (base 8) rather than decimal,
and so the use of decimal notation for describing Common Lisp is,
taken in its historical context, a bit unusual!)

\subsection{Nil, False, and the Empty List}

In Common Lisp, as in most Lisp dialects, the symbol \cdf{nil}
 is used to represent both the empty list and the ``false'' value
for Boolean tests.  An empty list may, of course, also be written
\cd{()}; this normally denotes the same object as \cdf{nil}.
(It is possible, by extremely perverse manipulation of the package system,
to cause the sequence of letters \cdf{nil} to be recognized
not as the symbol that represents the empty list but as another
symbol with the same name.  This obscure possibility will be ignored
in this book.)
These two notations may be used interchangeably as far as the Lisp
system is concerned.  However, as a matter of style,
this book
uses the notation {\emptylist} when it is desirable to emphasize
the use of an empty list, and uses the notation {\false}
when it is desirable to emphasize the use of the Boolean ``false''.
The notation \cd{'nil} (note the explicit quotation mark) is used to emphasize
the use of a symbol.
For example:
\begin{lisp}
~~~~~~~~~~~~~~~~~~~~~~~~~~~\=\kill
(defun three () 3)\>;\textrm{Emphasize empty parameter list} \\
(append '{\emptylist} '{\emptylist}) \EV\ {\emptylist}\>;\textrm{Emphasize use of empty lists} \\
(not {\false}) \EV\ {\true}\>;\textrm{Emphasize use as Boolean ``false''} \\
(get '{\nil} 'color)\>;\textrm{Emphasize use as a symbol}
\end{lisp}

Any data object other than {\false} is construed to be Boolean
``not false'', that is, ``true''.  The symbol {\true} is conventionally
used to mean ``true'' when no other value is more appropriate.
When a function is said to ``return \emph{false}'' or to ``be \emph{false}''
in some circumstance, this means that it returns {\false}.
However, when a function is said to ``return \emph{true}'' or to ``be \emph{true}''
in some circumstance, this means that it returns some value other
than {\false}, but not necessarily {\true}.

\subsection{Evaluation, Expansion, and Equivalence}

Execution of code in Lisp is called \emph{evaluation} because executing a
piece of code normally results in a data object called the \emph{value}
produced by the code.  The symbol \EV\ is used in examples to
indicate evaluation.
For example,
\begin{lisp}
(+ 4 5) \EV\ 9
\end{lisp}
means ``the result of evaluating the code \cd{(+ 4 5)} is (or would be,
or would have been) \cd{9}.'' 

The symbol \EX\ is used in examples to indicate macro expansion.
For example,
\begin{lisp}
(push x v) \EX\ (setf v (cons x v))
\end{lisp}
means ``the result of expanding the macro-call form \cd{(push x v)}
is \cd{(setf v (cons x v))}.''  This implies that the two pieces
of code do the same thing; the second piece of code is
the definition of what the first does.

The symbol \EQ\ is used in examples to indicate code equivalence.
For example,
\begin{lisp}
(gcd x (gcd y z)) \EQ\ (gcd (gcd x y) z)
\end{lisp}
means ``the value and effects of evaluating the form
\cd{(gcd x (gcd y z))} are always the same as the value
and effects of
\cd{(gcd (gcd x y) z)} for any values of the
variables \cdf{x}, \cdf{y}, and \cdf{z}.''
This implies that the two pieces
of code do the same thing; however, neither directly defines
the other in the way macro expansion does.

\subsection{Errors}
\label{INTRO-ERRORS}

When this book specifies that it ``is an error'' for some situation
to occur, this means that:

\begin{itemize}
\item No valid Common Lisp program should cause this situation to occur.

\item If this situation occurs, the effects and results are completely
undefined as far as adherence to the Common Lisp specification is concerned.

\item No Common Lisp implementation is required to detect such an error.
Of course, implementors are encouraged to provide for detection
of such errors wherever reasonable.
\end{itemize}
This is not to say that some particular implementation might not define
the effects and results for such a situation; the point is that no program
conforming to the Common Lisp specification may correctly depend on such
effects or results.

On the other hand, if it is specified in this book that in some situation
``an error is \emph{signaled},'' this means that:

\begin{itemize}
\item If this situation occurs, an error will be signaled
(see \cdf{error} and \cdf{cerror}).

\item Valid Common Lisp programs may rely on the fact that an error will be
signaled.

\item Every Common Lisp implementation is required to detect such an error.
\end{itemize}

In places where it is stated that so-and-so ``must'' or ``must not''
or ``may not''  be the case, then it ``is an error'' if the stated requirement
is not met.  For example, if an argument ``must be a symbol,'' then it
``is an error'' if the argument is not a symbol.  In all cases where
an error is to be \emph{signaled}, the word ``signaled'' is always used
explicitly in this book.

\begin{newer}
X3J13 has adopted a more elaborate terminology for errors,
and has made some effort to specify the type of error to be signaled
in situations where signaling is appropriate.  This effort
was not complete as of September 1989, and I have made little
attempt to incorporate the new error terminology or
error type specifications in this book.  However, the new terminology
is described and used in the specification of the
Common Lisp Object System appearing in chapter~\ref{CLOS}; this gives
the flavor of how erroneous situations will be described,
and appropriate actions prescribed, in the forthcoming ANSI Common
Lisp standard.
\end{newer}

\begin{table}[t]
\caption{Sample Function Description}
\label{Sample-Function-Description}
\begin{defun}*[Function]
sample-function arg1 arg2 &optional arg3 arg4

The function \cdf{sample-function} adds together \emph{arg1} and \emph{arg2}, and
then multiplies the result by \emph{arg3}.  If \emph{arg3} is not provided or
is {\nil}, the multiplication isn't done.  \cdf{sample-function} then returns
a list whose first element is this result and whose second element is
\emph{arg4} (which defaults to the symbol \cdf{foo}).
For example: 
\begin{lisp}
(sample-function 3 4) \EV\ (7 foo) \\
(sample-function 1 2 2 'bar) \EV\ (6 bar)
\end{lisp}
In general,
\cd{(sample-function \emph{x} \emph{y})} \EQ\ \cd{(list (+ \emph{x} \emph{y}) 'foo)}.
\end{defun}
\caption{Sample Variable Description}
\label{Sample-Variable-Description}
\begin{defun}*[Variable]
*sample-variable*

The variable \cd{*sample-variable*} specifies how many times
the special operator \cdf{sample-special-form} should iterate.
The value should always be a non-negative integer or {\nil}
(which means iterate indefinitely many times).  The initial value is \cd{0}
(meaning no iterations).
\end{defun}
\caption{Sample Constant Description}
\label{Sample-Constant-Description}
\begin{defun}*[Constant]
sample-constant

The named constant \cdf{sample-constant} has as its value
the height of the terminal screen in furlongs times
the base-2 logarithm of the implementation's total disk capacity in bytes,
as a floating-point number.
\end{defun}
\end{table}

\begin{table}[t]
\caption{Sample Special Form Description}
\label{Sample-Special-Form-Description}
\begin{defspec}*
sample-special-form [name] ({var}*) {form}+

This evaluates each form in sequence as an implicit \cdf{progn}, and does this
as many times as specified by
the global variable \cd{*sample-variable*}.  Each variable \emph{var} is bound
and initialized to \cd{43} before the first iteration, and unbound after
the last iteration.
The name \emph{name}, if supplied, may be used in a \cdf{return-from} form
to exit from the loop prematurely.  If the loop ends normally,
\cdf{sample-special-form} returns {\nil}.
For example:
\begin{lisp}
(setq *sample-variable* 3) \\
(sample-special-form {\emptylist} \emph{form1} \emph{form2})
\end{lisp}
This evaluates \emph{form1}, \emph{form2}, \emph{form1}, \emph{form2}, \emph{form1}, \emph{form2}
in that order.
\end{defspec}
\caption{Sample Macro Description}
\label{Sample-Macro-Description}
\begin{defmac}*
sample-macro var <declaration* | doc-string> {tag | statement}*

This evaluates the statements as a \cdf{prog} body,
with the variable \emph{var} bound to \cd{43}.
\begin{lisp}
(sample-macro x (return (+ x x))) \EV\ 86 \\
(sample-macro \emph{var} . \emph{body}) \EX\ (prog ((\emph{var} 43)) . \emph{body})
\end{lisp}
\end{defmac}
\end{table}

\subsection{Descriptions of Functions and Other Entities}
\label{FUNCTION-HEADER-NOTATION-SECTION}

Functions, variables, named constants, special operators, and macros are described
using a distinctive typographical format.
Table~\ref{Sample-Function-Description} illustrates the manner
in which Common Lisp functions are documented.
The first line specifies the name of the function,
the manner in which it accepts arguments,
and the fact that it is a function.
If the function takes many arguments, then the names of the arguments
may spill across two or three lines.
The paragraphs following this standard header
explain the definition and uses of the function and often
present examples or related functions.

Sometimes two or more related functions are explained in a single
combined description.  In this situation the headers for all the
functions appear together, followed by the combined description.

In general, actual code (including actual names of functions)
appears in this typeface: \cd{(cons a b)}.
Names that stand for pieces of code (metavariables) are written in
\emph{italics}.  In a function description, the names of the parameters appear
in italics for expository purposes.  The word \cd{\&optional} in the
list of parameters indicates that all arguments past that point are
optional; the default values for the parameters are described in the
text.  Parameter lists may also contain \cd{\&rest}, indicating that an
indefinite number of arguments may appear, or \cd{\&key}, indicating
that keyword arguments are accepted.
(The \cd{\&optional}/\cd{\&rest}/\cd{\&key}
syntax is actually used in Common Lisp function definitions for these purposes.)

Table~\ref{Sample-Variable-Description} illustrates the manner in
which a global variable is documented.  The first line specifies the
name of the variable and the fact that it is a variable.
Purely as a matter of convention, all global variables used
by Common Lisp have names beginning and ending with an asterisk.

Table~\ref{Sample-Constant-Description} illustrates the manner in
which a named constant is documented.  The first line specifies the
name of the constant and the fact that it is a constant.
(A constant is just like a global variable, except that it is
an error ever to alter its value or to bind it to a new value.)

Tables~\ref{Sample-Special-Form-Description}
and~\ref{Sample-Macro-Description} illustrate the documentation
of special operators and macros, which are closely related in purpose.
These are very different from functions.
Functions are called according to a single, specific, consistent syntax;
the \cd{\&optional}/\cd{\&rest}/\cd{\&key} syntax specifies how the function uses its arguments
internally but does not affect the syntax of a call.
In contrast, each special operator or macro can have its own idiosyncratic syntax.
It is by special operators and macros that the syntax of Common Lisp is defined
and extended.

In the description of a special operator or macro, an italicized word names a
corresponding part of the form that invokes the special operator or macro.
Parentheses stand for themselves and should be
written as such when invoking the special operator or macro.
Brackets, braces, stars, plus signs, and vertical bars are metasyntactic
marks. 
Brackets,
[ and ], indicate that what they enclose is optional
(may appear zero times or one time in that place); the square
brackets should not be written in code.
Braces, \{ and \}, simply parenthesize what they enclose
but may be followed by a star, \{\}*, or a plus sign, \{\}+;
a star indicates that what the braces enclose may appear any number of times
(including zero, that is, not at all), whereas a plus sign indicates
that what the braces enclose may appear any non-zero number of times
(that is, must appear at least once).  Within braces or brackets,
a vertical bar, |, separates mutually exclusive choices.
In summary, the notation \Mstar{x} means zero or more occurrences
of \emph{x}, the notation \Mplus{x} means one or more occurrences
of \emph{x}, and the notation \Mopt{x} means zero or one occurrence
of \emph{x}.  These notations are also used for syntactic
descriptions expressed as BNF-like productions, as
in table~\ref{NUMBER-SYNTAX-TABLE}.

Double brackets, [[ and ]], indicate that any number of the
alternatives enclosed may be used, and those used
may occur in any order, but each
alternative may be used at most once unless followed by a star.
For example,
\begin{tabbing}
\emph{p} \Mchoice{x {\Mor} \Mstar{y} {\Mor} z} \emph{q}
\end{tabbing}
means that
at most one \emph{x}, any number of \emph{y}'s, and at most one \emph{z}
may appear between the mandatory occurrences of \emph{p}
and \emph{q}, and those that appear may be in any order.

A downward arrow, \Mind{}, indicates a form of syntactic indirection
that helps to make \Mchoice{~} notation more readable.  If \emph{X} is
some non-terminal symbol occurring on the left-hand side of some BNF
production, then the right-hand
side of that production is to be textually substituted for any occurrence
of \Mind{X}.  Thus the two fragments
\begin{tabbing}
\emph{p} \Mchoice{\Mind{xyz-mixture}} \emph{q} \\
\emph{xyz-mixture} ::= \emph{x\/} {\Mor} \Mstar{y} {\Mor} \emph{z\/}
\end{tabbing}
are together equivalent to the previous example.

In the last example in table~\ref{Sample-Macro-Description}, notice the
use of dot notation.  The dot appearing in the expression
\cd{(sample-macro \emph{var} . \emph{body})} means that the name \emph{body} stands
for a list of forms, not just a single form, at the end of a list.  This
notation is often used in examples.

In the heading line in table~\ref{Sample-Macro-Description}, notice the
use of \Mchoice{~} notation to indicate that any number of declarations
may appear but at most one documentation string (which may appear before,
after, or somewhere in the middle of any declarations).

\subsection{The Lisp Reader}

The term ``Lisp reader'' refers not to you, the reader of this book,
nor to some person reading Lisp code, but specifically
to a Lisp procedure, namely the function \cdf{read},
which reads characters from an input stream and interprets them by parsing
as representations of Lisp objects.

\subsection{Overview of Syntax}

Certain characters are used in special ways in the syntax of Common Lisp.
The complete syntax is explained in detail in chapter~\ref{IO},
but a quick summary here may be useful:

\begin{indentdesc}{1.2pc}
\item[\cd{(}]
A left parenthesis begins a list of items.  The list may
contain any number of items, including zero.  Lists may be nested.
For example, \cd{(cons (car x) (cdr y))} is a list of three things,
of which the last two are themselves lists.

\item[\cd{)}] A right parenthesis ends a list of items.

\item[\cd{\Xquote}] An acute accent (also called single
quote or apostrophe) followed by an expression \emph{form}
is an abbreviation for \cd{(quote \emph{form})}.  Thus \cd{'foo} means
\cd{(quote foo)} and \cd{'(cons 'a 'b)} means \cd{(quote (cons (quote a) (quote b)))}.

\item[\cd{;}] Semicolon is the comment character.  It and all
characters up to the end of the line are discarded.

\item[\cd{"}] Double quotes surround character strings: \\
\cd{"This is a thirty-nine-character string."}

\item[\cd{{\Xbackslash}}] Backslash is an escape character. 
It causes the next character to be treated as a letter rather than for its usual
syntactic purpose.  For example, \cd{A{\Xbackslash}(B} denotes a symbol whose
name consists of the three characters \cdf{A}, \cd{(}, and \cdf{B}. Similarly,
\cd{"{\Xbackslash}""} denotes a character string containing one character, a
double quote, because the first and third double quotes serve to delimit the
string, and the second double quote serves as the contents of the string.  The
backslash causes the second double quote to be taken literally and prevents it
from being interpreted as the terminating delimiter of the string.

\item[\cd{|}] Vertical bars are used in pairs
to surround the name (or part of the name) of a symbol that has
many special characters in it.  It is roughly equivalent to putting a
backslash in front of every character so surrounded.  For example,
\cd{|A(B)|}, \cd{A|(|B|)|}, and \cd{A{\Xbackslash}(B{\Xbackslash})} all mean the symbol whose name
consists of the four characters \cdf{A}, \cd{(}, \cdf{B}, and \cd{)}.

\item[\cd{\#}] The number sign signals the beginning of a
complicated syntactic structure.
The next character designates the precise syntax to follow.
For example, \cd{\#o105} means $105_{8}$ (105 in octal notation);
\cd{\#x105} means $105_{16}$ (105 in hexadecimal notation);
\cd{\#b1011} means $1011_{2}$ (1011 in binary notation);
\cd{\#{\Xbackslash}L} denotes a character object for the character \cdf{L}; and
\cd{\#(a b c)} denotes a vector of three elements \cdf{a}, \cdf{b}, and \cdf{c}.
A particularly important case is that \cd{\#'\emph{fn}} means \cd{(function \emph{fn})},
in a manner analogous to \cd{'\emph{form}} meaning \cd{(quote \emph{form})}.

\item[\cd{{\Xbq}}] Grave accent (``backquote'') signals that
the next expression is a template that may contain commas.  The backquote syntax
represents a program that will construct a data structure
according to the template.

\item[\cd{,}] Commas are used within the backquote syntax.

\item[\cd{:}] Colon is used to indicate which package a
symbol belongs to. For example, \cd{network:reset} denotes the symbol named
\cdf{reset} in the package named \cdf{network}.  A leading colon indicates a
\emph{keyword}, a symbol that always evaluates to itself. x
The colon character is not actually part of the print name
of the symbol.
This is all explained in chapter~\ref{XPACK}; until you read
that, just keep in mind that a symbol notated with a leading colon
is in effect a constant that evaluates to itself.
\end{indentdesc}

Brackets, braces, question mark, and exclamation point
(that is, \cd{{\Xlbracket}}, \cd{{\Xrbracket}}, \cd{{\Xlbrace}}, \cd{{\Xrbrace}},
\cd{?}, and \cd{!}) are not used for any purpose in standard Common Lisp syntax.
These characters are explicitly reserved to the user, primarily
for use as \emph{macro characters} for user-defined lexical syntax extensions
(see section~\ref{MACRO-CHARACTERS-SECTION}).

All code in this book is written using lowercase letters.
Common Lisp is generally insensitive to the case in which code
is written.  Internally, names of symbols are ordinarily
converted to and stored in uppercase form.
There are ways to force case conversion on output if desired;
see \cdf{*print-case*}.
In this book, wherever an interactive exchange between a user
and the Lisp system is shown, the input is exhibited with lowercase
letters and the output with uppercase letters.

\cdf{readtable-case} settings allow the names of symbols
to be case-sensitive.  The default behavior, however, is as described
in the previous paragraph.  In any event, only uppercase letters
appear in the internal print names of symbols naming the
standard Common Lisp facilities described in this book.

%RUSSIAN
\else

\chapter{Вступление}

Common Lisp [Коммон Лисп] это новый диалект Lisp'а [Лиспа], наследник
MacLisp'а \cite{MOONUAL,PITMANUAL}, под влиянием
ZetaLisp'а \cite{BLUE-LISPM,GREEN-LISPM}, в некоторой мере расширенный Schema'ой
\cite{SCHEME-REVISED-REPORT} и Interlisp'ом \cite{INTERLISP}. 

\section{Цель}

Common Lisp предназначен для достижения следующих целей: 

\begin{flushdesc}
\item[\emph{Объединение}] 
Common Lisp создан в попытке сфокусировать работу
нескольких групп разработчиков, каждая из которых создавала потомка MacLisp'а
для различных компьютеров. Это реализации начинали отличаться из-за различий в
платформах: персональные компьютеры (Zetalisp, Spice Lisp), коммерческие
компьютеры с разделением времени (NIL--- <<Новая реализация Lisp'а>>) и
суперкомпьютеры (S-1 Lisp). Тогда как различия между платформам приводят к
несовместимостям между реализациями, Common Lisp предоставляет общий диалект,
который каждая реализация будет расширять для своих потребностей.

\item[\emph{Переносимость}]
Переносимость
Common Lisp умышленно исключает функционал, который не может быть легко
реализован на  широком  спектре  машин. С одной
стороны, сложный или дорогой в аппаратной реализации без специальных
микрокодов функционал исключается или
представляется в более абстрактной и эффективно реализуемой форме.
(Примером тому являются невидимые ссылочные указатели и локативы ZetaLisp'а.
Некоторые из решаемых ими проблем в CommonLisp разрешаются другими путями.)
С другой стороны, функционал полезный только на некоторых <<обычных>> или
<<коммерческих>> процессорах исключается или делается опциональными. (Примером
тому является система декларации типа, которая на некоторых реализациях
полезна, а на других полностью игнорируется. Декларации типов полностью
опциональны и в правильных программах влияют только на эффективность, а не на
семантику.) Common Lisp спроектирован для упрощения построения программ,
которые как можно меньше зависят от машинно-специфичных характеристик, таких,
как, например, длина слова, но при этом допускает некоторые различия реализаций.

\item[\emph{Согласованность}]
Многие реализации Lisp'а внутренне не согласованы в том, что семантика одной и
той же корректной программы может различаться для интерпретатора и
компилятора. Эти семантические различия преимущественно вытекают
из факта, что интерпретатор считает все переменные динамическими, тогда как
компилятор считает все переменные лексическими, если иное не указано явно. Такое
различие было обычной практикой в Lisp'е для 
достижения удобства и эффективности, но могло быть причиной скрытых, очень
"тонких" ошибок. Определение Common Lisp'а исключает такие аномалии явным
требованием к интерпретатору и компилятору реализовывать
идентичные семантики для корректных программ настолько, насколько
это возможно.

\item[\emph{Выразительность}]
Common Lisp собрал конструкции, которые, как показывает опыт, наиболее удобны и
понятны, не только из MacLisp'а, но также из других диалектов, и языков
программирования. Конструкции, оценённые как неуклюжие или бесполезные были
исключены. 

\item[\emph{Совместимость}]
Common Lisp старается быть совместимым с Lisp Machine Lisp'ом,
MacLisp'ом и Interlisp'ом, примерно в таком порядке.

\item[\emph{Эффективность}]
Common Lisp содержит много функционала, созданного для облегчения
производства высококачественного скомпилированного кода в тех
реализациях, разработчики которых заинтересованы в создании
эффективного компилятора. Одна реализация Common Lisp'а называемая
S-1 Lisp, уже содержит компилятор, который производит код для
математических вычислений, который конкурирует в скорости выполнения
с кодом, произведенных компилятором Fortran'а \cite{S1-COMPILER}. Компилятор S-1
Lisp дополняет по созданию наиболее эффективных численных вычислений,
проделанную в MacLisp'е \cite{MACLISP-BEATS-FORTRAN}.

\item[\emph{Мощность}]
Common Lisp является потомком MacLisp'а, который традиционно делал
акцент на предоставлении иструментов для построения систем. Такие инструменты в
свою очередь могли быть использованы для создания пользовательских
пакетов, вроде тех, что предоставлял Interlisp. Эти пакеты, однако, не
являются частью спецификации Common Lisp'а. Ожидается, что
такие пакеты будут построены на основе Common Lisp ядра.

\item[\emph{Стабильность}]
Предполагается, что Common Lisp будет изменяться медленно с
должным обдумыванием. 
Различные диалекты, которые являются надмножествами Common Lisp'а, могут служить
лабораториями для тестирования расширений языка, но такие расширения будут
добавляться в Common Lisp только после внимательного изучения и экспериментов.
\end{flushdesc}

Цели Common Lisp'а, таким образом, очень близки к Standard Lisp'у \cite{STANDARD-LISP-REPORT}
и Portable Standard Lisp'у \cite{PSL-MANUAL}. Common Lisp отличается от Standard
Lisp'а преимущественно тем, что содержит больше возможностей, включая более
богатую и более сложную систему типов и более сложные управляющие конструкции. 

Эта книга прежде всего предназначена быть спецификацией языка, а не
описанием реализации (однако, примечания для реализаций встречаются в тексте).
Книга определяет набор стандартных языковых концепций и конструкций, которые
могут использоваться для связи данных и алгоритмов в диалекте Common Lisp. Этот
набор концепций и конструкций иногда называют <<ядром языка Common Lisp>>,
потому что он содержит концептуально необходимые или важные вещи.  
Это ядро не является необходимым  минимумом для реализации. Несмотря на то, что
многие из его конструкций могут быть определены через другие, просто написанием
Lisp кода, все же кажется, что они должны быть концептуальными примитивами,
чтобы было согласие между пользователями по поводу 
того, как ими пользоваться. (Например, bignums и рациональные числа могут быть
реализованы как код, оперирующий fixnum'амами. Тем 
не менее, для концептуальной целостности языка важно то, что пользователи
считают их примитивами, и они достаточно полезны для того, чтобы внести их в
стандарт.)

По большей части данная книга описывает язык программирования, но не средства
программирования. Для обращения к таким
стандартным программным средствам, как компилятор, редактор, функции
трассировки и отладчик, определены несколько интерфейсов, но об их природе и
функционировании сказано очень мало. Предполагается, что на основе Common Lisp'а
будут построены одна или несколько обширных сред программирования, и они будут
содержать отдельную документацию. 

Теперь есть много реализаций Common Lisp'а. Некоторые были запрограммированы
исследовательскими группами в университетах, а некоторые --- компаниями, которые
продают их в коммерческих целях, и вокруг
этих реализаций фактически вырос ряд полезных сред для программирования.
Более того, все вышеуказанные цели были достигнуты, и прежде всего ---
переносимость. Перемещение большого количества Lisp-кода с одного компьютера на
другой теперь является рутинной операцией.

\section{Условные обозначения}

Для выразительности в книге используется некоторое количество условных обозначений.

\subsection{Десятичные числа}

Все числа в данной книге представлены в десятичной системе счисления кроме мест,
где система счисления указывается явно. 
(Конечно, десятичная система обычно и используется в работе.
К несчастью, в некоторых других диалектах Lisp'а, в частности MacLisp'а,
нотацией по умолчанию является восьмеричная (основание 8), вместо десятичной, и
использование десятичной системы в описании Common Lisp'а в историческом
контексте слегка необычно!) 

\subsection{Nil, False и пустой список}

В Common Lisp'е, как и во многих диалектах Lisp'а, символ \cdf{nil} используется
для представления пустого списка и булева значения <<ложь>>. Пустой список,
конечно, может, также быть записан так: \cd{()}; это обычно означает то же, что
и \cdf{nil}.
(Конечно, существует возможность крайне извращённым способом переопределить
 с помощью системы пакетов значение последовательности букв \cdf{nil}, которое будет 
обозначать не пустой список, а другой символ с этим именем. Эта мутная
возможность игнорируется в данной книге.)
Эти два обозначения могут использоваться взаимозаменяемо настолько, насколько
позволяет Lisp. В данной книге используется обозначение {\emptylist}, когда необходимо
подчеркнуть использование пустого списка, и {\false}, когда обозначается булево
значение <<ложь>>. Запись \cd{'nil} (обратите внимание на явный знак кавычки)
используется для подчеркивания того, что обозначение используется как символ.
Например:
\begin{lisp}
~~~~~~~~~~~~~~~~~~~~~~~~~~~\=\kill
(defun three () 3)\>;\textrm{Обозначает пустой список параметров} \\
(append '{\emptylist} '{\emptylist}) \EV\ {\emptylist}\>;\textrm{Обозначает использование
пустых списков} \\
(not {\false}) \EV\ {\true}\>;\textrm{Подчёркивает использование как булева значения <<ложь>>} \\
(get '{\nil} 'color)\>;\textrm{Подчёркивает использование как символа}
\end{lisp}

Любой объект данных, не являющийся {\false} истолковывается как булево значение
<<не ложь>>, которое является <<истиной>>. Символ {\true} обычно используется для
обозначения <<истины>>, когда нет более подходящего значения.
Когда говорится, что функция <<возвращает \emph{ложь}>> или <<\emph{ложна}>>
в некоторых случаях, это значит, что она возвращает {\false}.
Однако если говорится, что функция <<возвращает \emph{истину}>> или
<<\emph{истинна}>> в некоторых случаях, это значит, что она возвращает некоторое
значение отличное от {\false}, но необязательно {\true}.

\subsection{Вычисление, Раскрытие и Равенство}

Выполнение Lisp кода называется \emph{вычисление}, так как выполнение части кода
обычно возвращает некоторый объект данных, называемый \emph{значением}, созданным
этим кодом. Для обозначения вычисления в примерах используется символ \EV\ .
Например,
\begin{lisp}
(+ 4 5) \EV\ 9
\end{lisp}
означает <<результатом вычисления кода \cd{(+ 4 5)} является (или будет, или был)
\cd{9}>>.

Символ \EX\ используется в примерах для обозначения раскрытия макросов.
Например,
\begin{lisp}
(push x v) \EX\ (setf v (cons x v))
\end{lisp}
означает <<результатом раскрытия макроса формы \cd{(push x v)}
является \cd{(setf v (cons x v))}>>. Это подразумевает, что две части кода
делают одно и то же действие; вторая часть кода является определением того, что
делает первая часть.

Символ \EQ\ используется в примерах для обозначения эквивалентности
(тождественности).
Например,
\begin{lisp}
(gcd x (gcd y z)) \EQ\ (gcd (gcd x y) z)
\end{lisp}
означает <<значение и побочные эффекты вычисления формы \cd{(gcd x (gcd y z))} всегда
являются такими же, как и значение и побочные эффекты \cd{(gcd (gcd x y) z)} для любых
значений переменных \cdf{x}, \cdf{y} и \cdf{z}>>.
Это подразумевает, что две части кода делают одинаковые вещи. Однако ни одна из
них не определяет другую напрямую --- так, как это делается при раскрытии макроса.

\subsection{Ошибки}
\label{INTRO-ERRORS}

Когда в книге для некоторых возникающих ситуаций указывается, что <<это
ошибка>>, это значит: 

\begin{itemize}
\item Корректная Common Lisp программа не должна вызывать данную ситуацию.

\item Если данная ситуация случилась, побочные эффекты и результаты получатся совершенно неопределенными по спецификации Common Lisp'a.

\item От реализации Common Lisp'а не требуется обнаруживать такие ошибки.
 Конечно, разработчикам рекомендуется реализовывать детектирование подобных ошибок,
  когда это необходимо.
\end{itemize}

Имеется в виду не то, что какая-то реализация может и не задать побочные эффекты и
результаты для данных ситуаций, а иное --- то, что программа, полностью
соотвествующая спецификации Common Lisp'а, не должна быть зависима от подобных
побочных эффектов и результатов.

Однако в некоторых ситуациях, если это обозначено в книге,
<<\emph{сигнализируется} ошибка>>, и это значит: 
\begin{itemize}
\item Если данная ситуация случилась, будет сигнализирована ошибка
(см. \cdf{error} и \cdf{cerror}).

\item Корректная Common Lisp программа может полагаться на тот факт, что ошибка будет сигнализирована.

\item Каждая реализация Common Lisp'а должна детектировать такую ошибку.
\end{itemize}

В местах, где встречаются выражения <<должен>> быть или <<не должен>> быть, или что-то
<<не может>> быть, подразумевается, что если указанные условия не выполняются, то <<это ошибка>>. Например: если аргумент <<должен
быть символом>>, а аргумент не символ, тогда <<это
ошибка>>. Во всех случаях, где ошибка \emph{сигнализируется}, всегда явно
используется слово <<сигнализируется (генерируется)>>.

\begin{table}[t]
\caption{Образец описания функций}
\label{Sample-Function-Description}
\begin{defun}*[Функция]
sample-function arg1 arg2 &optional arg3 arg4

Функция \cdf{sample-function} складывает вместе \emph{arg1} и \emph{arg2} и
полученную сумму умножает на \emph{arg3}. Если \emph{arg3} не задан или равен
{\nil}, умножения не производится. \cdf{sample-function} затем возвращает список,
в котором первый элемент содержит результат, а второй элемент равен \emph{arg4}
(который по умолчанию равен символу \cdf{foo}).
Например:
\begin{lisp}
(sample-function 3 4) \EV\ (7 foo) \\
(sample-function 1 2 2 'bar) \EV\ (6 bar)
\end{lisp}
В целом,
\cd{(sample-function \emph{x} \emph{y})} \EQ\ \cd{(list (+ \emph{x} \emph{y}) 'foo)}.
\end{defun}

\caption{Образец описания переменной}
\label{Sample-Variable-Description}
\begin{defun}*[Переменная]
*sample-variable*

Переменная \cd{*sample-variable*} задаёт, сколько раз специальная
форма \cdf{sample-special-form} должна выполняться. Значение должно быть всегда
неотрицательным числом или {\nil} (что значит, выполнение бесконечно много
раз). Начальное значение \cd{0} (означает отсутствие выполнения).
\end{defun}

\caption{Образец описания константы}
\label{Sample-Constant-Description}
\begin{defun}*[Константа]
sample-constant

Именованная константа \cdf{sample-constant} имеет своим значением число с плавающей точкой, равное высоте экрана в ярдах, умноженной на логарифм по основанию 2 от общего
объёма в байтах, занимемого реализацией Common Lisp'а на диске.
\end{defun}
\end{table}

\begin{table}[t]
\caption{Образец описания специальной формы}
\label{Sample-Special-Form-Description}
\begin{defspec}*
sample-special-form [name] ({var}*) {form}+

Производит вычисление каждой формы в последовательности, как неявный \cdf{progn},
и делает это столько раз, сколько обозначено в глобальной
переменной \cd{*sample-variable*}. Каждая переменная \emph{var} связывается и
инициализируется значением \cd{43} перед первой итерацией, и
освобождается после последней итерации.
Имя \emph{name}, если задано, может быть использовано в \cdf{return-from} форме
для преждевременного выхода из цикла. Если цикл завершился
нормально, \cdf{sample-special-form} возвращает {\nil}.
Например:
\begin{lisp}
(setq *sample-variable* 3) \\
(sample-special-form {\emptylist} \emph{form1} \emph{form2})
\end{lisp}
Здесь вычисляется \emph{form1}, \emph{form2}, \emph{form1},
\emph{form2}, \emph{form1}, \emph{form2} в указанном порядке.  
\end{defspec}
\caption{Образец описания макроса}
\label{Sample-Macro-Description}
\begin{defmac}*
sample-macro var <declaration* | doc-string> {tag | statement}*

Вычисляет выражения как тело \cdf{prog} с переменной \emph{var} связанной со
значением \cd{43}.
\begin{lisp}
(sample-macro x (return (+ x x))) \EV\ 86 \\
(sample-macro \emph{var} . \emph{body}) \EX\ (prog ((\emph{var} 43)) . \emph{body})
\end{lisp}
\end{defmac}
\end{table}

\subsection{Описания функций и других объектов}
\label{FUNCTION-HEADER-NOTATION-SECTION}

Функции, переменные, именованные константы, специальные формы и макросы
описываются с помощью особого типографского формата.
Таблица~\ref{Sample-Function-Description} показывает способ, которым
документируются Common Lisp функции.
Первая строка определяет имя функции, способ передачи аргументов, и тот факт,
что это функция.
Если функция принимает много аргументов, тогда имена аргументов могут быть
разнесены на две или три строки.
Параграф, следующий за этим стандартным заголовком, разъясняет определение и
использование данной функции, а зачастую также предоставляет примеры или связанные
функции.

Иногда две и более связанных функций даются в одном комбинированном
описании. В такой ситуации заголовки для всех функций отображаются совместно, с
последующим описанием.

Текущий код (включая текущие имена функций) представляется в данном
шрифте: \cd{(cons a b)}.
Имена, встречающиеся в частях кода (метапеременные) пишутся \emph{наклонным
шрифтом}. В описании функции имена параметров предоставляются в наклонном
шрифте. Слово \cd{\&optional} в списке параметров указывает на то, что все
последующие аргументы являются необязательными. Значения по умолчанию для
параметров описываются в последующем тексте. Список параметров может также
включать \cd{\&rest}, указывающий на возможность бесконечного количества
аргументов, или \cd{\&key}, указывающий на то, что допустимы именованные аргументы.
(Синтаксис \cd{\&optional}/\cd{\&rest}/\cd{\&key} и в самом деле используется для
этих целей при определении функций Common Lisp).

Таблица~\ref{Sample-Variable-Description} показывает способ, с помощью которого
документируются глобальные переменные. Первая строка определяет имя переменной
и тот факт, что это переменная.  Исключительно для удобства было принято
соглашение, что все глобальные переменные Common Lisp'а имеют имена,
начинающиеся и заканчивающиеся звёздочкой (asterisk).

Таблица~\ref{Sample-Constant-Description} отображает способ, с помощью которого
документируются константы. Первая строка определяет имя константы и тот факт, что это
константа.
(Константа является просто глобальной переменной за исключением того, что
 при попытке связывания этой переменной с другим значением возникает ошибка.)

Таблицы~\ref{Sample-Special-Form-Description} и~\ref{Sample-Macro-Description}
показывают документирование специальных форм и макросов, предназначения которых
тесно связаны.
Они очень сильно отличаются от функций.
Функции вызываются в соответствии с одним определённым неизменным механизмом.
Синтаксис \cd{\&optional}/\cd{\&rest}/\cd{\&key} задаёт то, как функция
внутренне использует свои аргументы, но не влияет на механизм вызова.
В отличие от этого, каждая специальная форма или макрос может иметь свой
особенный, индивидуальный механизм. Синтаксис Common Lisp'а задаётся и
расширяется с помощью специальных форм и макросов.

В описании специальных форм или макросов слова, записанные наклонным шрифтом, обозначают
соответствующую часть формы, которая вызывает специальную форму или макрос.
Круглые скобки означают сами себя, и должны быть указаны как есть при
вызове специальной формы или макроса.
Квадратные скобки, фигурные скобки, звездочки, знаки плюса и вертикальные скобки
является метасинтаксическими знаками.
Квадратные скобки,
[ и ], показывают, что заключённое в них выражение является
необязательным (может встречаться ноль или один раз в данном месте); квадратные
скобки не должны записываться в коде.
Фигурные скобки, \{ и \}, просто отображают заключённое в них
выражение, однако после закрывающей скобки может следовать звёздочка, * или
знак плюс +. Звёздочка показывает, что выражение в скобках может
встречаться НОЛЬ и более раз, тогда как плюс показывает, что выражение может
встречаться ОДИН и более раз. Внутри скобок, может использоваться вертикальная
черта |, она разделяет взаимоисключаемые элементы выбора.
В целом, запись \Mstar{x} значит, что \emph{x} может встречаться ноль и
более раз, запись \Mplus{x} значит, что \emph{x} может встречаться один и
более раз, и запись \Mopt{x} значит, что \emph{x} может встречаться ноль или
один раз. Такие записи также используются для описания выражений в стиле БНФ,
как в таблице~\ref{NUMBER-SYNTAX-TABLE}.

Двойные скобки, [[ и ]], показывают, что может использоваться любое количество
альтернатив, перечисленных в скобках, и в любом порядке, но каждая альтернатива
может использоваться не более одного раза, если только за ней нет звёздочки.
Например,
\begin{tabbing}
\emph{p} \Mchoice{x {\Mor} \Mstar{y} {\Mor} z} \emph{q}
\end{tabbing}
означает, что максимум один \emph{x}, любое количество \emph{y}, и максимум один
\emph{z} могут в любом порядке использоваться между обязательными \emph{p} и
\emph{q}.

Стрелочка вниз, \Mind{}, показывает, что данная форма будет раскрываться
ниже. Это делает запись \Mchoice{~} более читаемой. Если \emph{X} является
некоторым нетерминальным символом, стоящим слева в некоторой БНФ форме, правая
ее часть должна быть подставлена вместо символа \Mind{X} во всех случаях его
использования. Таким образом, два фрагмента

\begin{tabbing}
\emph{p} \Mchoice{\Mind{xyz-mixture}} \emph{q} \\
\emph{xyz-mixture} ::= \emph{x\/} {\Mor} \Mstar{y} {\Mor} \emph{z\/}
\end{tabbing}
вместе составляют эквивалент для предыдущего примера.

В последнем примере в таблице~\ref{Sample-Macro-Description}, рассматривается
использование записи с точкой. Точка, встречающаяся в выражении
\cd{(sample-macro \emph{var} . \emph{body})}, означает то, что имя \emph{body}
является списком форм, а не одиночной формой в конце списка. Эта запись 
часто используется в примерах.

В заглавной строке в таблице~\ref{Sample-Macro-Description}, запись \Mchoice{~}
означает, что может указываться любое количество определений (declaration), 
но максимум одна строка документации doc-string (которая может указываться перед, после,
или между определениями).

\subsection{Лисповый считыватель}

Термин <<Лисповый считыватель (читатель лиспового кода)>> относится не к вам,
читатель этой книги, и не к какому-либо человеку, читающему код на Lisp'е, а к
Lisp процедуре, которая называется \cdf{read}. Она читает символы из входного
потока и интерпретирует их с помощью парсинга как представления Lisp объектов.

\subsection{Обзор синтаксиса}

В Common Lisp'е некоторые строковые символы используется в определённых целях. Полное
описание синтаксиса можно прочесть в главе~\ref{IO}, но небольшой обзор здесь
может быть также полезен:
\begin{indentdesc}{1.2pc}
\item[\cd{(}]
Левая круглая скобка начинает список элементов. Список может содержать любое
количество элементов, включая ноль элементов (пустой список). Списки могут быть
вложенными. Например, \cd{(cons (car x) (cdr y))} список из трёх элементов, в
котором два последних также являются списками.

\item[\cd{)}] Правая круглая скобка завершает список элементов.

\item[\cd{\Xquote}] Одинарная кавычка (апостроф) с последующим выражением
  \emph{form} является сокращением для \cd{(quote \emph{form})}.

\item[\cd{;}] Точка с запятой обозначает комментарий. Она и все символы после
неё до конца строки игнорируются.

\item[\cd{"}] Двойная кавычка окружает символьные строки: \\
\cd{"This is a thirty-nine-character string."}

\item[\cd{{\Xbackslash}}] Обратная наклонная черта является экранирующим
символом. Она показывает, что следующий символ считывается как буква, и не несет
того синтаксического смысла, который приписывается ему правилами Common
Lisp'а. Например, \cd{A{\Xbackslash}(B} означает символ, имя которого содержит
три знака: \cdf{A}, \cd{(} и \cdf{B}. Подобным образом \cd{"{\Xbackslash}""}
означает строку, которая содержит один знак - двойную кавычку. Первая и
последняя двойные кавычки обозначают начало и конец строки. Обратная наклонная
черта обозначает, что вторая двойная кавычка будет интерпретирована как знак, а
не как синтаксическая конструкция для обозначения начала и конца строки.

\item[\cd{|}] Вертикальные черты используются попарно, для окружения имени (или
части имени) символа, которое содержит много специальных знаков. Это примерно равнозначно
тому, что перед каждым из них ставилась бы обратная косая
черта. Например, \cd{|A(B)|}, \cd{A|(|B|)|}
и \cd{A{\Xbackslash}(B{\Xbackslash})} все означают одно и то же имя.

\item[\cd{\#}] Знак решётки (диез) обозначает начало сложной синтаксической
конструкции. Символ после решетки определяет последующий синтаксис.
Например, \cd{\#o105} означает $105_{8}$ (105 в восьмеричной системе счисления);
\cd{\#x105} означает $105_{16}$ (105 в шестнадцатеричной системе счисления);
\cd{\#b1011} означает $1011_{2}$ (1011 в двоичной системе счисления);
\cd{\#{\Xbackslash}L} определяет строковый символ \cdf{L}; и \cd{\#(a b c)}
обозначает вектор из трёх элементов \cdf{a}, \cdf{b} и \cdf{c}. В частности, важным
случаем является то, что \cd{\#'\emph{fn}} означает \cd{(function \emph{fn})}, на
манер использования одинарной кавычки \cd{'\emph{form}}, обозначающей \cd{(quote
\emph{form})}.

\item[\cd{{\Xbq}}] Обратная одинарная кавычка показывает, что следуемое
выражение является шаблоном, который может содержать запятые. Синтаксис этой
обратной кавычки представляет программу, которая может создавать структуры
данных в соответствии с шаблоном.

\item[\cd{,}] Запятые используются внутри конструкции с обратной кавычкой.

\item[\cd{:}] Двоеточие используется для обозначения принадлежности символа к пакету. Например, \cd{network:reset} показывает, что символ с
именем \cdf{reset} принадлежит пакету \cdf{network}. Двоеточие в начале обозначает 
keyword (примечания переводчика: это не ключевое слово в понимании других языков 
программирования), символ, который вычисляется сам в себя. Двоеточие не является
частью печатаемого имени символа. 
Это все объясняется в главе~\ref{XPACK}; пока вы её не прочли, просто держите в
голове, что символ с двоеточием в начале являлется константой, которая
вычисляется сама в себя.
\end{indentdesc}

Квадратные и фигурные скобки, вопросительный и восклицательные знаки,
(\cd{{\Xlbracket}}, \cd{{\Xrbracket}}, \cd{{\Xlbrace}}, \cd{{\Xrbrace}}, \cd{?}
и \cd{!}) не используются ни для каких целей в стандартном синтаксисе Common
Lisp. Эти символы явно зарезервированы для пользователей, преимущественно для
использования в качестве \emph{макро-символов} для пользовательских расширений
синтаксиса (см. раздел~\ref{MACRO-CHARACTERS-SECTION}).

Весь код в данной книге записан в нижнем регистре. Common Lisp не чуствителен к
регистру текста программы. Внутри при обработке Common Lisp транслирует все
имена символов в верхний регистр. С помощью \cdf{*print-case*} можно настроить
регистр вывода имен символов.
В данной книге, там где отображается взаимодействие пользователя и Lisp'овой
системы, ввод представлен в нижнем регистре, а вывод в верхнем.

Настройка переменной \cdf{readtable-case} позволяет именам символов быть
регистрозависимыми. Однако, поведение по умолчанию такое, как описано в
предыдущем параграфе. В любом случае, описанные в книге имена символов внутри
представлены с помощью букв в верхнем регистре.

\fi
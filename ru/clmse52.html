<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Спецификаторы деклараций</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-06-05 16:10:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
   <div id="toplinks"> &lt;<a href="../index.html">Главная</a>&gt; &lt;<a href="symbols.html">Символы</a>&gt; <br />&#x003C;<a 
href="clmse53.html" >Далее</a>&#x003E;&#x003C;<a 
href="clmse51.html" >Назад</a>&#x003E;&#x003C;<a 
href="clmse51.html#tailclmse51.html" >Назад-и-вниз</a>&#x003E;&#x003C;<a 
href="#tailclmse52.html">В-конец</a>&#x003E;&#x003C;<a 
href="declar.html#clmse52.html" >Наверх</a>&#x003E;</div><h3 class="sectionHead"><span class="titlemark">9.2
</span> <a 
href="clm.html#QQ2-66-112" id="x66-1030009.2">Спецификаторы деклараций</a></h3>
<!--l. 1432--><p class="noindent" >Ниже представлен список спецификаторов деклараций для использования в
<b><a 
href="symbols.html#x188-375295r295">declare</a></b>.
<div class="flushdesc">
      <ul><li><b>
<b>special</b> </b></li><b>(special <em>var1</em> <em>var2</em> ...)</b> указывает на то, что все указанные
      переменные должны рассматриваться как <em>специальные</em>. Данный
      спецификатор воздействует как на связывания переменных, так и на
      ссылки на эти переменные в коде. Все указанные связывания
      переменных будут динамическими, и ссылки будут осуществляться на
      эти связывания, а не на связывания определённые локально. Например:
      <div class="lisp"><tt><div class="tabbing">
      (defun hack (thing *mod*)       ;Связывание параметра
      <br>          (declare (special *mod*))     ; <b>*mod*</b> доступно для <b>hack1</b>,<br>
             (hack1 (car thing)))          ; но связывание <b>thing</b> нет<br>
           <br>                                                            (defun hack1 (arg)<br>
             (declare (special *mod*))     ;Декларируем что ссылка на <b>*mod*</b><br>
                                           ; внутри <b>hack1</b> будет специальной<br>
             (if (atom arg) *mod*<br>            (cons (hack1 (car arg)) (hack1 (cdr arg)))))<br>
      <!--l. 1454--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 1455--><p class="noindent" >Следует отметить, что по правилам хорошего тона, имена специальных
      переменных окружаются звёздочками.
                                                                          

                                                                          
      <!--l. 1458--><p class="noindent" >Декларация <b>special</b> <em>не</em> охватывает все связывания. Внутренние
      связывания переменных неявно скрывают декларацию <b>special</b> и
      должны быть явно передекларированы в специальные. (Однако
      прокламация <b>special</b> имеет глобальный эффект. Это сделано для
      совместимости с MacLisp&#x2019;ом.) Например: <div class="lisp"><tt><div class="tabbing">
      (proclaim &#x2019;(special x))     ;<b>x</b> всегда специальная
      <br>                                <br>                                (defun example (x y)<br>
             (declare (special y))<br>                   (let ((y 3) (x (* x 2)))<br>
               (print (+ y (locally (declare (special y)) y)))<br>
               (let ((y 4)) (declare (special y)) (foo x))))<br>
      <!--l. 1472--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 1473--><p class="noindent" >В приведенном выше коде, внешние и внутренние связывания
      переменной <b>y</b> являются специальными и, таким образом, действуют в
      динамической области видимости. Однако среднее связывание
      действует в лексической области видимости. Два аргумента <b><a 
href="symbols.html#x188-375054r54">+</a></b>
      различаются, один содержит значение <b>3</b> лексически связанной
      переменной <b>y</b>, другой содержит значение специальной переменной
      <b>y</b>. Все связывания и переменной <b>x</b> и ссылки на неё является
      специальными, так как в коде использовалась прокламация
      <b>special</b>.
      <!--l. 1482--><p class="noindent" >В целях стиля, необходимо избегать использование прокламаций
      <b>special</b>. Для объявления специальных переменных предназначены
      макросы <b><a 
href="symbols.html#x188-375316r316">defvar</a></b> и <b><a 
href="symbols.html#x188-375311r311">defparameter</a></b>.
      <li><b>
<b>type</b> </b></li><b>(type <em>type</em> <em>var1</em> <em>var2</em> ...)</b> применяются только для связываний
      переменный и указывает на то, что переменные будут принимать значения
      только указанного типа. В частности, значения присваиваемые
      переменным с помощью <b><a 
href="symbols.html#x188-375833r833">setq</a></b>, как и первоначальные значения, должны
      быть заданного типа.
<div class="new">
                                                                          

                                                                          
      <!--l. 1494--><p class="noindent" >X3J13 voted in January 1989 <a 
 id="dx66-103001"></a>to alter the interpretation of type declarations.
      They are not to be construed to aﬀect “only variable bindings.” The
      new rule for a declaration of a variable to have a speciﬁed type is
      threefold:
           <ul class="itemize1">
           <li class="itemize">It is an error if, during the execution of any reference to that
           variable  within  the  scope  of  the  declaration,  the  value  of  the
           variable is not of the declared type.
           </li>
           <li class="itemize">It is an error if, during the execution of a <b><a 
href="symbols.html#x188-375833r833">setq</a></b> of that variable
           within the scope of the declaration, the new value for the variable
           is not of the declared type.
           </li>
           <li class="itemize">It is an error if, at any moment that execution enters the scope
           of the declaration, the value of the variable is not of the declared
           type.</li></ul>
      <!--l. 1511--><p class="noindent" >One may think of a type declaration <b>(declare (type face bodoni))</b> as
      implicitly changing every reference to <b>bodoni</b> within the scope of the
      declaration to <b>(the face bodoni)</b>; changing every expression <em>exp</em> assigned
      to <b>bodoni</b> within the scope of the declaration to <b>(the face <em>exp</em>)</b>; and
      implicitly executing <b>(the face bodoni)</b> every time execution enters the
      scope of the declaration.
      <!--l. 1518--><p class="noindent" >These new rules make type declarations much more useful. Under ﬁrst
      edition rules, a type declaration was useless if not associated with a variable
      binding; declarations such as in <div class="lisp"><tt><div class="tabbing">
      (locally
      <br>                                                      (declare (type (byte 8) x y))<br>
             (+ x y))<br>
      <!--l. 1525--><p class="noindent" ></div>
</tt>
</div>
                                                                          

                                                                          
      <!--l. 1526--><p class="noindent" >at best had no eﬀect and at worst were erroneous, depending on
      one&#x2019;s interpretation of the ﬁrst edition. Under the interpretation
      approved by X3J13, such declarations have “the obvious natural
      interpretation.”
      <!--l. 1530--><p class="noindent" >X3J13 noted that if nested type declarations refer to the same variable, then
      all of them have eﬀect; the value of the variable must be a member of the
      intersection of the declared types.
      <!--l. 1534--><p class="noindent" >Nested type declarations could occur as a result of either macro expansion
      or carefully crafted code. There are three cases. First, the inner type might
      be a subtype of the outer one: <div class="lisp"><tt><div class="tabbing">
      (defun compare (apples oranges)
      <br>                                       (declare (type number apples oranges))<br>
             (cond ((typep apples &#x2019;ﬁxnum)<br>               ;; The programmer happens to know that, thanks to<br>
                    ;; constraints imposed by the caller, if APPLES<br>
                    ;; is a ﬁxnum, then ORANGES will be also, and<br>
                    ;; therefore wishes to avoid the unnecessary cost<br>
                    ;; of checking ORANGES.  Nevertheless the compiler<br>
                    ;; should be informed to allow it to optimize code.<br>
                    (locally (declare (type ﬁxnum apples oranges)))<br>
                             ;; Maybe the compiler could have ﬁgured<br>
                             ;; out by ﬂow analysis that APPLES must<br>
                             ;; be a ﬁxnum here, but it doesn&#x2019;t hurt<br>
                             ;; to say it explicitly.<br>
                      (&#x003C; apples oranges)))<br>              ((or (complex apples)<br>
                        (complex oranges))<br>
                    (error &#x0022;Not yet implemented.  Sorry.&#x0022;))<br>
                   ...))<br>
      <!--l. 1557--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 1558--><p class="noindent" >This is the case most likely to arise in code written completely by
      hand.
                                                                          

                                                                          
      <!--l. 1560--><p class="noindent" >Second, the outer type might be a subtype of the inner one. In this case the
      inner declaration has no additional practical eﬀect, but it is harmless. This
      is likely to occur if code declares a variable to be of a very speciﬁc type and
      then passes it to a macro that then declares it to be of a less speciﬁc
      type.
      <!--l. 1567--><p class="noindent" >Third, the inner and outer declarations might be for types that overlap,
      neither being a subtype of the other. This is likely to occur only as a result
      of macro expansion. For example, user code might declare a variable to be of
      type <b>integer</b>, and a macro might later declare it to be of type <b>(or
      ﬁxnum package)</b>; in this case a compiler could intersect the two
      types to determine that in this instance the variable may hold only
      ﬁxnums.
      <!--l. 1575--><p class="noindent" >The reader should note that the following code fragment is, perhaps
      astonishingly, <em>not in error</em> under the interpretation approved by X3J13:
      <div class="lisp"><tt><div class="tabbing">
      (let ((james .007)
      <br>                         (maxwell 86))<br>                     (ﬂet ((spy-swap ()<br>
                      (rotatef james maxwell)))<br>
               (locally (declare (integer maxwell))<br>            (spy-swap)<br>
                 (view-movie &#x0022;The Sound of Music&#x0022;)<br>
                 (spy-swap)<br>                                  maxwell)))<br>
            <span class="math"> ⇒</span> 86  (after a couple of hours of Julie Andrews)<br>
      <!--l. 1589--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 1590--><p class="noindent" >The variable <b>maxwell</b> is declared to be an integer over the <em>scope</em> of the type
      declaration, not over its <em>extent</em>. Indeed <b>maxwell</b> takes on the non-integer
      value <b>.007</b> while the Trapp family make their escape, but because no
      reference to <b>maxwell</b> within the scope of the declaration ever produces a
      non-integer value, the code is correct.
      <!--l. 1598--><p class="noindent" >Now the assignment to <b>maxwell</b> during the ﬁrst call to <b>spy-swap</b>,
      and the reference to <b>maxwell</b> during the second call, <em>do</em> involve
                                                                          

                                                                          
      non-integer values, but they occur within the body of <b>spy-swap</b>,
      which is <em>not</em> in the scope of the type declaration! One could put the
      declaration in a diﬀerent place so as to include <b>spy-swap</b> in the scope:
      <div class="lisp"><tt><div class="tabbing">
      (let ((james .007)
      <br>              (maxwell 86))<br>          (locally (declare (integer maxwell))<br>
               (ﬂet ((spy-swap ()<br>                   (rotatef james maxwell)))<br>
                 (spy-swap)                                   ;Bug!<br>
                 (view-movie &#x0022;The Sound of Music&#x0022;)<br>
                 (spy-swap)<br>                                  maxwell)))<br>
      <!--l. 1614--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 1615--><p class="noindent" >and then the code is indeed in error.
      </div>
<div class="new">
      <!--l. 1619--><p class="noindent" >X3J13 also voted in January 1989 <a 
 id="dx66-103002"></a>to alter the meaning of the <b><a 
href="symbols.html#x188-375434r434">function</a></b> type
      speciﬁer when used in <b>type</b> declarations (see section <a 
href="clmse22.html#x31-470004.5">4.5<!--tex4ht:ref: SPECIALIZED-TYPE-SPECIFIER-SECTION --></a>).
      </div>
      <li><b>
<em>type</em> </b></li><b>(<em>type</em> <em>var1</em> <em>var2</em> ...)</b> является аббревиатурой для <b>(type <em>type</em> <em>var1</em>
      <em>var2</em> ...)</b>, при условии, что <em>type</em> один из символов из таблицы <a 
href="clmse19.html#x28-440011">4.1<!--tex4ht:ref: TYPE-SYMBOLS-TABLE --></a>.
<div class="new">
      <!--l. 1632--><p class="noindent" >Observe that this covers the particularly common case of declaring numeric
      variables: <div class="lisp"><tt><div class="tabbing">
      (declare (single-ﬂoat mass dx dy dz)
      <br>                                             (double-ﬂoat acceleration sum))<br>
                                                                          

                                                                          
      <!--l. 1637--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 1638--><p class="noindent" >In many implementations there is also some advantage to declaring variables
      to have certain specialized vector types such as <b>base-string</b>.
      </div>
      <li><b>
<b>ftype</b> </b></li><b>(ftype <em>type</em> <em>function-name-1</em> <em>function-name-2</em> ...)</b> указывает но то,
      что именованная функция будет принимать и возвращать заданный
      типы, как в следующем примере: <div class="lisp"><tt><div class="tabbing">
      (declare (ftype (function (integer list) t) nth)
      <br>                                 (ftype (function (number) ﬂoat) sin cos))<br>
      <!--l. 1649--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 1650--><p class="noindent" >Следует отметить, что соблюдаются правила лексической области
      видимости. Если одна из указанных функций лексически ограничена (с
      помощью <b><a 
href="symbols.html#x188-375413r413">ﬂet</a></b> или <b><a 
href="symbols.html#x188-375503r503">labels</a></b>), то декларация применится для локального
      определения, а не для глобального.
<div class="newer">
      <!--l. 1655--><p class="noindent" >X3J13 voted in March 1989 <a 
 id="dx66-103003"></a>to extend <b>ftype</b> declaration speciﬁers to accept
      any function-name (a symbol or a list whose <em>car</em> is <b><a 
href="symbols.html#x188-375832r832">setf</a></b>—see section <a 
href="clmse35.html#x47-750007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>).
      Thus one may write <div class="lisp"><tt><div class="tabbing">
      (declaim (ftype (function (list) t) (setf cadr)))
      <br>
      <!--l. 1662--><p class="noindent" ></div>
</tt>
                                                                          

                                                                          
</div>
      <!--l. 1663--><p class="noindent" >to indicate the type of the <b><a 
href="symbols.html#x188-375832r832">setf</a></b> expansion function for <b><a 
href="symbols.html#x188-375175r175">cadr</a></b>.
      </div>
<div class="new">
      <!--l. 1667--><p class="noindent" >X3J13 voted in January 1989 <a 
 id="dx66-103004"></a>to alter the meaning of the <b><a 
href="symbols.html#x188-375434r434">function</a></b> type
      speciﬁer when used in <b>ftype</b> declarations (see section <a 
href="clmse22.html#x31-470004.5">4.5<!--tex4ht:ref: SPECIALIZED-TYPE-SPECIFIER-SECTION --></a>).
      </div>
<div class="new">
      <!--l. 1676--><p class="noindent" >X3J13 voted in January 1989 <a 
 id="dx66-103005"></a>to remove this interpretation of the <b><a 
href="symbols.html#x188-375434r434">function</a></b>
      declaration speciﬁer from the language. Instead, a declaration speciﬁer
      <div class="lisp"><tt><div class="tabbing">
      (function <em>var1</em> <em>var2</em> ...)
      <br>
      <!--l. 1683--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 1684--><p class="noindent" >is to be treated simply as an abbreviation for <div class="lisp"><tt><div class="tabbing">
      (type function <em>var1</em> <em>var2</em> ...)
      <br>
      <!--l. 1687--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 1688--><p class="noindent" >just as for all other symbols appearing in table <a 
href="clmse19.html#x28-440011">4.1<!--tex4ht:ref: TYPE-SYMBOLS-TABLE --></a>.
      <!--l. 1690--><p class="noindent" >X3J13 noted that although <b><a 
href="symbols.html#x188-375434r434">function</a></b> appears in table <a 
href="clmse19.html#x28-440011">4.1<!--tex4ht:ref: TYPE-SYMBOLS-TABLE --></a>, the ﬁrst edition
      also discussed it explicitly, with a diﬀerent meaning, without noting whether
      the diﬀering interpretation was to replace or augment the interpretation
      regarding table <a 
href="clmse19.html#x28-440011">4.1<!--tex4ht:ref: TYPE-SYMBOLS-TABLE --></a>. Unfortunately there is an ambiguous case: the
      declaration <div class="lisp"><tt><div class="tabbing">
                                                                          

                                                                          
      (declare (function foo nil string))
      <br>
      <!--l. 1699--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 1700--><p class="noindent" >can be construed to abbreviate either <div class="lisp"><tt><div class="tabbing">
      (declare (ftype (function () string) foo))
      <br>
      <!--l. 1703--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 1704--><p class="noindent" >or <div class="lisp"><tt><div class="tabbing">
      (declare (type function foo nil string))
      <br>
      <!--l. 1707--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 1708--><p class="noindent" >The latter could perhaps be rejected on semantic grounds: it would
      be an error to declare <b><a 
href="symbols.html#x188-375658r658">nil</a></b>, a constant, to be of type <b><a 
href="symbols.html#x188-375434r434">function</a></b>. In
      any case, X3J13 determined that the ice was too thin here; the
      possibility of confusion is not worth the convenience of an abbreviation
      for <b>ftype</b> declarations. The change also makes the language more
      consistent.
      </div>
                                                                          

                                                                          
      <li><b>
<b>inline</b> </b></li><b>(inline <em>function1</em> <em>function2</em> ...)</b> указывает, что <em>было бы неплохо</em>
      встроить код указанных функций непосредственно в место вызова. Это
      может ускорить работу программы, но затруднить отладку (например,
      вызовы встроенных функций не могут быть протрассированы).
      Помните, компилятор может игнорировать эту декларацию.
      <!--l. 1723--><p class="noindent" >Следует отметить, что соблюдаются правила лексической области
      видимости. Если одна из указанных функций лексически ограничена (с
      помощью <b><a 
href="symbols.html#x188-375413r413">ﬂet</a></b> или <b><a 
href="symbols.html#x188-375503r503">labels</a></b>), то декларация применится для локального
      определения, а не для глобального.
<div class="newer">
      <!--l. 1729--><p class="noindent" >X3J13 voted in October 1988 <a 
 id="dx66-103006"></a>to clarify that during compilation the <b>inline</b>
      declaration speciﬁer serves two distinct purposes: it indicates not only that
      aﬀected calls to the speciﬁed functions should be expanded in-line, but also
      that aﬀected deﬁnitions of the speciﬁed functions must be recorded for
      possible use in performing such expansions.
      <!--l. 1736--><p class="noindent" >Looking at it the other way, the compiler is not required to save function
      deﬁnitions against the possibility of future expansions unless the functions
      have already been proclaimed to be <b>inline</b>. If a function is proclaimed (or
      declaimed) <b>inline</b> before some call to that function but the current
      deﬁnition of that function was established before the proclamation was
      processed, it is implementation-dependent whether that call will be
      expanded in-line. (Of course, it is implementation-dependent anyway,
      because a compiler is always free to ignore <b>inline</b> declaration speciﬁers.
      However, the intent of the committee is clear: for best results, the user is
      advised to put any <b>inline</b> proclamation of a function before any deﬁnition of
      or call to that function.)
      <!--l. 1750--><p class="noindent" >Consider these examples: <div class="lisp"><tt><div class="tabbing">
      (defun huey (x) (+ x 100))         ;Compiler need not remember this
      <br>                                                     (declaim (inline huey dewey))<br>
           (defun dewey (y) (huey (sqrt y)))  ;Call to <b>huey</b> unlikely to be expanded<br>
           (defun louie (z) (dewey (/ z)))    ;Call to <b>dewey</b> likely to be expanded<br>
                                                                          

                                                                          
      <!--l. 1756--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 1759--><p class="noindent" >X3J13 voted in March 1989 <a 
 id="dx66-103007"></a>to extend <b>inline</b> declaration speciﬁers to
      accept any function-name (a symbol or a list whose <em>car</em> is <b><a 
href="symbols.html#x188-375832r832">setf</a></b>—see
      section <a 
href="clmse35.html#x47-750007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>). Thus one may write <b>(declare (inline (setf cadr)))</b> to
      indicate that the <b><a 
href="symbols.html#x188-375832r832">setf</a></b> expansion function for <b><a 
href="symbols.html#x188-375175r175">cadr</a></b> should be compiled
      in-line.
      </div>
      <li><b>
<b>notinline</b> </b></li><b>(notinline <em>function1</em> <em>function2</em> ...)</b> указывает на то, что
      встраивать код указанных функций в место вызова <em>не нужно</em>. Эта
      декларация обязательна. Компилятор <em>не</em> может её игнорировать.
      <!--l. 1775--><p class="noindent" >Следует отметить, что соблюдаются правила лексической области
      видимости. Если одна из указанных функций лексически ограничена
      (с помощью <b><a 
href="symbols.html#x188-375413r413">ﬂet</a></b> или <b><a 
href="symbols.html#x188-375503r503">labels</a></b>), то декларация применится для
      локального определения, а не для глобального. <div class="newer"> X3J13 voted in
      March 1989 <a 
 id="dx66-103008"></a>to extend <b>notinline</b> declaration speciﬁers to accept any
      function-name (a symbol or a list whose <em>car</em> is <b><a 
href="symbols.html#x188-375832r832">setf</a></b>—see section <a 
href="clmse35.html#x47-750007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>).
      Thus one may write <b>(declare (notinline (setf cadr)))</b> to indicate
      that the <b><a 
href="symbols.html#x188-375832r832">setf</a></b> expansion function for <b><a 
href="symbols.html#x188-375175r175">cadr</a></b> should not be compiled
      in-line.
      </div>
<div class="new">
      <!--l. 1790--><p class="noindent" >X3J13 voted in January 1989 <a 
 id="dx66-103009"></a>to clarify that the proper way to deﬁne a
      function <b>gnards</b> that is not <b>inline</b> by default, but for which a local
      declaration <b>(declare (inline gnards))</b> has half a chance of actually
      compiling <b>gnards</b> in-line, is as follows: <div class="lisp"><tt><div class="tabbing">
      (declaim (inline gnards))
      <br>                                                                                            <br>
           (defun gnards ...)<br>                                              <br>
           (declaim (notinline gnards))<br>
                                                                          

                                                                          
      <!--l. 1802--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 1803--><p class="noindent" >The point is that the ﬁrst declamation informs the compiler that the
      deﬁnition of <b>gnards</b> may be needed later for in-line expansion, and the
      second declamation prevents any expansions unless and until it is
      overridden.
      <!--l. 1808--><p class="noindent" >While an implementation is never required to perform in-line expansion,
      many implementations that do support such expansion will not process
      <b>inline</b> requests successfully unless deﬁnitions are written with these
      proclamations in the manner shown above.
      </div>
      <li><b>
<b>ignore</b> </b></li><b>(ignore <em>var1</em> <em>var2</em> ... <em>varn</em>)</b> применяется только для связываний
      переменных и указывает на то, что связывания указанных переменных
      никогда не используются. Желательно, чтобы компилятор выдавал
      предупреждение, если переменная не используется и не задекларирована
      игнорироваться.
      <li><b>
<b>optimize</b> </b></li><b>(optimize (<em>quality1</em> <em>value1</em>) (<em>quality2</em> <em>value2</em>)...)</b> рекомендует
      компилятору использовать указанные значения для свойств
      компилятора. Свойство компилятора является символом. Стандартные
      свойства включают <b>speed</b> (скомпилированного кода), <b>space</b>
      (и размер кода и run-time space), <b>safety</b> (проверка ошибок во
      время выполнения) и <b>compilation-speed</b> (скорость процесса
      компиляции).
<div class="newer">
      <!--l. 1830--><p class="noindent" >X3J13 voted in October 1988 <a 
 id="dx66-103010"></a>to add the standard quality <b>debug</b> (ease of
      debugging).
      </div>
      <!--l. 1834--><p class="noindent" >Также реализацией могут представляться другие свойства. <em>value</em>
      должно быть неотрицательным целым числом, обычно на интервале <b>0</b> и
      <b>3</b>. Значение <b>0</b> означает, что свойство полностью не важно, и <b>3</b>, что
      свойство полностью важно. <b>1</b> и <b>2</b> промежуточные значение, <b>1</b>
      «нормальный» или «обычный» уровень. Для наизначимого уровня
                                                                          

                                                                          
      существует аббревиатура, то есть <b>(<em>quality</em> 3)</b> можно записать, как
      просто <em>quality</em>. Например: <div class="lisp"><tt><div class="tabbing">
      (defun often-used-subroutine (x y)
      <br>              (declare (optimize (safety 2)))<br>              (error-check x y)<br>
             (hairy-setup x)<br>                             (do ((i 0 (+ i 1))<br>
                  (z x (cdr z)))<br>                               ((null z) i)<br>
               ;; This inner loop really needs to burn.<br>
               (declare (optimize speed))<br>             (declare (ﬁxnum i))<br>
               )))<br>
      <!--l. 1855--><p class="noindent" ></div>
</tt>
</div>
      <li><b>
<b>declaration</b> </b></li><b>(declaration <em>name1</em> <em>name2</em> ...)</b> сообщается компилятору, что
      каждая <em>namej</em> является нестандартным именем декларации. Целью
      является указать одному компилятор не создавать предупреждений для
      деклараций, которые используются для другого компилятора.
      <!--l. 1864--><p class="noindent" >The <b>declaration</b> declaration speciﬁer may be used with <b><a 
href="symbols.html#x188-375293r293">declaim</a></b> as well as
      <b><a 
href="symbols.html#x188-375744r744">proclaim</a></b>. The preceding examples would be better written using <b><a 
href="symbols.html#x188-375293r293">declaim</a></b>,
      to ensure that the compiler will process them properly.
<div class="lisp">
<tt>
      <!--l. 1868--><p class="noindent" ><div class="tabbing">
      (declaim (declaration author
      <br>                                                           target-language<br>
                                 target-machine))<br>
           <br>                                            (declaim (target-language ada)<br>
                    (target-machine IBM-650))<br>                          <br>
           (defun strangep (x)<br>         (declare (author &#x0022;Harry Tweeker&#x0022;))<br>
             (member x &#x2019;(strange weird odd peculiar)))<br>
                                                                          

                                                                          
      <!--l. 1879--><p class="noindent" ></div>
</tt>
</div>
      <li><b>
<b>dynamic-extent</b> </b></li>
<b>
      <!--l. 1883--><p class="noindent" >(dynamic-extent <em>item1</em> <em>item2</em> ... <em>itemn</em>)</b> declares that certain variables
      or function-names refer to data objects whose extents may be regarded as
      dynamic; that is, the declaration may be construed as a guarantee on the
      part of the programmer that the program will behave correctly even if the
      data objects have only dynamic extent rather than the usual indeﬁnite
      extent.
      <!--l. 1889--><p class="noindent" >Each <em>item</em> may be either a variable name or <b>(function <em>f </em>)</b> where <em>f </em> is a
      function-name (see section <a 
href="clmse35.html#x47-750007.1">7.1<!--tex4ht:ref: FUNCTION-NAME-SECTION --></a>). (Of course, <b>(function <em>f </em>)</b> may be
      abbreviated in the usual way as <b>#&#x2019;<em>f </em></b>.)
      <!--l. 1894--><p class="noindent" >It is permissible for an implementation simply to ignore this declaration. In
      implementations that do not ignore it, the compiler (or interpreter) is free to
      make whatever optimizations are appropriate given this information; the
      most common optimization is to stack-allocate the initial value of the
      object. The data types that can be optimized in this manner may vary from
      implementation to implementation.
      <!--l. 1901--><p class="noindent" >The meaning of this declaration can be stated more precisely. We say that
      object <em>x</em> is an <em>otherwise inaccessible part</em> of <em>y</em> if and only if making <em>y</em>
      inaccessible would make <em>x</em> inaccessible. (Note that every object is an
      otherwise inaccessible part of itself.) Now suppose that construct <em>c</em> contains
      a <b>dynamic-extent</b> declaration for variable (or function) <em>v</em> (which need not
      be bound by <em>c</em>). Consider the values <span class="math"><em>w</em><sub>1</sub>,…,<em>w</em><sub>n</sub></span> taken on by <em>v</em> during
      the course of some execution of <em>c</em>. The declaration asserts that if
      some object <em>x</em> is an otherwise inaccessible part of <span class="math"><em>w</em><sub>j</sub></span> whenever <span class="math"><em>w</em><sub>j</sub></span>
      becomes the value of <em>v</em>, then just after execution of <span class="math">c</span> terminates <em>x</em> will
      be either inaccessible or still an otherwise inaccessible part of the
      value of <em>v</em>. If this assertion is ever violated, the consequences are
      undeﬁned.
      <!--l. 1916--><p class="noindent" >In some implementations, it is possible to allocate data structures in a way
      that will make them easier to reclaim than by general-purpose garbage
                                                                          

                                                                          
      collection (for example, on the stack or in some temporary area). The
      <b>dynamic-extent</b> declaration is designed to give the implementation the
      information necessary to exploit such techniques.
      <!--l. 1922--><p class="noindent" >For example, in the code fragment <div class="lisp"><tt><div class="tabbing">
      (let ((x (list &#x2019;a1 &#x2019;b1 &#x2019;c1))
      <br>                                     (y (cons &#x2019;a2 (cons &#x2019;b2 (cons &#x2019;c2 &#x2019;d2)))))<br>
             (declare (dynamic-extent x y))<br>                            ...)<br>
      <!--l. 1925--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 1925--><p class="noindent" >it is not diﬃcult to prove that the otherwise inaccessible parts of <b>x</b> include
      the three conses constructed by <b><a 
href="symbols.html#x188-375535r535">list</a></b>, and that the otherwise inaccessible
      parts of <b>y</b> include three other conses manufactured by the three calls to
      <b>cons</b>. Given the presence of the <b>dynamic-extent</b> declaration, a compiler
      would be justiﬁed in stack-allocating these six conses and reclaiming their
      storage on exit from the <b><a 
href="symbols.html#x188-375531r531">let</a></b> form.
      <!--l. 1933--><p class="noindent" >Since stack allocation of the initial value entails knowing at the object&#x2019;s
      creation time that the object can be stack-allocated, it is not generally
      useful to declare <b>dynamic-extent</b> for variables that have no lexically
      apparent initial value. For example, <div class="lisp"><tt><div class="tabbing">
      (defun f ()
      <br>           (let ((x (list 1 2 3)))<br>             (declare (dynamic-extent x))<br>
               ...))<br>
      <!--l. 1939--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 1939--><p class="noindent" >would permit a compiler to stack-allocate the list in <b>x</b>. However,
      <div class="lisp"><tt><div class="tabbing">
                                                                          

                                                                          
      (defun g (x) (declare (dynamic-extent x)) ...)
      <br>                                                          (defun f () (g (list 1 2 3)))<br>
      <!--l. 1943--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 1943--><p class="noindent" >could not typically permit a similar optimization in <b><a 
href="symbols.html#x188-375383r383">f</a></b> because of the
      possibility of later redeﬁnition of <b>g</b>. Only an implementation careful enough
      to recompile <b><a 
href="symbols.html#x188-375383r383">f</a></b> if the deﬁnition of <b>g</b> were to change incompatibly could
      stack-allocate the list argument to <b>g</b> in <b><a 
href="symbols.html#x188-375383r383">f</a></b>.
      <!--l. 1948--><p class="noindent" >Other interesting cases are <div class="lisp"><tt><div class="tabbing">
      (declaim (inline g))
      <br>                                 (defun g (x) (declare (dynamic-extent x)) ...)<br>
           (defun f () (g (list 1 2 3)))<br>
      <!--l. 1951--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 1951--><p class="noindent" >and <div class="lisp"><tt><div class="tabbing">
      (defun f ()
      <br>                               (ﬂet ((g (x) (declare (dynamic-extent x)) ...))<br>
               (g (list 1 2 3))))<br>
      <!--l. 1954--><p class="noindent" ></div>
</tt>
</div>
                                                                          

                                                                          
      <!--l. 1954--><p class="noindent" >In each case some compilers might realize the optimization is possible and
      others might not.
      <!--l. 1957--><p class="noindent" >An interesting variant of this is the so-called <em>stack-allocated rest list</em>, which
      can be achieved (in implementations supporting the optimization) by
      <div class="lisp"><tt><div class="tabbing">
      (defun f (&#x0026;rest x)
      <br>                                                     (declare (dynamic-extent x))<br>
             ...)<br>
      <!--l. 1960--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 1960--><p class="noindent" >Note here that although the initial value of <b>x</b> is not explicitly present,
      nevertheless in the usual implementation strategy the function <b><a 
href="symbols.html#x188-375383r383">f</a></b> is
      responsible for assembling the list for <b>x</b> from the passed arguments, so the <b><a 
href="symbols.html#x188-375383r383">f</a></b>
      function can be optimized by a compiler to construct a stack-allocated list
      instead of a heap-allocated list.
      <!--l. 1966--><p class="noindent" >Some Common Lisp functions take other functions as arguments; frequently
      the argument function is a so-called <em>downward funarg</em>, that is, a functional
      argument that is passed only downward and whose extent may therefore be
      dynamic. <div class="lisp"><tt><div class="tabbing">
      (ﬂet ((gd (x) (atan (sinh x))))
      <br>          (declare (dynamic-extent #&#x2019;gd))     ;<b><a 
href="symbols.html#x188-375605r605">mapcar</a></b> won&#x2019;t hang on to <b>gd</b><br>
             (mapcar #&#x2019;gd my-list-of-numbers))<br>
      <!--l. 1972--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 1975--><p class="noindent" >The following three examples are in error, since in each case the value of <b>x</b> is
      used outside of its extent. <div class="lisp"><tt><div class="tabbing">
                                                                          

                                                                          
      (length (let ((x (list 1 2 3)))
      <br>                                                 (declare (dynamic-extent x))<br>
                     x))                                    ;Wrong<br>
      <!--l. 1980--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 1980--><p class="noindent" >The preceding code is obviously incorrect, because the cons cells making up
      the list in <b>x</b> might be deallocated (thanks to the declaration) before <b><a 
href="symbols.html#x188-375530r530">length</a></b>
      is called. <div class="lisp"><tt><div class="tabbing">
      (length (list (let ((x (list 1 2 3)))
      <br>                                             (declare (dynamic-extent x))<br>
                           x)))                             ;Wrong<br>
      <!--l. 1986--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 1986--><p class="noindent" >In this second case it is less obvious that the code is incorrect, because one
      might argue that the cons cells making up the list in <b>x</b> have no eﬀect on the
      result to be computed by <b><a 
href="symbols.html#x188-375530r530">length</a></b>. Nevertheless the code brieﬂy violates the
      assertion implied by the declaration and is therefore incorrect. (It is not
      diﬃcult to imagine a perfectly sensible implementation of a garbage
      collector that might become confused by a cons cell containing a dangling
      pointer to a list that was once stack-allocated but then deallocated.)
      <div class="lisp"><tt><div class="tabbing">
      (progn (let ((x (list 1 2 3)))
      <br>                                                 (declare (dynamic-extent x))<br>
                    x)                                      ;Wrong<br>
                  (print &#x0022;Six dollars is your change have a nice day NEXT!&#x0022;))<br>
                                                                          

                                                                          
      <!--l. 1997--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 1997--><p class="noindent" >In this third case it is even less obvious that the code is incorrect, because
      the value of <b>x</b> returned from the <b><a 
href="symbols.html#x188-375531r531">let</a></b> construct is discarded right away by the
      <b><a 
href="symbols.html#x188-375749r749">progn</a></b>. Indeed it is, but “right away” isn&#x2019;t fast enough. The code brieﬂy
      violates the assertion implied by the declaration and is therefore incorrect.
      (If the code is being interpreted, the interpreter might hang on to
      the value returned by the <b><a 
href="symbols.html#x188-375531r531">let</a></b> for some time before it is eventually
      discarded.)
      <!--l. 2005--><p class="noindent" >Here is one last example, one that has little practical import but is
      theoretically quite instructive. <div class="lisp"><tt><div class="tabbing">
      (dotimes (j 10)
      <br>                                                      (declare (dynamic-extent j))<br>
             (setq foo 3)                     ;Correct<br>
             (setq foo j))                    ;Erroneous—but why? (see text)<br>
      <!--l. 2010--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 2010--><p class="noindent" >Since <b>j</b> is an integer by the deﬁnition of <b><a 
href="symbols.html#x188-375343r343">dotimes</a></b>, but <b><a 
href="symbols.html#x188-375366r366">eq</a></b> and <b><a 
href="symbols.html#x188-375367r367">eql</a></b> are not
      necessarily equivalent for integers, what are the otherwise inaccessible parts
      of <b>j</b>, which this declaration requires the body of the <b><a 
href="symbols.html#x188-375343r343">dotimes</a></b> not to “save”?
      If the value of <b>j</b> is <b>3</b>, and the body does <b>(setq foo 3)</b>, is that an error?
      The answer is no, but the interesting thing is that it depends on
      the implementation-dependent behavior of <b><a 
href="symbols.html#x188-375366r366">eq</a></b> on numbers. In an
      implementation where <b><a 
href="symbols.html#x188-375366r366">eq</a></b> and <b><a 
href="symbols.html#x188-375367r367">eql</a></b> are equivalent for <b>3</b>, then <b>3</b> is not an
      otherwise inaccessible part because <b>(eq j (+ 2 1))</b> is true, and therefore
      there is another way to access the object besides going through <b>j</b>.
      On the other hand, in an implementation where <b><a 
href="symbols.html#x188-375366r366">eq</a></b> and <b><a 
href="symbols.html#x188-375367r367">eql</a></b> are
      not equivalent for <b>3</b>, then the particular <b>3</b> that is the value of <b>j</b> is
      an otherwise inaccessible part, but any other <b>3</b> is not. Thus <b>(setq
      foo 3)</b> is valid but <b>(setq foo j)</b> is erroneous. Since <b>(setq foo j)</b> is
                                                                          

                                                                          
      erroneous in some implementations, it is erroneous in all portable
      programs, but some other implementations may not be able to detect the
      error. (If this conclusion seems strange, it may help to replace <b>3</b>
      everywhere in the preceding argument with some obvious bignum such as
      <b>375374638837424898243</b> and to replace <b>10</b> with some even larger
      bignum.)
      <!--l. 2030--><p class="noindent" >The <b>dynamic-extent</b> declaration should be used with great care. It makes
      possible great performance improvements in some situations, but if the user
      misdeclares something and consequently the implementation returns a
      pointer into the stack (or stores it in the heap), an undeﬁned situation
      may result and the integrity of the Lisp storage mechanism may be
      compromised. Debugging these situations may be tricky. Users who have
      asked for this feature have indicated a willingness to deal with such
      problems; nevertheless, I do not encourage casual users to use this
      declaration.</ul>
</div>
<!--l. 2040--><p class="indent" >   Реализация может поддерживать другие спецификаторы деклараций
(специфичные для неё). С другой стороны, компилятор Common Lisp может
игнорировать некоторые виды деклараций (например, неподдерживаемые
компилятором), за исключением спецификатора декларации <b>declaration</b>.
Однако, разработчики компиляторов поощряются в том, чтобы выдавать
предупреждение об использовании неизвестных деклараций.
                                                                          

                                                                          
<!--l. 2048--><p class="indent" >   <div id="bottomlinks">&#x003C;<a 
href="clmse53.html" >Далее</a>&#x003E;&#x003C;<a 
href="clmse51.html" >Назад</a>&#x003E;&#x003C;<a 
href="clmse51.html#tailclmse51.html" >Назад-и-вниз</a>&#x003E;&#x003C;<a 
href="clmse52.html" >В-начало</a>&#x003E;&#x003C;<a 
href="declar.html#clmse52.html" >Наверх</a>&#x003E;<br> &lt;<a href="../index.html">Главная</a>&gt; &lt;<a href="symbols.html">Символы</a>&gt;</div><a 
 id="tailclmse52.html"></a>
 
</body></html> 

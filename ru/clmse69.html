<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Приведение типов и доступ к компонентам чисел</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-09-13 23:02:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
   <div id="toplinks"> &lt;<a href="../index.html">Главная</a>&gt; &lt;<a href="symbols.html">Символы</a>&gt; <br />&#x003C;<a 
href="clmse70.html" >Далее</a>&#x003E;&#x003C;<a 
href="clmse68.html" >Назад</a>&#x003E;&#x003C;<a 
href="clmse68.html#tailclmse68.html" >Назад-и-вниз</a>&#x003E;&#x003C;<a 
href="#tailclmse69.html">В-конец</a>&#x003E;&#x003C;<a 
href="number.html#clmse69.html" >Наверх</a>&#x003E;</div><h3 class="sectionHead"><span class="titlemark">12.6
</span> <a 
href="clm.html#QQ2-86-156" id="x86-12600012.6">Приведение типов и доступ к компонентам чисел</a></h3>
<!--l. 6171--><p class="noindent" >Тогда как большинство арифметических функций будут оперировать любым
типом чисел, выполняя при необходимости приведения, следующие функции
позволяют явно преобразовывать типы данных.
<div class="defun">
<div class="defunheader">
<a 
 id="dx86-126001"></a>
<em>
<!--l. 6176--><p class="noindent" >[Функция]</em> <b>ﬂoat</b> <i>number</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>other</i>
</div>
<!--l. 6178--><p class="indent" >   Преобразует любое некомплексное число в число с плавающей точкой.
При отсутствии необязательного параметра, если <em>number</em> уже является
числом с плавающей точкой, то оно и будет возвращено, иначе число будет
преобразовано в <b>single-ﬂoat</b>. Если аргумент <em>other</em> указан, тогда он должен
быть числом с плавающей точкой, и <em>number</em> будет конвертирован в такой же
формат как у <em>other</em>.
<!--l. 6186--><p class="indent" >   Смотрите также <b><a 
href="symbols.html#x188-380256r256">coerce</a></b>.
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx86-126002"></a>
<em>
<!--l. 6190--><p class="noindent" >[Функция]</em> <b>rational</b> <i>number</i><br />
<a 
 id="dx86-126003"></a>
<em>
[Функция]</em> <b>rationalize</b> <i>number</i>
</div>
<!--l. 6193--><p class="indent" >   Каждая из этих функций преобразует любое некомплексное число в
                                                                          

                                                                          
рациональное. Если аргумент уже является рациональным, он возвращается
как есть. Две функции различаются в том, как они обрабатывают числа с
плавающей точкой.
<b>
<!--l. 6197--><p class="indent" >   rational</b> предполагает, что число с плавающей точкой совершенно точно,
и возвращает рациональное число математически эквивалентное значению
числа с плавающей точкой.
<b>
<!--l. 6201--><p class="indent" >   <a 
href="symbols.html#x188-380776r776">rationalize</a></b> предполагает, что число с плавающей точкой приближенное, и
может возвращать любое рациональное число, для которого исходное число
является наилучшим приближением. Функция пытается сохранить числитель
и знаменатель наименьшими насколько это возможно.
<!--l. 6206--><p class="indent" >   Следующие тождества всегда справедливы <div class="lisp"><tt><div class="tabbing">
(ﬂoat (rational <em>x</em>) <em>x</em>) <span class="math"> ≡</span> <em>x</em>
   <br>
<!--l. 6209--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6210--><p class="indent" >   и <div class="lisp"><tt><div class="tabbing">
(ﬂoat (rationalize <em>x</em>) <em>x</em>) <span class="math"> ≡</span> <em>x</em>
   <br>
<!--l. 6213--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6214--><p class="indent" >   То есть, преобразование числа с плавающей точкой любым из методов
туда и обратно даёт исходное число. Различие в том, что <b>rational</b> обычно
имеет более простую недорогую реализацию, тогда как <b><a 
href="symbols.html#x188-380776r776">rationalize</a></b>
представляет более «красивое» число.
<hr></div>
<div class="defun">
<div class="defunheader">
                                                                          

                                                                          
<a 
 id="dx86-126004"></a>
<em>
<!--l. 6221--><p class="noindent" >[Функция]</em> <b>numerator</b> <i>rational</i><br />
<a 
 id="dx86-126005"></a>
<em>
[Функция]</em> <b>denominator</b> <i>rational</i>
</div>
<!--l. 6224--><p class="indent" >   Эти функции принимают рациональное число (целое или дробное) и
возвращают в качестве целого числа числитель или знаменатель дроби,
приведённое к каноническому виду. Числитель целого числа и является
этим числом. Знаменатель целого числа <b>1</b>. Следует отметить, что
<div class="lisp"><tt><div class="tabbing">
(gcd (numerator <em>x</em>) (denominator <em>x</em>)) <span class="math"> ⇒</span> 1
   <br>
<!--l. 6230--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6231--><p class="indent" >   Знаменатель будет всегда строго положительным числом. Числитель
может быть любым целым числом. Например: <div class="lisp"><tt><div class="tabbing">
(numerator (/ 8 -6)) <span class="math"> ⇒</span> -4
   <br>                                                         (denominator (/ 8 -6)) <span class="math"> ⇒</span> 3<br>
<!--l. 6237--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
<!--l. 6240--><p class="indent" >   В Common Lisp&#x2019;е нет функции <b>ﬁx</b>, потому что есть несколько интересных
способов преобразовать нецелое число к целому. Эти способы представлены
функциями ниже, которые выполняются не только преобразование типа, но
также некоторые нетривиальные вычисления.
<div class="defun">
                                                                          

                                                                          
<div class="defunheader">
<a 
 id="dx86-126006"></a>
<em>
<!--l. 6246--><p class="noindent" >[Функция]</em> <b>ﬂoor</b> <i>number</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>divisor</i><br />
<a 
 id="dx86-126007"></a>
<em>
[Функция]</em> <b>ceiling</b> <i>number</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>divisor</i><br />
<a 
 id="dx86-126008"></a>
<em>
[Функция]</em> <b>truncate</b> <i>number</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>divisor</i><br />
<a 
 id="dx86-126009"></a>
<em>
[Функция]</em> <b>round</b> <i>number</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>divisor</i>
</div>
<!--l. 6251--><p class="indent" >   При вызове с одним аргументом, каждая из этих функций преобразует
аргумент <em>number</em> (который не может быть комплексным числом) в целое
число. Если аргумент уже является целым числом, то он немедленно
возвращается в качестве результата. Если аргумент дробь или число с
плавающей точкой, для конвертации функции используют различные
алгоритмы.
<b>
<!--l. 6258--><p class="indent" >   <a 
href="symbols.html#x188-380434r434">ﬂoor</a></b> преобразовывает аргумент путём отсечения к отрицательной
бесконечности, то есть, результатом является наибольшее целое число,
которое не больше чем аргумент.
<b>
<!--l. 6262--><p class="indent" >   <a 
href="symbols.html#x188-380210r210">ceiling</a></b> преобразовывает аргумент путём отсечения к положительной
бесконечности, то есть, результатом является наименьшее целое число,
которое не меньше чем аргумент.
<b>
<!--l. 6266--><p class="indent" >   <a 
href="symbols.html#x188-380968r968">truncate</a></b> преобразовывает аргумент путём отсечения к нулю, то есть,
результатом является целое число с таким же знаком, которое имеет
наибольшую целую величину, но не большую чем аргумент.
<b>
<!--l. 6270--><p class="indent" >   <a 
href="symbols.html#x188-380822r822">round</a></b> преобразовывает аргумент путём округление к ближайщему
целому. Если исходное число находится посередене (то есть содержит
слагаемое + 0.5), тогда оно округляется к ближайщему чётному числу
(которое делится на два).
                                                                          

                                                                          
<!--l. 6274--><p class="indent" >   Следующая таблица содержит то, что возвращают четыре функции для
разных аргументов.
<div class="flushleft" 
>
<!--l. 6277--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" >Аргумент</td><td align="left" >ﬂoor</td><td align="left" >ceiling</td><td align="left" >truncate</td><td align="left" >round</td>
</tr><tr><td align="left" >     2.6    </td><td align="left" >  2 </td><td align="left" >    3   </td><td align="left" >     2    </td><td align="left" >   3  </td></tr><tr><td align="left" >  2.5 </td> <td align="left" >  2 </td> <td align="left" >  3 </td> <td align="left" >  2 </td> <td align="left" >  2</td>
</tr><tr><td align="left" >     2.4    </td><td align="left" >  2 </td><td align="left" >    3   </td><td align="left" >     2    </td><td align="left" >   2  </td></tr><tr><td align="left" >  0.7 </td> <td align="left" >  0 </td> <td align="left" >  1 </td> <td align="left" >  0 </td> <td align="left" >  1</td>
</tr><tr><td align="left" >     0.3    </td><td align="left" >  0 </td><td align="left" >    1   </td><td align="left" >     0    </td><td align="left" >   0  </td></tr><tr><td align="left" > -0.3 </td> <td align="left" > -1 </td> <td align="left" >  0 </td> <td align="left" >  0 </td> <td align="left" >  0</td>
</tr><tr><td align="left" >    -0.7    </td><td align="left" >  -1  </td><td align="left" >    0   </td><td align="left" >     0    </td><td align="left" >   -1   </td></tr><tr><td align="left" > -2.4 </td> <td align="left" > -3 </td> <td align="left" > -2 </td> <td align="left" > -2 </td> <td align="left" > -2</td>
</tr><tr><td align="left" >    -2.5    </td><td align="left" >  -3  </td><td align="left" >   -2   </td><td align="left" >    -2    </td><td align="left" >   -2   </td></tr><tr><td align="left" > -2.6 </td> <td align="left" > -3 </td> <td align="left" > -2 </td> <td align="left" > -2 </td> <td align="left" > -3</td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td><td><hr></td><td><hr></td></tr><tr><td align="left" > </td></tr></table>
</div></div>
<!--l. 6296--><p class="indent" >   Если указан второй аргумент <em>divisor</em>, тогда аргумент <em>number</em> будет
разделен на <em>divisor</em>, а затем уже будут проведены вышеописанные действия.
Например, <b>(ﬂoor 5 2)</b> <span class="math"> ≡</span> <b>(values (ﬂoor (/ 5 2)))</b>, но первый вариант
потенциально эффективнее.
<div class="new">
<!--l. 6302--><p class="indent" >   This statement is not entirely accurate; one should instead say that <b>(values
(ﬂoor 5 2))</b> <span class="math"> ≡</span> <b>(values (ﬂoor (/ 5 2)))</b>, because there is a second value to
consider, as discussed below. In other words, the ﬁrst values returned by the two
forms will be the same, but in general the second values will diﬀer. Indeed, we
have <div class="lisp"><tt><div class="tabbing">
(ﬂoor 5 2) <span class="math"> ⇒</span> 2 and 1
   <br>                                                          (ﬂoor (/ 5 2)) <span class="math"> ⇒</span> 2 and 1/2<br>
<!--l. 6310--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6311--><p class="indent" >   for this example.
</div>
<em>
<!--l. 6314--><p class="indent" >   divisor</em> может любым числом, кроме комплексного. <em>divisor</em> не может
равняться нулю. Случай вызова функции с одним аргументом эквивалентен
вызову с двумя аргументами, последний из которых равен <b>1</b>.
<div class="newer">
                                                                          

                                                                          
<!--l. 6320--><p class="indent" >   In other words, the one-argument case returns an integer and fractional part
for the <em>number</em>: <b>(truncate 5.3) <span class="math"> ⇒</span> 5.0 and 0.3</b>, for example.
</div>
<!--l. 6324--><p class="indent" >   Каждая из функций возвращает <em>два</em> значения. Второе значение является
остатком и может быть получено с помощью <b><a 
href="symbols.html#x188-380656r656">multiple-value-bind</a></b> или
другими подобными конструкциями. Если любая из этих функций получает
два аргумента <em>x</em> и <em>y</em> и возвращает <em>q</em> и <em>r</em>, тогда <span class="math"><em>q</em> ⋅<em>y</em> + <em>r</em> = <em>x</em></span>. Первое
значение результата <em>q</em> всегда целочисленное. Остаток <em>r</em> целочисленный,
если оба аргумента были целочисленными, и рациональное, если оба
аргумента были рациональными, и с плавающей точкой, если один из
аргументов был с плавающей точкой. Если при вызове был указан
один аргумент, то тип данных остатка всегда такой же как и этот
аргумент.
<!--l. 6337--><p class="indent" >   Когда указывается только один аргумент, сумма двух значений
результата точно равняется переданному в параметре значению.
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx86-126010"></a>
<em>
<!--l. 6342--><p class="noindent" >[Функция]</em> <b>mod</b> <i>number</i> <i>divisor</i><br />
<a 
 id="dx86-126011"></a>
<em>
[Функция]</em> <b>rem</b> <i>number</i> <i>divisor</i>
</div>
<b>
<!--l. 6345--><p class="indent" >   <a 
href="symbols.html#x188-380643r643">mod</a></b> выполняет операцию <b><a 
href="symbols.html#x188-380434r434">ﬂoor</a></b> для двух аргументов и возвращает
<em>второй</em> результат <b><a 
href="symbols.html#x188-380434r434">ﬂoor</a></b>. Таким же образом, <b><a 
href="symbols.html#x188-380795r795">rem</a></b> выполняет операцию
<b><a 
href="symbols.html#x188-380968r968">truncate</a></b> для двух аргументов и возвращает <em>второй</em> результат <b><a 
href="symbols.html#x188-380968r968">truncate</a></b>.
<!--l. 6350--><p class="indent" >   Таким образом <b><a 
href="symbols.html#x188-380643r643">mod</a></b> и <b><a 
href="symbols.html#x188-380795r795">rem</a></b> являются обычными функциями вычисления
остатка от деления двух чисел. Аргументы могут быть также числами с
плавающей точкой. <div class="lisp"><tt><div class="tabbing">
(mod 13 4) <span class="math"> ⇒</span> 1                           (rem 13 4) <span class="math"> ⇒</span> 1
                                                                          

                                                                          
   <br>                     (mod -13 4) <span class="math"> ⇒</span> 3                          (rem -13 4) <span class="math"> ⇒</span> -1<br>
(mod 13 -4) <span class="math"> ⇒</span> -3                         (rem 13 -4) <span class="math"> ⇒</span> 1<br>
(mod -13 -4) <span class="math"> ⇒</span> -1                        (rem -13 -4) <span class="math"> ⇒</span> -1<br>
(mod 13.4 1) <span class="math"> ⇒</span> 0.4                       (rem 13.4 1) <span class="math"> ⇒</span> 0.4<br>
(mod -13.4 1) <span class="math"> ⇒</span> 0.6                      (rem -13.4 1) <span class="math"> ⇒</span> -0.4<br>
<!--l. 6361--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx86-126012"></a>
<em>
<!--l. 6365--><p class="noindent" >[Функция]</em> <b>ﬄoor</b> <i>number</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>divisor</i><br />
<a 
 id="dx86-126013"></a>
<em>
[Функция]</em> <b>fceiling</b> <i>number</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>divisor</i><br />
<a 
 id="dx86-126014"></a>
<em>
[Функция]</em> <b>ftruncate</b> <i>number</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>divisor</i><br />
<a 
 id="dx86-126015"></a>
<em>
[Функция]</em> <b>fround</b> <i>number</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>divisor</i>
</div>
<!--l. 6370--><p class="indent" >   Эти функции похожи на <b><a 
href="symbols.html#x188-380434r434">ﬂoor</a></b>, <b><a 
href="symbols.html#x188-380210r210">ceiling</a></b>, <b><a 
href="symbols.html#x188-380968r968">truncate</a></b> и <b><a 
href="symbols.html#x188-380822r822">round</a></b> за исключением
того, что результат (первый из двух) всегда целое число, а не число с
плавающей точкой. Это примерно, как если бы <b><a 
href="symbols.html#x188-380399r399">ﬄoor</a></b> передала аргументы в
<b><a 
href="symbols.html#x188-380434r434">ﬂoor</a></b>, а затем применила к первому результату <b><a 
href="symbols.html#x188-380426r426">ﬂoat</a></b> и вернула полученную
пару значений. Однако, на практике <b><a 
href="symbols.html#x188-380399r399">ﬄoor</a></b> может быть реализована более
эффективно. Такое же описание подходит к остальным трём функциям. Если
первый аргумент является числом с плавающей точкой, и второй аргумент не
точнее типа первого, тогда первый результат будет такого же типа как
первый аргумент. Например: <div class="lisp"><tt><div class="tabbing">
                                                                          

                                                                          
(ﬄoor -4.7) <span class="math"> ⇒</span> -5.0 and 0.3
   <br>                                                   (ﬄoor 3.5d0) <span class="math"> ⇒</span> 3.0d0 and 0.5d0<br>
<!--l. 6383--><p class="noindent" ></div>
</tt>
</div>
<hr>
</div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx86-126016"></a>
<em>
<!--l. 6387--><p class="noindent" >[Функция]</em> <b>decode-ﬂoat</b> <i>ﬂoat</i><br />
<a 
 id="dx86-126017"></a>
<em>
[Функция]</em> <b>scale-ﬂoat</b> <i>ﬂoat</i> <i>integer</i><br />
<a 
 id="dx86-126018"></a>
<em>
[Функция]</em> <b>ﬂoat-radix</b> <i>ﬂoat</i><br />
<a 
 id="dx86-126019"></a>
<em>
[Функция]</em> <b>ﬂoat-sign</b> <i>ﬂoat1</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>ﬂoat2</i><br />
<a 
 id="dx86-126020"></a>
<em>
[Функция]</em> <b>ﬂoat-digits</b> <i>ﬂoat</i><br />
<a 
 id="dx86-126021"></a>
<em>
[Функция]</em> <b>ﬂoat-precision</b> <i>ﬂoat</i><br />
<a 
 id="dx86-126022"></a>
<em>
[Функция]</em> <b>integer-decode-ﬂoat</b> <i>ﬂoat</i>
</div>
<!--l. 6395--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380308r308">decode-ﬂoat</a></b> принимает числа с плавающей точкой и
возвращает три значения.
<!--l. 6398--><p class="indent" >   Первое значение является мантиссой и числом того же типа, что и
аргумент. Второе значение является целочисленной экспонентой. Третье
                                                                          

                                                                          
значение отображает знак аргумента (-1.0 или 1.0) и является и числом того
же типа, что и аргумент . Пусть <em>b</em> есть система счисления для отображения
чисел с плавающей точкой, тогда <b><a 
href="symbols.html#x188-380308r308">decode-ﬂoat</a></b> делит аргумент на <em>b</em> в
некоторой степени, чтобы привести значение в промежуток включая 1/<em>b</em> и не
включая 1 и возвращает частное в качестве первого значения FIXME.
Однако, если аргумент равен нулю результат равен абсолютному значению
аргумента (то есть, если существует отрицательный ноль, то для него
возвращается положительный ноль).
<!--l. 6409--><p class="indent" >   Второе значение <b><a 
href="symbols.html#x188-380308r308">decode-ﬂoat</a></b> является целочисленным экспонентой <em>e</em>,
которая равняется степени, в которую было возведено <em>b</em>. Если аргумент
равен нулю, то может быть возвращено любое целое число, при условии, что
тожество, описанное ниже для <b>scale-format</b>, имеет место быть.
<!--l. 6414--><p class="indent" >   Третье значение <b><a 
href="symbols.html#x188-380308r308">decode-ﬂoat</a></b> является числом с плавающей точкой в том
же формате, что и аргумент, абсолютное значение которого равно 1, и знак
совпадает со знаком аргумента.
<!--l. 6418--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380831r831">scale-ﬂoat</a></b> принимает число с плавающей точкой <em>f </em> (не
обязательно между 1/<em>b</em> и 1) и целое число <em>k</em>, и возвращает <b>(* <em>f </em> (expt (ﬂoat
<em>b</em> <em>f </em>) <em>k</em>))</b>. (Использование <b><a 
href="symbols.html#x188-380831r831">scale-ﬂoat</a></b> может быть более эффективным, чем
использование возведения в степень или умножения и позволяет избежать
переполнений).
<!--l. 6424--><p class="indent" >   Следует отметить, что <div class="lisp"><tt><div class="tabbing">
(multiple-value-bind (signif expon sign)
   <br>                       (decode-ﬂoat <em>f </em>)<br>    (scale-ﬂoat signif expon))<br>
<span class="math"> ≡</span> (abs <em>f </em>)<br>
<!--l. 6430--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6431--><p class="indent" >   и <div class="lisp"><tt><div class="tabbing">
(multiple-value-bind (signif expon sign)
   <br>                                                              (decode-ﬂoat <em>f </em>)<br>
  (* (scale-ﬂoat signif expon) sign))<br>                                  <span class="math"> ≡</span> <em>f </em><br>
                                                                          

                                                                          
<!--l. 6437--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6439--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380429r429">ﬂoat-radix</a></b> возвращает (в качестве целого числа) основание <em>b</em>
для числа с плавающей точкой.
<!--l. 6442--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380430r430">ﬂoat-sign</a></b> возвращает такое число с плавающей точкой <em>z</em>,
что <em>z</em> и <em>ﬂoat1</em> имеют одинаковый знак, и <em>z</em> и <em>ﬂoat2</em> имеют равное
абсолютное значение. Аргумент <em>ﬂoat2</em> по-умолчанию имеет значение
<b>(ﬂoat 1 <em> oat1</em>)</b>. Таким образом <b>(ﬂoat-sign x)</b> всегда возвращает <b>1.0</b>
или <b>-1.0</b> в таком же формате и с тем же знаком, что и <em>x</em>. (Следует
отметить, что если реализация содержит различные представления
для отрицательного и положительного нулей, тогда <b>(ﬂoat-sign -0.0)</b>
<span class="math"> ⇒</span> <b>-1.0</b>.)
<!--l. 6451--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380427r427">ﬂoat-digits</a></b> возвращает целочисленное количество цифр
используемых в представлении аргумента. Функция <b><a 
href="symbols.html#x188-380428r428">ﬂoat-precision</a></b>
возвращает целочисленное количество цифр в мантиссе аргумента.
Если аргумент равен нулю, то результатом также будет ноль. Для
нормализованных чисел с плавающей точкой, результаты <b><a 
href="symbols.html#x188-380427r427">ﬂoat-digits</a></b> и
<b><a 
href="symbols.html#x188-380428r428">ﬂoat-precision</a></b> будут такими же. Но в случае с денормализованными
числами или нулём точность будет меньше чем количество цифр в
представлении.
<!--l. 6459--><p class="indent" >   Функция <b><a 
href="symbols.html#x188-380500r500">integer-decode-ﬂoat</a></b> похожа на <b><a 
href="symbols.html#x188-380308r308">decode-ﬂoat</a></b>, но в качестве
первого значение возвращает масштабированную целочисленную мантиссу.
Для аргумента <em>f </em>, это число будет строго меньше чем <div class="lisp"><tt><div class="tabbing">
<b>(expt <em>b</em> (ﬂoat-precision <em>f </em>))</b>
   <br>
<!--l. 6464--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6465--><p class="indent" >   на не менее чем <div class="lisp"><tt><div class="tabbing">
<b>(expt <em>b</em> (- (ﬂoat-precision <em>f </em>) 1))</b>
   <br>
                                                                          

                                                                          
<!--l. 6468--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6469--><p class="indent" >   за исключением того, что если <em>f </em> равно нулю, тогда целочисленное
значение также будет равно нулю.
<!--l. 6472--><p class="indent" >   Второе значение имеет такую же связь с первым значением, как и для
<b><a 
href="symbols.html#x188-380308r308">decode-ﬂoat</a></b>: <div class="lisp"><tt><div class="tabbing">
(multiple-value-bind (signif expon sign)
   <br>                                                    (integer-decode-ﬂoat <em>f </em>)<br>
  (scale-ﬂoat (ﬂoat signif <em>f </em>) expon))<br>                            <span class="math"> ≡</span> (abs <em>f </em>)<br>
<!--l. 6479--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6481--><p class="indent" >   Третье значение <b><a 
href="symbols.html#x188-380500r500">integer-decode-ﬂoat</a></b> будет <b>1</b> или <b>-1</b>.
_______________<div class="rationale">
<!--l. 6484--><p class="noindent" ><b>Обоснование:</b> Эти функции позволяют писать машиннонезависиммые или как
минимум машиннопараметризированные приложения с вычислениями чисел с
плавающими точками с необходимой эффективностью.
</div>___________________________________________________________________________________________________________
<hr>
</div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx86-126023"></a>
<em>
<!--l. 6493--><p class="noindent" >[Функция]</em> <b>complex</b> <i>realpart</i> <tt><a 
href="clmse29.html#x39-620005.2.2">&#x0026;optional</a></tt> <i>imagpart</i>
</div>
<!--l. 6495--><p class="indent" >    Аргументы должны быть некомплексными числами. Результатом
является число, которое имеет действительную часть <em>realpart</em> и мнимую
<em>imagpart</em>, возможно конвертированные к одному типу. Если <em>imagpart</em> не
указаны, тогда используется <b>(coerce 0 (type-of <em>realpart</em>))</b>. Необходимо
отметить, что если обе части комплексного число рациональны, и мнимая
                                                                          

                                                                          
часть равна нуля, то результатом будет только действительная часть <em>realpart</em>
так как в силу вступят правила канонизации. Таким образом результат
<b><a 
href="symbols.html#x188-380268r268">complex</a></b> не всегда является комплексным числом. Он может быть просто
рациональным числом (<b>rational</b>).
<hr></div>
<div class="defun">
<div class="defunheader">
<a 
 id="dx86-126024"></a>
<em>
<!--l. 6508--><p class="noindent" >[Функция]</em> <b>realpart</b> <i>number</i><br />
<a 
 id="dx86-126025"></a>
<em>
[Функция]</em> <b>imagpart</b> <i>number</i>
</div>
<!--l. 6511--><p class="indent" >   Эти функции возвращают действительную и мнимую части комплексного
числа. Если <em>number</em> не является комплексным числом, тогда <b><a 
href="symbols.html#x188-380792r792">realpart</a></b>
возвращает это число, а <b><a 
href="symbols.html#x188-380490r490">imagpart</a></b> возвращает <b>(* 0 <em>number</em>)</b>, другими
словами, <b>0</b> того типа, каким был аргумент.
<div class="newer">
<!--l. 6517--><p class="indent" >   A clever way to multiply a complex number <em>z</em> by <em>i</em> is to write <div class="lisp"><tt><div class="tabbing">
(complex (- (imagpart <em>z</em>)) (realpart <em>z</em>))
   <br>
<!--l. 6520--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6521--><p class="indent" >   instead of <b>(* <em>z</em> #c(0 1))</b>. This cleverness is not always gratuitous; it may be
of particular importance in the presence of minus zero. For example, if we are
using IEEE standard ﬂoating-point arithmetic and <span class="math">z = 4 + 0<em>i</em></span>, the result of the
clever expression is <span class="math"> − 0 + 4<em>i</em></span>, a true <span class="math">90<sup>∘</sup></span> rotation of <span class="math"><em>z</em></span>, whereas the result of <b>(* <em>z</em>
#c(0 1))</b> is likely to be <div class="tabbing">
                                                                          

                                                                          
<span class="math">(4 + 0<em>i</em>)(+0 + <em>i</em>) = ((4)(+0) − (+0)(1)) + ((4)(1) + (+0)(+0))<em>i</em></span>
   <br>                                   <span class="math"> = ((+0) − (+0)) + ((4) + (+0))<em>i</em> = +0 + 4<em>i</em></span><br>
<!--l. 6530--><p class="noindent" ></div>which could land on the wrong side of a branch cut, for example.
</div>
<hr></div>
                                                                          

                                                                          
<!--l. 6536--><p class="indent" >   <div id="bottomlinks">&#x003C;<a 
href="clmse70.html" >Далее</a>&#x003E;&#x003C;<a 
href="clmse68.html" >Назад</a>&#x003E;&#x003C;<a 
href="clmse68.html#tailclmse68.html" >Назад-и-вниз</a>&#x003E;&#x003C;<a 
href="clmse69.html" >В-начало</a>&#x003E;&#x003C;<a 
href="number.html#clmse69.html" >Наверх</a>&#x003E;<br> &lt;<a href="../index.html">Главная</a>&gt; &lt;<a href="symbols.html">Символы</a>&gt;</div><a 
 id="tailclmse69.html"></a>
 
</body></html> 

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//RU"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>Концепция программного интерфейса</title> 
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- 3,next,fn-in,charset=utf-8,sections+,minitoc<,html --> 
<meta name="src" content="clm.tex"> 
<meta name="date" content="2012-09-13 12:40:00"> 
<link rel="stylesheet" type="text/css" href="clm.css"> 
<link rel="stylesheet" type="text/css" href="../cltl2ed.css"></head><body 
>
   <div id="toplinks"> &lt;<a href="../index.html">Главная</a>&gt; &lt;<a href="symbols.html">Символы</a>&gt; <br />&#x003C;<a 
href="clmse145.html" >Далее</a>&#x003E;&#x003C;<a 
href="clos.html" >Назад</a>&#x003E;&#x003C;<a 
href="clos.html#tailclos.html" >Назад-и-вниз</a>&#x003E;&#x003C;<a 
href="#tailclmse144.html">В-конец</a>&#x003E;&#x003C;<a 
href="clos.html#clmse144.html" >Наверх</a>&#x003E;</div><h3 class="sectionHead"><span class="titlemark">28.1
</span> <a 
href="clm.html#QQ2-177-296" id="x177-25400028.1">Концепция программного интерфейса</a></h3>
<!--l. 5696--><p class="noindent" >Common Lisp Object System (CLOS [клос]) — это объектно-ориентированное
расширение для Common Lisp&#x2019;а. Объектная система основана на обобщённых
функциях, множественном наследовании, декларации сочетания методов и
метаобъектном протоколе.
<!--l. 5701--><p class="indent" >   Первые две части данной спецификации описывают программный
интерфейс для использования CLOS&#x2019;а. Первая часть содержит описание
концепций CLOS&#x2019;а, а вторая — описание функций и макросов, используемых
в интерфейсе для программиста. Третья часть описывает методы для
изменения поведения объектной системы.
<!--l. 5707--><p class="indent" >   Основными объектами CLOS&#x2019;а являются классы, экземпляры классов,
обобщённые функции и методы.
<!--l. 5710--><p class="indent" >   Объект <em>класса</em> отображает структуру и поведение множества других
                                                                          

                                                                          
объектов, которые называются <em>экземплярами</em> класса. Каждый объект
Common Lisp&#x2019;а является <em>экземпляром</em> класса. Класс объекта устанавливает
ряд операций, которые могут быть выполнены над объектом.
<em>
<!--l. 5715--><p class="indent" >   Обобщённые функций</em> — это функции, поведение которых зависит от
классов или типов её аргументов. Объект обобщённой функции имеет
множество методов, лямбда-список, тип сочетания методов и другую
информацию. <em>Методы</em> содержат поведение, которое зависит от класса
или типа, переданный аргументов, и операции обобщённой функции.
Говорится, что метод <em>специализирует</em> обобщённую функцию. При
вызове обобщённая функция выполняет подмножество методов. Какие
методы будут выполнены зависит от классов или типов аргументов
функции.
<!--l. 5723--><p class="indent" >   Обобщённая функция может использоваться также как и обычная
функция. В частности, обобщённая функция может быть аргументом
для таких функций, как <b><a 
href="symbols.html#x190-382444r444">funcall</a></b> и <b><a 
href="symbols.html#x190-382101r101">apply</a></b>, и может иметь глобальное
имя.
<em>
<!--l. 5727--><p class="indent" >   Метод</em> является объектом, который содержит функцию, последовательность
<em>специализаторов параметров</em>, которые указывают возможные для данного
метода классы и типы аргументов, и последовательность <em>квалификаторов</em>,
которые используются для <em>сочетания методов</em> при определении позиции
метода относительно других методов. Каждый обязательный формальный
параметр каждого метода имеет связанный специализатор, и метод
будет вызываться только при аргументах, удовлетворяющих данным
специализаторам.
<!--l. 5735--><p class="indent" >   Функционал сочетаний методов управляет порядком вызова методов
и возвратом значений обобщённой функцией. По-умолчанию CLOS
использует стандартный тип сочетания методов, но он также предоставляет
возможность определения новых типов сочетаний.
<!--l. 5740--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.1   </span> <a 
href="frontmatter.html#QQ2-177-297" id="x177-25500028.1.1">Терминология для ошибок</a></h4>
<!--l. 5743--><p class="noindent" >Ситуация — это выполнение выражения в некотором заданном контексте.
Например, ситуацией может быть вызов функции с аргументами, которые не
удовлетворяют некоторым заданным ограничениям.
                                                                          

                                                                          
<!--l. 5747--><p class="indent" >   В спецификации CLOS&#x2019;а описано поведение программ во всех ситуациях.
Кроме того указаны некоторые возможности для разработчиков реализаций.
Реализация не может расширять синтаксис или семантику объектной
системы за исключением явно описанных возможностей. В частности,
реализация не может расширять синтаксис объектной системы так, чтобы
появлялась двусмысленность между спецификацией и расширением.
<div class="flushdesc">
      <ul><li><b>
«При наступлении события <em>S</em> сигнализируется ошибка.» </b></li>
      <!--l. 5758--><p class="noindent" >Данная терминология имеет следующий смысл:
           <ul class="itemize1">
           <li class="itemize">Если   возникает   данная   ситуация,   в   интерпретаторе   и
           компиляторе при всех возможных уровнях оптимизации будет
           сигнализирована ошибка.
           </li>
           <li class="itemize">Корректные  программы  могут  полагаться  на  тот  факт,
           что  если  возникает  данная  ситуация,  в  интерпретаторе  и
           компиляторе при всех возможных уровнях оптимизации будет
           сигнализирована ошибка.
           </li>
           <li class="itemize">Любая   реализация   должна   определять   такие   ошибки   в
           интерпретаторе и компиляторе при всех возможных уровнях
           оптимизации.</li></ul>
      <li><b>
«При наступлении события <em>S</em> должна бы быть сигнализирована ошибка.» </b></li>
      <!--l. 5774--><p class="noindent" >Данная терминология имеет следующий смысл:
           <ul class="itemize1">
           <li class="itemize">Если  возникает  данная  ситуация,  будет  сигнализирована
           ошибка по крайней мере в интерпретаторе и в компиляторе
           при самом безопасном уровне оптимизации.
                                                                          

                                                                          
           </li>
           <li class="itemize">Корректная программа не может полагаться на тот факт, что
           ошибка будет сигнализирована.
           </li>
           <li class="itemize">При сигнализировании результаты выполнения не определены
           (смотрите ниже).</li></ul>
      <li><b>
«При наступлении события <em>S</em> результаты не определены.» </b></li>
      <!--l. 5789--><p class="noindent" >Данная терминология имеет следующий смысл:
           <ul class="itemize1">
           <li class="itemize">При  наступлении  данного  события,  результаты  не  могут
           быть определены. Результаты могут быть от безобидных до
           фатальных.
           </li>
           <li class="itemize">Реализация   может   детектировать   данную   ситуацию   и
           сигнализировать ошибку, но это не является требованием.
           </li>
           <li class="itemize">Программа   не   может   как-либо   полагаться   на   данную
           ситуацию.</li></ul>
      <li><b>
«При наступлении события <em>S</em> результаты точно не установлены.» </b></li>
      <!--l. 5803--><p class="noindent" >Данная терминология имеет следующий смысл:
           <ul class="itemize1">
           <li class="itemize">В   объектной   системе   эффекты   от   данной   ситуации   не
           определены, но они безобидны.
           </li>
           <li class="itemize">Реализация  может  явно  определять  последствия  данной
           ситуации.
                                                                          

                                                                          
           </li>
           <li class="itemize">Программы   не   могут   зависеть   от   последствий   данной
           ситуации, однако программы должны обрабатывать данную
           ситуацию как не установленную, но безобидную.</li></ul>
      <li><b>
«CLOS может быть расширен для покрытия ситуации <em>S</em>.» </b></li>
      <!--l. 5817--><p class="noindent" >Смысл данной терминологии в том, что реализация может обрабатывать
      данную ситуацию <em>S</em> одним из трёх случаев:
           <ul class="itemize1">
           <li class="itemize">При наступлении события <em>S</em> будет сигнализирована ошибка
           по крайней мере в интерпретаторе и в компиляторе при самом
           безопасном уровне оптимизации.
           </li>
           <li class="itemize">При  наступлении  события  <em>S</em>  результаты  выполнения  не
           определены.
           </li>
           <li class="itemize">При наступлении события <em>S</em> результаты точно определены.</li></ul>
      <!--l. 5830--><p class="noindent" >В дополнение данная терминология имеет следующий смысл:
           <ul class="itemize1">
           <li class="itemize">Переносимая  программа  не  может  зависеть  от  последствий
           данной  ситуации.  Переносимая  программа  должна  считать
           данную ситуацию не определённой.</li></ul>
      <li><b>
«Реализация может расширять синтаксис <em>S</em>.» </b></li>
      <!--l. 5840--><p class="noindent" >Эта терминология имеет следующий смысл:
           <ul class="itemize1">
           <li class="itemize">Реализация может определять недвусмысленные расширения
           для синтаксиса <em>S</em>.
                                                                          

                                                                          
           </li>
           <li class="itemize">Переносимая   программа   не   может   зависеть   от   этого
           расширения.  Все  переносимые  программы  должны  считать
           синтаксис как бессмысленный.</li></ul>
      </ul>
</div>
<!--l. 5851--><p class="indent" >   Спецификация CLOS может запрещать данные расширения, но разрешая
другие.
<!--l. 5853--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.2   </span> <a 
href="frontmatter.html#QQ2-177-298" id="x177-25600028.1.2">Классы</a></h4>
<em>
<!--l. 5856--><p class="noindent" >Класс</em> является объектом, который устанавливает структуру и поведение
некоторого множества других объектов, которые называются <em>экземплярами</em>
класса.
<!--l. 5860--><p class="indent" >   Класс может наследовать структуру и поведение от других классов.
Класс, определение которого при наследовании ссылается на другие классы,
называется <em>подклассом</em> каждого из этих классов. Классы, на которые при
наследовании происходит ссылка, называются <em>суперклассами</em> для
наследующего класса.
<!--l. 5866--><p class="indent" >   У класса может быть <em>имя</em>. Для получения имени класса может
использоваться функция <b><a 
href="symbols.html#x190-382244r244">class-name</a></b>, которая принимает объект класса
и возвращает его имя. Имя анонимного класса — <b><a 
href="symbols.html#x190-382670r670">nil</a></b>. Имя класса
может задаваться символом. Функция <b><a 
href="symbols.html#x190-382415r415">ﬁnd-class</a></b> принимает символ
и возвращает класс, имя которого заданно символом. Класс имеет
<em>собственное имя</em>, если имя является символом и если имя задаёт
данный класс. То есть, класс <em>C</em> имеет <em>собственное имя</em> <em>S</em>, если <em>S</em> =
<b>(class-name <em>C</em>)</b> и <em>C</em> = <b>(ﬁnd-class <em>S</em>)</b>. Следует отметить, что существует
возможность того, что <b>(ﬁnd-class <span class="math">S<sub>1</sub></span>)</b> = <b>(ﬁnd-class <span class="math">S<sub>2</sub></span>)</b> и <span class="math">S<sub>1</sub>≠S<sub>2</sub></span>. Если
<em>C</em> = <b>(ﬁnd-class <em>S</em>)</b>, мы говорим, что <em>C</em> является <em>классом с именем</em>
<em>S</em>.
<!--l. 5879--><p class="indent" >   Класс <span class="math">C<sub>1</sub></span> является <em>прямым суперклассом</em> класса <span class="math">C<sub>2</sub></span>, если <span class="math">C<sub>2</sub></span> в своём
определении явно указывает <span class="math">C<sub>1</sub></span> как родительский. В этом случае <span class="math">C<sub>2</sub></span>
является <em>прямым подклассом</em> <span class="math">C<sub>1</sub></span>. Класс <span class="math">C<sub>n</sub></span> является <em>суперклассом</em> для
класса <span class="math">C<sub>1</sub></span> в том случае, если существует ряд классов <span class="math">C<sub>2</sub>,…,C<sub>n−1</sub></span> такой, что
                                                                          

                                                                          
<span class="math">C<sub>i+1</sub></span> является прямым суперклассом <span class="math">C<sub>i</sub></span> для <span class="math">1 ≤<em>i</em> &#x003C; <em>n</em></span>. В этом случае <span class="math">C<sub>1</sub></span>
является подклассом <span class="math">C<sub>n</sub></span>. Класс никогда не рассматривается как суперкласс
или подкласс самого себя. То есть, если <span class="math">C<sub>1</sub></span> является суперклассом <span class="math">C<sub>2</sub></span>, тогда
<span class="math">C<sub>1</sub>≠C<sub>2</sub></span>. Множество классов, составленное из некоторого класса <em>C</em> и его
суперклассов, называется «<em>С</em> и его суперклассы».
<!--l. 5890--><p class="indent" >   Каждый класс имеет <em>список приоритетности классов</em>, который является
списком из данного класса и его суперклассов. Список отсортирован от
наиболее специфичного к наименее специфичному классу. Список
приоритетности классов используется в нескольких случаях. В общем случае
наиболее специфичные классы могут <em>скрывать</em>, или перезаписывать
свойства, которые могли бы быть унаследованы от менее специфичных
классов. Выбор метода и процесс сочетания методов использует список
приоритетности классов для упорядочивания методов от наиболее к наименее
специфичным.
<!--l. 5900--><p class="indent" >   При определении класса является важным порядок прямых суперклассов.
Каждый класс имеет <em>локальный список приоритетности классов</em>, состоящий
из данного класса и его прямых суперклассов в порядке, в котором они
перечислены в определении.
<!--l. 5904--><p class="indent" >   Список приоритетности классов всегда состоит из локальных списков
приоритетности классов для каждого класса, перечисленногов первом списка.
Классы в каждом локальном списке находятся в том же порядке, что и в
общем списке. Если порядок в локальном списке противоречит всем
остальным, то список приоритетности не создаётся, и сигнализируется
ошибка. Список приоритетности классов и его создание описывается в
разделе <a 
href="#x177-26700028.1.5">28.1.5<!--tex4ht:ref: Determining-the-Class-Precedence-List-SECTION --></a>.
<!--l. 5912--><p class="indent" >   Классы организованы в ориентированный ациклический граф.
Существует два наиболее значимых класса: <b><a 
href="symbols.html#x190-382951r951">t</a></b> и <b>standard-object</b>. Класс <b><a 
href="symbols.html#x190-382951r951">t</a></b> не
имеет суперклассов (родителей). Он является суперклассом для всех
классов, за исключением самого себя. Класс <b>standard-object</b> является
экземпляром класса <b>standard-class</b> и является суперклассом для
всех классов - экземпляров <b>standard-class</b>, за исключением самого
себя.
<!--l. 5919--><p class="indent" >   В языке предусмотрено отображение пространства CLOS классов в
пространство типов. Большинство стандартных типов Common Lisp&#x2019;а имеют
соответствующий класс с тем же именем, что и тип. Но некоторые
типы соответствия не имеют. Интеграция типов и классов описана в
разделе <a 
href="#x177-26600028.1.4">28.1.4<!--tex4ht:ref: Integrating-Types-and-Classes-SECTION --></a>.
<!--l. 5924--><p class="indent" >   Классы представлены объектами, которые в свою очередь являются
                                                                          

                                                                          
экземплярами классов. Класс класса объекта называется <em>метаклассом</em>
данного объекта. Когда конкретной объект не оговаривается, термин
<em>метакласс</em> будет использоваться для обозначения класса, экземпляры
которого сами являются классами. Метакласс устанавливает форму
наследования, используемую классами, которые являются его экземплярами,
и представление экземпляров этих классов. CLOS предоставляет основной
метакласс, <b>standard-class</b>, которого вполне достаточно для большинства
программ. Метаобъектный протокол предоставляет механизм для
определения и использования новых метаклассов.
<!--l. 5935--><p class="indent" >   За исключением явного указания, все классы упомянутые в этой главе
являются экземплярами класса <b>standard-class</b>, все обобщённые функции
являются экземплярами класса <b>standard-generic-function</b>, и все методы
являются экземплярами класса <b>standard-method</b>.
<!--l. 5940--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-25700028.1.2" id="x177-25700028.1.2">Определение классов</a></h5>
<!--l. 5942--><p class="noindent" >Для определения новых классов используется макрос <b><a 
href="symbols.html#x190-382310r310">defclass</a></b>. Определение
класса включает следующие пункты:
      <ul class="itemize1">
      <li class="itemize">Имя  нового  класса.  Для  вновь  определяемого  класса  имя  будет
      являться собственным.
      </li>
      <li class="itemize">Список прямых суперклассов нового класса.
      </li>
      <li class="itemize">Множество <em>спецификаторов слотов</em>. Каждый спецификатор слота
      включает   имя   слота   и   ноль   или   более   <em>параметров  слота</em>.
      Параметры   слота   принадлежат   только   одному   слоту.   Если
      определение   класса   содержит   два   спецификатора   слотов   с
      одинаковыми именами, то сигнализируется ошибка.
      </li>
      <li class="itemize">Множество
      <em>параметров класса</em>. Каждый параметр класса принадлежит всему
      классу в целом.</li></ul>
                                                                          

                                                                          
<!--l. 5959--><p class="indent" >   Параметры слота и класса формы <b><a 
href="symbols.html#x190-382310r310">defclass</a></b> предоставляют механизм для
следующих пунктов:
      <ul class="itemize1">
      <li class="itemize">Указание первоначального значения по-умолчанию для заданного
      слота.
      </li>
      <li class="itemize">Указание,  что  методы  для  обобщённых  функций  для  записи  и
      чтения слотов будут сгенерированы автоматически.
      </li>
      <li class="itemize">Указание  будет  ли  заданный  слот  общим  для  всех  экземпляров
      класса, или каждый экземпляр будет иметь свой собственный слот.
      </li>
      <li class="itemize">Указание множества первоначальных аргументов и их значений
      при создании экземпляра класса.
      </li>
      <li class="itemize">Указание  того,  какой  метакласс  использоваться  для  данного
      класса.
      </li>
      <li class="itemize">Указание того, какой тип данных будет храниться в слоте.
      </li>
      <li class="itemize">Указание строк документации для слотов.</li></ul>
<!--l. 5980--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-25800028.1.2" id="x177-25800028.1.2">Создание экземпляров классов</a></h5>
<!--l. 5982--><p class="noindent" >Обобщённая функция <b><a 
href="symbols.html#x190-382595r595">make-instance</a></b> создаёт и возвращает новый экземпляр
объекта. Объектная система предоставляет несколько способов для указания
того, как будет инициализирован новый экземпляр. Например, можно
указать первоначальные значения для слотов с помощью аргументов
для <b><a 
href="symbols.html#x190-382595r595">make-instance</a></b> или с помощью указания их в спецификаторе
слота.
                                                                          

                                                                          
<!--l. 5988--><p class="indent" >   В методах для обобщённых функций, которые являются частью
инициализационного протокола, могут быть выполнены другие действия
для инициализации. Весь инициализационный протокол описан в
разделе <a 
href="#x177-28500028.1.9">28.1.9<!--tex4ht:ref: Object-Creation-and-Initialization-SECTION --></a>.
<!--l. 5994--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-25900028.1.2" id="x177-25900028.1.2">Слоты</a></h5>
<!--l. 5996--><p class="noindent" >Объект, метаклассом которого является <b>standard-class</b>, имеет ноль или
более слотов. Слоты объекта определяются классом объекта. Каждый слот
может содержать одно значение. Имя слота является обычным символом,
который может использоваться и для переменной.
<!--l. 6002--><p class="indent" >   Когда слот не имеет значения, слот называется <em>несвязанным</em>. Когда
происходит чтение несвязанного слота, вызывается обобщённая функция
<b><a 
href="symbols.html#x190-382886r886">slot-unbound</a></b>. По-умолчанию установленный системой главный метод для
<b><a 
href="symbols.html#x190-382886r886">slot-unbound</a></b> сигнализирует ошибку.
<!--l. 6007--><p class="indent" >   Значение по-умолчанию для слота устанавливается с помощью параметра
слота <b>:initform</b>. Когда для установки значения используется форма
<b>:initform</b>, то она вычисляется в том же лексическом окружении, что и
<b><a 
href="symbols.html#x190-382310r310">defclass</a></b>. <b>:initform</b> вместе с лексическим окружением, тем же что и для
<b><a 
href="symbols.html#x190-382310r310">defclass</a></b>, называется <em>захваченной</em> <b>:initform</b>. Смотрите раздел <a 
href="#x177-28500028.1.9">28.1.9<!--tex4ht:ref: Object-Creation-and-Initialization-SECTION --></a>.
<em>
<!--l. 6014--><p class="indent" >   Локальный слот</em> — это слот, который доступен только в рамках одного
экземпляра класса. <em>Разделяемый слот</em> — это слот, который одновременно
доступен для нескольких экземпляров класса.
<!--l. 6018--><p class="indent" >   Говорится, что класс <em>определяет</em> слот с заданным именем, если форма
<b><a 
href="symbols.html#x190-382310r310">defclass</a></b>, которая создаёт класс, содержит спецификатор слота с этим
именем. Определение локального слота не создаёт его немедленно.
Определение указывает, что слот будет создаваться каждый раз при
создании экземпляра класса. Определение разделяемого слота создаёт его
немедленно.
<!--l. 6025--><p class="indent" >   Параметр <b>:allocation</b> для <b><a 
href="symbols.html#x190-382310r310">defclass</a></b> указывает тип создаваемого
слота. Если значение <b>:allocation</b> равно <b>:instance</b>, тогда слот будет
локальным. Если значение <b>:allocation</b> равно <b>:class</b>, тогда слот будет
разделяемым.
<!--l. 6030--><p class="indent" >   Слот называется <em>доступным</em> для экземпляра класса, если слот был
определён в этом классе, или был унаследован от суперкласса. Заданное
                                                                          

                                                                          
имя может указывать на не более чем один слот экземпляра класса.
Разделяемый слот доступен для всех экземпляров класса. Подробное
описание наследования слотов дано в разделе <a 
href="#x177-26300028.1.3">28.1.3<!--tex4ht:ref: Inheritance-of-Slots-and-Slot-Options-SECTION --></a>.
<!--l. 6036--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-26000028.1.2" id="x177-26000028.1.2">Получение доступа к слотам</a></h5>
<!--l. 6038--><p class="noindent" >К слоту можно получить доступ двумя способами: с помощью использования
простой функции <b><a 
href="symbols.html#x190-382887r887">slot-value</a></b> или с помощью обобщённых функций,
созданных с помощью формы <b><a 
href="symbols.html#x190-382310r310">defclass</a></b>.
<b>
<!--l. 6042--><p class="indent" >   <a 
href="symbols.html#x190-382887r887">slot-value</a></b> может быть использована с любым именем слота, которое было
определено в форме <b><a 
href="symbols.html#x190-382310r310">defclass</a></b>, для доступа к некоторому слоту, доступному в
экземпляре класса.
<!--l. 6046--><p class="indent" >   Макрос <b><a 
href="symbols.html#x190-382310r310">defclass</a></b> предоставляет синтаксис для генерации методов для
чтения и записи слотов. Если необходимо <em>чтение</em>, тогда автоматически
генерируется метод для чтения значения слота, однако для записи метод не
генерируется. Если необходима <em>запись</em>, тогда автоматически генерируется
метод для записи значение в слот, однако для чтения метод не генерируется.
Если необходим <em>аксессор</em>, тогда автоматически генерируются методы для
чтения и для записи. Метода для чтения и записи реализуются с помощью
<b><a 
href="symbols.html#x190-382887r887">slot-value</a></b>.
<!--l. 6054--><p class="indent" >   Когда для слота указываются методы чтения и записи, то также
указывается имя для обобщённой функции. Если в качестве имени
метода указан символ <em>name</em>, тогда именем обобщённой функции для
записи слота является символ <em>name</em>, и обобщённая функция принимает
два аргумента: новое значение и экземпляр класса, соответственно.
Если имя указанное для аксессора является символом <em>name</em>, имя
обобщённой функции для чтения слота является символом <em>name</em>, и имя
обобщённой функции для записи слота является символом списком <b>(setf
<em>name</em>)</b>.
<!--l. 6063--><p class="indent" >   Обобщённая функция созданная в результате использования параметров
слота чтения, записи или аксессора является обычной обобщённой функцией,
и может использоваться в соответствующих местах.
<!--l. 6067--><p class="indent" >   Следует отметить, что <b><a 
href="symbols.html#x190-382887r887">slot-value</a></b> может использоваться для чтения или
записи значение в слот вне зависимости от того, существуют ли метода для
чтения или записи слота. Когда используется <b><a 
href="symbols.html#x190-382887r887">slot-value</a></b>, методы чтения или
                                                                          

                                                                          
записи не вызываются.
<!--l. 6072--><p class="indent" >   Макрос <b><a 
href="symbols.html#x190-383023r1023">with-slots</a></b> может быть использован для установки лексического
окружения, в котором указанные слоты доступны лексически как если бы
они были просто переменными. Макрос <b><a 
href="symbols.html#x190-383023r1023">with-slots</a></b> вызывает функцию
<b><a 
href="symbols.html#x190-382887r887">slot-value</a></b> для доступа к указанным слотам.
<!--l. 6077--><p class="indent" >   Макрос <b><a 
href="symbols.html#x190-383013r1013">with-accessors</a></b> может быть использован для установки
лексического окружения, в котором указанные слоты доступны лексически с
помощью аксессоров как если бы они были просто переменными. Макрос
<b><a 
href="symbols.html#x190-383013r1013">with-accessors</a></b> вызывает соответствующие аксессоры для доступа к
указанным слотам. Любой аксессор, указанный в <b><a 
href="symbols.html#x190-383013r1013">with-accessors</a></b> должен
быть уже доступным перед использованием.
<!--l. 6084--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.3   </span> <a 
href="frontmatter.html#QQ2-177-303" id="x177-26100028.1.3">Наследование</a></h4>
<!--l. 6087--><p class="noindent" >Класс может наследовать методы, слоты и другие параметры формы
<b><a 
href="symbols.html#x190-382310r310">defclass</a></b> от своих суперклассов (родительских классов). Следующие разделы
описывают наследование методов, слотов и их параметров, и параметров
класса.
<!--l. 6091--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-26200028.1.3" id="x177-26200028.1.3">Наследование методов</a></h5>
<!--l. 6094--><p class="noindent" >Подкласс наследует методы в том смысле, что любой метод применимый ко
всем экземплярам некоторого класса также может быть применён ко всем
экземплярам любого подкласса данного класса.
<!--l. 6098--><p class="indent" >   Наследование методов работает одинаково вне зависимости от того, был
ли метод создан с помощью формы определения метода или с помощью
параметра формы <b><a 
href="symbols.html#x190-382310r310">defclass</a></b>, который указал на автоматическую генерацию
метода.
<!--l. 6102--><p class="indent" >   Подробное описание наследования методов дано в разделе <a 
href="#x177-27600028.1.7">28.1.7<!--tex4ht:ref: Method-Selection-and-Combination-SECTION --></a>.
<!--l. 6105--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-26300028.1.3" id="x177-26300028.1.3">Наследование слотов и их параметров</a></h5>
<!--l. 6108--><p class="noindent" >Множество имен всех слотов доступных в экземпляре класса <em>C</em> является
объединением множеств слотов определяемых классом <em>С</em> и его суперклассами.
                                                                          

                                                                          
<em>Структура</em> экземпляра — это множество имён локальных слотов в данном
экземпляре.
<!--l. 6113--><p class="indent" >   В простейшем случае, среди класса <em>C</em> и его суперклассов только один
из них определяет слот с заданным именем. Если слот определён в
суперклассе <em>C</em>, слот называется <em>унаследованным</em>. Характеристики слота
установлены с помощью спецификатора слота в определяющем его классе.
Рассмотрим класс определяющий слот <em>S</em>. Если значение параметра слота
<b>:allocation</b> равно <b>:instance</b>, тогда <em>S</em> является локальным слотом и каждый
экземпляр класса <em>C</em> имеет свой собственный слот с именем <em>S</em>. Если
значение параметра слота <b>:allocation</b> равно <b>:class</b>, тогда <em>S</em> является
разделяемым слотом, класс, который определял <em>S</em> хранит значение
слота, и все экземпляры <em>C</em> могут получить доступ к этому слоту. Если
параметр слота <b>:allocation</b> не указан, по-умолчанию используется
<b>:instance</b>.
<!--l. 6125--><p class="indent" >   В общем случае, среди классов <em>C</em> и его суперклассов определять слот с
заданным именем могут несколько классов. В таких случаях в экземпляре
класса <em>C</em> будет доступен только один слот, и свойства этого слота будут
комбинацией нескольких спецификаторов слотов в соответствие с
пунктами:
      <ul class="itemize1">
      <li class="itemize">Все                             спецификаторы                             слота
      для данного имени слота упорядочиваются от наиболее к наименее
      специфичному, в соответствие списка приоритетности классов для
      <em>C</em>, которые этот слот определяют. All references to the speciﬁcity of
      slot speciﬁers immediately following refer to this ordering.
      </li>
      <li class="itemize">Тип
      слота (разделяемый, локальный) определяется наиболее близким
      спецификатором  слота.  Если  наиболее  близкий  спецификатор
      слота  не  содержит  параметр  <b>:allocation</b>,  используется  значение
      <b>:instance</b>. Более дальние спецификаторы слота влияния на тип
      слота не оказывают.
      </li>
      <li class="itemize">По-умолчанию      первоначальная      форма      значения      для
      слота является значением параметра слота <b>:initform</b> из наиболее
                                                                          

                                                                          
      близкого спецификатора слота, который такой параметр содержит.
      Если ни один спецификатор слота не содержит параметр <b>:initform</b>,
      слот не будет иметь первоначальное значение по-умолчанию.
      </li>
      <li class="itemize">Содержимое  слота  всегда  будет  принадлежать  типу  <b>(and  <span class="math">T<sub>1</sub></span>  <span class="math">…</span>
      <span class="math">T<sub>n</sub></span>)</b>,  где  <span class="math">T<sub>1</sub>,…,T<sub>n</sub></span>  являются  значениями  параметра  слота  <b>:type</b>,
      содержащимися во всех спецификаторах слота. Если спецификатор
      слота не содержит параметр <b>:type</b>, содержимое слота будет всегда
      принадлежать  типу  <b><a 
href="symbols.html#x190-382951r951">t</a></b>.  Результат  попытки  сохранить  в  слоте
      значение, которое не принадлежит указанному типу, не определён.
      </li>
      <li class="itemize">Множество         аргументов,         которые         инициализируют
      заданный является объединением всех аргументов перечисленных
      в параметре слота <b>:initarg</b> во всех спецификаторах.
      </li>
      <li class="itemize">Строка документации для слота будет взята из наиболее ближнего
      спецификатора,  который  содержит  параметр  <b>:documentation</b>.
      Если ни один спецификатор не содержал данного параметра, то
      слот не будет содержать строку документации.</li></ul>
<!--l. 6167--><p class="indent" >   Следствие правила назначения типа слота (разделяемого, локального)
заключается в том, что разделяемый слот может быть затенён. Например,
если класс <span class="math">C<sub>1</sub></span> определяется слот с именем <em>S</em>, значение параметра
<b>:allocation</b> которого равно <b>:class</b>, то этот слот будет доступен для
всех экземпляров <span class="math">C<sub>1</sub></span> и его подклассов. Однако, если <span class="math">C<sub>2</sub></span> является
подклассом <span class="math">C<sub>1</sub></span> и также определяет слот с именем <em>S</em>, слот из <span class="math">C<sub>1</sub></span> не
будет разделяемым между экземплярами <span class="math">C<sub>2</sub></span> и его подклассами. Если
класс <span class="math">C<sub>1</sub></span> определяет разделяемый слот, тогда любой подкласс <span class="math">C<sub>2</sub></span> для
<span class="math">C<sub>1</sub></span> будет иметь этот разделяемый слот, пока форма <b><a 
href="symbols.html#x190-382310r310">defclass</a></b> для <span class="math">C<sub>2</sub></span>
не определит слот с тем же именем, или <span class="math">C<sub>2</sub></span> не получит суперкласс
приоритетнее суперкласса <span class="math">C<sub>1</sub></span>, который определяет слот с таким же
именем.
<!--l. 6179--><p class="indent" >   Следствие из правила указания типа содержимого слота заключается в
том, что значение слота удовлетворяет ограничениям типа каждого
спецификатора слота в данном классе и всех его суперклассов. Так как
результат попытки сохранения значения, которое не удовлетворяет типу, не
                                                                          

                                                                          
определён, то слот может случайно содержать это значение.
<!--l. 6185--><p class="indent" >   Параметры слота <b>:reader</b>, <b>:writer</b> и <b>:accessor</b> создают методы, а не
определяют какие-либо свойства слота. Наследование методов чтения и
записи описано в разделе <a 
href="#x177-26200028.1.3">28.1.3<!--tex4ht:ref: Inheritance-of-Methods-SECTION --></a>.
<!--l. 6189--><p class="indent" >   Методы, которые выполняют доступ к слотам, используют только имя
слота и тип значения слота. Предположим, что суперкласс предоставляет
метод, который обеспечивает доступ к разделяемому слота с некоторым
именем, и подкласс определяет локальный слот с этим же именем. Если
метод, представленный от суперкласса, используется для экземпляра
подкласса, метод будет оперировать с локальным слотом.
<!--l. 6196--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-26400028.1.3" id="x177-26400028.1.3">Наследование параметров класса</a></h5>
<!--l. 6198--><p class="noindent" >Параметр класса <b>:default-initargs</b> наследуется. Множество всех
первоначальных аргументов класса является объединением множеств этих
аргументов для данного класса и всех его суперклассов. В случае коллизий
выбирается значение наиболее близкого класса.
<!--l. 6203--><p class="indent" >   Если некоторый параметр класса <b>:default-initargs</b> определяет
аргумент с одним и тем же именем более одного раза, сигнализируется
ошибка.
<!--l. 6206--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-26500028.1.3" id="x177-26500028.1.3">Примеры</a></h5>
<div class="lisp">
<tt>
<!--l. 6208--><p class="noindent" ><div class="tabbing">
(defclass C1 ()
   <br>         ((S1 :initform 5.4 :type number)<br>          (S2 :allocation :class)))<br>
<br>                                                         (defclass C2 (C1)<br>
  ((S1 :initform 5 :type integer)<br>                  (S2 :allocation :instance)<br>
   (S3 :accessor C2-S3)))<br>
<!--l. 6217--><p class="noindent" ></div>
                                                                          

                                                                          
</tt>
</div>
<!--l. 6219--><p class="noindent" >Экземпляры класса <b>C1</b> содержат локальный слот с именем <b>S1</b>, значение
по-умолчанию которого 5.4 и это значение всегда должно быть числовым.
Класс <b>C1</b> также содержит разделяемый слот с именем <b>S2</b>.
<!--l. 6223--><p class="indent" >   В экземплярах класса <b>C2</b> будут присутствовать слоты с именем <b>S1</b>.
Первоначальное значение по-умолчанию для слота <b>S1</b> равно 5. Значение
слота <b>S1</b> принадлежит типу <b>(and integer number)</b>. В экземплярах <b>C2</b>
также будут присутствовать слоты с именами <b>S2</b> и <b>S3</b>. Класс <b>C2</b> также
имеет метод <b>C2-S3</b> для чтения значения слота <b>S3</b>. Данный метод также
используется для записи значения в слот <b>S3</b>.
<!--l. 6230--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.4   </span> <a 
href="frontmatter.html#QQ2-177-308" id="x177-26600028.1.4">Интеграция типов и классов</a></h4>
<!--l. 6233--><p class="noindent" >CLOS отображает пространство классов в пространство типов Common Lisp&#x2019;а.
Каждый класс, который имеет имя собственное, имеет соответствующий
одноимённый тип.
<!--l. 6236--><p class="indent" >   Собственное имя любого класса является корректным спецификатором
типа. Кроме того, каждый объект класса (не экземпляр) является
корректным спецификатором типа. Таким образом выражение <b>(typep <em>object
class</em>)</b> вычисляется в истину, если класс <em>object</em> является собственно классом
<em>class</em> или подклассом для <em>class</em>. Вычисление выражения <b>(subtypep <em>class1
class2</em>)</b> возвращает значения <b><a 
href="symbols.html#x190-382951r951">t</a></b> и <b><a 
href="symbols.html#x190-382951r951">t</a></b>, если <em>class1</em> является подклассом <em>class2</em>
или если они являются одним и тем же классом, иначе выражение
возвращает значения <b><a 
href="symbols.html#x190-382670r670">nil</a></b> и <b><a 
href="symbols.html#x190-382951r951">t</a></b>. Если <em>I</em> является экземпляром некоторого
класса <em>C</em> с именем <em>S</em> и <em>C</em> является экземпляром метакласса <b>standard-class</b>,
тогда вычисление выражения <b>(type-of <em>I</em></b> будет возвращать <b>S</b>, если <em>S</em>
является собственным именем <em>C</em>. Если <em>S</em> не является именем собственным <em>C</em>,
выражение <b>(type-of <em>I</em>)</b> будет возвращать <em>C</em>.
<!--l. 6251--><p class="indent" >   Так как имена классов и объекты (не экземпляры) классов является
спецификаторами типов, они могут быть использованы в специальном
операторе <b><a 
href="symbols.html#x190-382958r958">the</a></b> и в декларациях типов.
<!--l. 6255--><p class="indent" >   Многие, но не все, определённые стандартом спецификаторы типов имеют
соответствующие классы с тем же именем собственным. Эти типы
перечислены в таблице <a 
href="#x177-2660021">28.1<!--tex4ht:ref: CLOS-PRECEDENCE-TABLE --></a>. Например, тип <b>array</b> имеет соответствующий
одноимённый класс. Спецификаторы типов, представленные списками, не
                                                                          

                                                                          
имеют соответствующих классов. Форма <b><a 
href="symbols.html#x190-382326r326">deftype</a></b> не создаёт никаких
классов.
<!--l. 6261--><p class="indent" >   Любой класс, который соответствует определённому стандартом
спецификатору типа, может быть реализован тремя способами на усмотрение
реализации. Он может быть <em>стандартным классом</em> (типов класса,
определяемым с помощью <b><a 
href="symbols.html#x190-382310r310">defclass</a></b>), <em>классом структуры</em> (определяемым с
помощью <b><a 
href="symbols.html#x190-382325r325">defstruct</a></b>), или <em>встроенным классом</em> (реализованным специальным
нерасширяемым способом).
<!--l. 6268--><p class="indent" >   Встроенный класс тот, экземпляры которого имеют ограниченные
возможности или специальные представления. При попытке использовать
<b><a 
href="symbols.html#x190-382310r310">defclass</a></b> для определения подкласса для встроенного класса будет
сигнализирована ошибка. При вызове <b><a 
href="symbols.html#x190-382595r595">make-instance</a></b> для создания
экземпляра встроенного класса будет сигнализирована ошибка. При
вызове <b><a 
href="symbols.html#x190-382887r887">slot-value</a></b> для создания экземпляра встроенного класса будет
сигнализирована ошибка. При переопределении встроенного класса или
использовании <b><a 
href="symbols.html#x190-382214r214">change-class</a></b> для изменения класса экземпляра в или из
встроенного класса будет сигнализирована ошибка. Однако встроенные
классы могут быть использованы в качестве специализатора параметра в
методах.
<!--l. 6281--><p class="indent" >   Существует возможность определения является ли класс встроенным с
помощью проверки метакласса. Стандартный класс является экземпляром
метакласса <b>standard-class</b>, встроенный класс является экземпляром
метакласса <b>built-in-class</b>, и класс структуры является экземпляром
метакласса <b>structure-class</b>.
<!--l. 6287--><p class="indent" >   Любой тип структуры, созданный с помощью <b><a 
href="symbols.html#x190-382325r325">defstruct</a></b> без использования
параметра <b>:type</b>, имеет соответствующий класс. Этот класс является
экземпляром метакласса <b>structure-class</b>.
<!--l. 6291--><p class="indent" >   Параметр <b>:include</b> <b><a 
href="symbols.html#x190-382325r325">defstruct</a></b> создаёт прямой подкласс класса,
соответствующего наследуемой структуре.
<!--l. 6294--><p class="indent" >   Много стандартных Common Lisp&#x2019;овых спецификаторов типов имеют
соответствующие классы для того, чтобы пользователи могли писать методы,
которые различаются на основе этих типов.
<!--l. 6298--><p class="indent" >   Иерархические отношения между спецификаторами типов зеркально
отражены на отношения между классами, соответствующим данным типам.
Существующая иерархия типов используется для установки списков
приоритетности классов для каждого класса, соответствующего Common
Lisp&#x2019;овому типу.
<!--l. 6303--><p class="indent" >   В таблице <a 
href="#x177-2660021">28.1<!--tex4ht:ref: CLOS-PRECEDENCE-TABLE --></a> перечислены все классы, которые имеют соответствующие
                                                                          

                                                                          
спецификаторы типов. Суперклассы для каждого такого класса представлены в
порядке от наиболее близкого к наиболее дальнему, или просто в порядке
приоритетности. По этой таблице может быть составлен локальный список
приоритетности классов для каждого такого класса, который соответствует
типу.
<!--l. 6310--><p class="indent" >   Отдельные реализации могут расширять этот список добавляя другие
спецификаторы типов и соответствующие классы. Отдельные реализации
могут расширять список приоритетности классов при условии, что не
нарушится иерархия отношений типов и дизъюнкция, описанная в
разделе <a 
href="clmse17.html#x24-400002.15">2.15<!--tex4ht:ref: DATA-TYPE-RELATIONSHIPS --></a>. Стандартный класс, определённый без прямых суперклассов,
гарантированно не пересекается с другими классами в таблице, за
исключением класса с именем <b><a 
href="symbols.html#x190-382951r951">t</a></b>. FIXME
<!--l. 6319--><p class="indent" >   [At this point the original CLOS report speciﬁed that certain Common Lisp
types were to appear in table <a 
href="#x177-2660021">28.1<!--tex4ht:ref: CLOS-PRECEDENCE-TABLE --></a> if and only if X3J13 voted to make them
disjoint from <b>cons</b>, <b>symbol</b>, <b>array</b>, <b>number</b>, and <b><a 
href="symbols.html#x190-382234r234">character</a></b>. X3J13 voted to do
so in June 1988 <a 
 id="dx177-266001"></a>. I have added these types and their class precedence lists to the
table; the new types are indicated by asterisks.—GLS]
   <div class="table">
                                                                          

                                                                          
<!--l. 6328--><p class="indent" >   <a 
 id="x177-2660021"></a><hr class="float"><div class="float" 
>
                                                                          

                                                                          
  <div class="caption" 
><span class="id">Таблица 28.1:   </span><span  
class="content">Родительские   классы   для   отображения   Common
Lisp&#x2019;овых типов</span></div><!--tex4ht:label?: x177-2660021 -->
<div class="flushleft" 
>
<!--l. 6331--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" >Common Lisp&#x2019;овый тип</td><td align="left" >Список приоритетности классов для соответствующего типа/класса</td>
</tr><tr><td align="left" >array                         </td><td align="left" >(array t)                                                                                   </td>
</tr><tr><td align="left" >bit-vector                   </td><td align="left" >(bit-vector vector array sequence t)                                                </td>
</tr><tr><td align="left" >character                    </td><td align="left" >(character t)                                                                             </td>
</tr><tr><td align="left" >complex                     </td><td align="left" >(complex number t)                                                                    </td>
</tr><tr><td align="left" >cons                          </td><td align="left" >(cons list sequence t)                                                                  </td>
</tr><tr><td align="left" >ﬂoat                          </td><td align="left" >(ﬂoat number t)                                                                         </td>
</tr><tr><td align="left" >function *                   </td><td align="left" >(function t)                                                                               </td>
</tr><tr><td align="left" >hash-table *                </td><td align="left" >(hash-table t)                                                                            </td>
</tr><tr><td align="left" >integer                       </td><td align="left" >(integer rational number t)                                                           </td>
</tr><tr><td align="left" >list                            </td><td align="left" >(list sequence t)                                                                         </td>
</tr><tr><td align="left" >null                           </td><td align="left" >(null symbol list sequence t)                                                         </td>
</tr><tr><td align="left" >number                      </td><td align="left" >(number t)                                                                                </td>
</tr><tr><td align="left" >package *                   </td><td align="left" >(package t)                                                                               </td>
</tr><tr><td align="left" >pathname *                </td><td align="left" >(pathname t)                                                                             </td>
</tr><tr><td align="left" >random-state *            </td><td align="left" >(random-state t)                                                                        </td>
</tr><tr><td align="left" >ratio                          </td><td align="left" >(ratio rational number t)                                                             </td>
</tr><tr><td align="left" >rational                      </td><td align="left" >(rational number t)                                                                    </td>
</tr><tr><td align="left" >readtable *                 </td><td align="left" >(readtable t)                                                                             </td>
</tr><tr><td align="left" >sequence                    </td><td align="left" >(sequence t)                                                                              </td>
</tr><tr><td align="left" >stream *                     </td><td align="left" >(stream t)                                                                                 </td>
</tr><tr><td align="left" >string                        </td><td align="left" >(string vector array sequence t)                                                     </td>
</tr><tr><td align="left" >symbol                       </td><td align="left" >(symbol t)                                                                                </td>
</tr><tr><td align="left" >t                               </td><td align="left" >(t)                                                                                           </td>
</tr><tr><td align="left" >vector                        </td><td align="left" >(vector array sequence t)                                                             </td></tr></table>
</div></div>
<!--l. 6363--><p class="noindent" >[An asterisk indicates a type added to this table as a consequence of a portion of
the CLOS speciﬁcation that was conditional on X3J13 voting to make that type
disjoint from certain other built-in types <a 
 id="dx177-266003"></a>.—GLS]
                                                                          

                                                                          
   </div><hr class="endfloat" />
   </div>
   <h4 class="subsectionHead"><span class="titlemark">28.1.5   </span> <a 
href="frontmatter.html#QQ2-177-310" id="x177-26700028.1.5">Определение списка приоритетности классов</a></h4>
<!--l. 6372--><p class="noindent" >Форма <b><a 
href="symbols.html#x190-382310r310">defclass</a></b> содержит список упорядоченных прямых суперклассов
для задаваемого класса. Этот список называется <em>локальным списком
приоритетности классов</em>. Это отсортированный список из класса
и его прямых суперклассов. <em>Список приоритетности классов</em> для
класса <em>C</em> является упорядоченным списком из класса <em>C</em> и всех его
суперклассов, который согласуется с локальными списками для <em>C</em> и его
суперклассов.
<!--l. 6379--><p class="indent" >   Класс имеет приоритет перед его прямыми суперклассами, и прямой
суперкласс стоит перед всеми другими прямыми суперклассами указанными
правее в форме <b><a 
href="symbols.html#x190-382310r310">defclass</a></b>. Для любого класса <em>C</em>, истинно определение
<span class="math">
                  R<sub>C</sub> = {(C,C<sub>1</sub>), (C<sub>1</sub>,C<sub>2</sub>),…, (C<sub>n−1</sub>,C<sub>n</sub>)}
</span> , где <span class="math">C<sub>1</sub>,…,C<sub>n</sub></span> — прямые суперклассы для <em>C</em> в порядке, в котором они
перечислены в форме <b><a 
href="symbols.html#x190-382310r310">defclass</a></b>. Данные упорядоченные пары образуют
упорядоченный список из класса <em>C</em> и его прямых суперклассов.
<!--l. 6389--><p class="indent" >   Пусть <span class="math">S<sub>C</sub></span> является множеством из <em>C</em> и его суперклассов. Пусть <em>R</em>
является
<span class="math">
                                                                          

                                                                          
                             R = ⋃
  <sub>c ∈ S<sub>
C</sub></sub>R<sub>c</sub>
</span>
<!--l. 6393--><p class="indent" >   Множество <em>R</em> может образовывать или не образовывать частичное
упорядочение, в зависимости от того, согласованы ли <span class="math">R<sub>c</sub></span>, <span class="math">c ∈ S<sub>C</sub></span>.
Предполагается, что они согласованы, и что <em>R</em> образовывает частичное
упорядочение. Когда <span class="math">R<sub>c</sub></span> не согласовано, говориться, что <em>R</em> несогласовано.
FIXME
<!--l. 6399--><p class="indent" >   Для вычисления списка приоритетности классов для класса <em>C</em>,
необходимо топологически отсортировать элементы множества <span class="math">S<sub>C</sub></span> по
отношению к частичному упорядочению, созданному с помощью <em>R</em>. Когда
топологическая сортировка должна выбрать класс из множества из
двух или более классов, и в соответствие с множеством <em>R</em> ни один не
приоритетнее другого , класс выбирается детерминированно так, как
описано ниже. Если множество <em>R</em> не согласовано, сигнализируется
ошибка.
<!--l. 6407--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-26800028.1.5" id="x177-26800028.1.5">Топологическая сортировка</a></h5>
<!--l. 6410--><p class="noindent" ><a 
href="http://ru.wikipedia.org/wiki/\protect \T2A\CYRT \protect \T2A\cyro \protect \T2A\cyrp \protect \T2A\cyro \protect \T2A\cyrl \protect \T2A\cyro \protect \T2A\cyrg \protect \T2A\cyri \protect \T2A\cyrch \protect \T2A\cyre \protect \T2A\cyrs \protect \T2A\cyrk \protect \T2A\cyra \protect \T2A\cyrya _\protect \T2A\cyrs \protect \T2A\cyro \protect \T2A\cyrr \protect \T2A\cyrt \protect \T2A\cyri \protect \T2A\cyrr \protect \T2A\cyro \protect \T2A\cyrv \protect \T2A\cyrk \protect \T2A\cyra " >Топологическая сортировка</a>
<!--l. 6412--><p class="indent" >   Топологическая сортировка осуществляет поиск такого класса <em>C</em> в <span class="math">S<sub>c</sub></span>,
если в соответствии с элементами <em>R</em> никакой другой класс не предшествует
данному. Класс <em>C</em> размещается в самом начале результирующего списка.
Удаляется <em>C</em> из <span class="math">C<sub>c</sub></span> и удаляются все пары вида <span class="math">(C,D)</span>, <span class="math">D ∈ S<sub>C</sub></span> из <em>R</em>.
Процесс повторяется, в конец результирующего списка добавляются
классы без предшествующих классов. Остановка происходит, когда
элементов, у которых нет предшествующих элементов, больше не
осталось.
<!--l. 6420--><p class="indent" >   Если множество <span class="math">S<sub>C</sub></span> не пустое и процесс сортировка завершился,
множество <em>R</em> является несолгасованным. Если каждый класс в конечном
множестве классов имеет предшествующие классы, тогда <em>R</em> содержит
циклическую структуру. Это значит, что существует такая цепочка классов
<span class="math">C<sub>1</sub>,…,C<sub>n</sub></span>, что <span class="math">C<sub>i</sub></span> имеет предшествующий <span class="math">C<sub>i+1</sub></span>, <span class="math">1 ≤ i &#x003C; n</span>, и <span class="math">C<sub>n</sub></span> предшествует
<span class="math">C<sub>1</sub></span>.
<!--l. 6427--><p class="indent" >   Иногда случается так, что в <span class="math">S<sub>C</sub></span> есть несколько классов без
                                                                          

                                                                          
предшественников. В этом случае выбирается один, который имеет прямой
подкласс, стоящий наиболее правее в вычисленном списке предшествующих
классов. Если такого класса нет, <em>R</em> не образовывает частичное упорядочение
— <span class="math">R<sub>c</sub></span>, <span class="math">c ∈ S<sub>C</sub></span> не согласованы.
<!--l. 6433--><p class="indent" >   Более подробно, пусть <span class="math">{N<sub>1</sub>,…,N<sub>m</sub>}</span>, <span class="math">m ≥ 2</span> будут классами из <span class="math">S<sub>C</sub></span> без
предшественников. Пусть <span class="math">(C<sub>1</sub>…C<sub>n</sub>)</span>, <span class="math">n ≥ 1</span>, будут вычисленным списком
приоритетности классов. <span class="math">C<sub>1</sub></span> — наиболее специфичный класс, и <span class="math">C<sub>n</sub></span> —
наименее специфичный. Пусть <span class="math">1 ≤ j ≤ n</span> будет наибольшим числом таким,
что существует <em>i</em>, где <span class="math">1 ≤ i ≤ m</span> и <span class="math">N<sub>i</sub></span> является прямым суперклассом <span class="math">C<sub>j</sub></span>, <span class="math">N<sub>i</sub></span>
находится рядом.
<!--l. 6440--><p class="indent" >   Результат этого правила выбора из множества класса без предшественников
заключается в том, что классы в простой цепочке суперклассов являются
смежными в списке приоритетности классов, и эти классы в каждом
относительно раздельном подграфе являются смежными в списке
приоритетности классов. Например, пусть <span class="math">T<sub>1</sub></span> и <span class="math">T<sub>2</sub></span> будут подграфами, у
которого общим элементом является только <em>J</em>. Предположим, что для <em>J</em> не
ни одного суперкласса ни в <span class="math">T<sub>1</sub></span>, ни в <span class="math">T<sub>2</sub></span>. Пусть <span class="math">C<sub>1</sub></span> будет нижней частью
<span class="math">T<sub>1</sub></span> и <span class="math">C<sub>2</sub></span> — нижней частью <span class="math">T<sub>2</sub></span>. Предположим <em>C</em> является классом, у
которого прямые суперклассы <span class="math">C<sub>1</sub></span> и <span class="math">C<sub>2</sub></span> вот в этом порядке. Тогда список
приоритетности класса для <em>C</em> будет начинаться с <em>C</em> и продолжаться всеми
классами из <span class="math">T<sub>1</sub></span> за исключением <em>J</em>. Следующими будут классы из <span class="math">T<sub>2</sub></span>. Класс <em>J</em>
и его суперклассы будут последними.
<!--l. 6453--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-26900028.1.5" id="x177-26900028.1.5">Примеры</a></h5>
<!--l. 6455--><p class="noindent" >Данный пример устанавливает список родительских классов для класса <b>pie</b>.
Классы определены следующим образом:
<div class="lisp">
<tt>
<!--l. 6458--><p class="indent" >   <div class="tabbing">
(defclass pie (apple cinnamon) ())
   <br>            (defclass apple (fruit) ())<br>            (defclass cinnamon (spice) ())<br>
(defclass fruit (food) ())<br>                           (defclass spice (food) ())<br>
(defclass food () ())<br>
                                                                          

                                                                          
<!--l. 6465--><p class="noindent" ></div>
</tt>
</div>
<div class="flushleft" 
>
<!--l. 6467--><p class="noindent" >
<!--l. 6469--><p class="noindent" >Множество S={<b>pie</b>, <b>apple</b>, <b>cinnamon</b>, <b>fruit</b>, <b>spice</b>, <b>food</b>,
<b>standard-object</b>, <b><a 
href="symbols.html#x190-382951r951">t</a></b>}. Множество R={(<b>pie</b>, <b>apple</b>), (<b>apple</b>, <b>cinnamon</b>),
(<b>cinnamon</b>, <b>standard-object</b>), (<b>apple</b>, <b>fruit</b>), (<b>fruit</b>,
<b>standard-object</b>), (<b>cinnamon</b>, <b>spice</b>), (<b>spice</b>, <b>standard-object</b>),
(<b>fruit</b>, <b>food</b>), (<b>food</b>, <b>standard-object</b>), (<b>spice</b>, <b>food</b>),
(<b>standard-object</b>, <b><a 
href="symbols.html#x190-382951r951">t</a></b>)}.
<!--l. 6502--><p class="noindent" >Класс <b>pie</b> не имеет предшественников, поэтому он идёт первым.
Результат пока что просто <b>(pie)</b>. Происходит удаление <b>pie</b> из <em>S</em> и пар,
содержащих <b>pie</b>, из <em>R</em>. Получается: S={<b>apple</b>, <b>cinnamon</b>, <b>fruit</b>, <b>spice</b>,
<b>food</b>, <b>standard-object</b>, <b><a 
href="symbols.html#x190-382951r951">t</a></b>} and R={ (<b>apple</b>, <b>cinnamon</b>), (<b>cinnamon</b>,
<b>standard-object</b>), (<b>apple</b>, <b>fruit</b>), (<b>fruit</b>, <b>standard-object</b>),
(<b>cinnamon</b>, <b>spice</b>), (<b>spice</b>, <b>standard-object</b>), (<b>fruit</b>, <b>food</b>), (<b>food</b>,
<b>standard-object</b>), (<b>spice</b>, <b>food</b>), (<b>standard-object</b>, <b><a 
href="symbols.html#x190-382951r951">t</a></b>)}.
<!--l. 6533--><p class="noindent" >Класс <b>apple</b> не имеет предшественников, поэтому он следующий.
Результат теперь <b>(pie apple)</b>. Происходит удаление <b>apple</b> из <em>S</em> и пар,
содержащих <b>pie</b>, из <em>R</em>. Получается: S={<b>cinnamon</b>, <b>fruit</b>, <b>spice</b>, <b>food</b>,
<b>standard-object</b>, <b><a 
href="symbols.html#x190-382951r951">t</a></b>} and R={(<b>cinnamon</b>, <b>standard-object</b>), (<b>fruit</b>,
<b>standard-object</b>), (<b>cinnamon</b>, <b>spice</b>), (<b>spice</b>, <b>standard-object</b>),
(<b>fruit</b>, <b>food</b>), (<b>food</b>, <b>standard-object</b>), (<b>spice</b>, <b>food</b>),
(<b>standard-object</b>, <b><a 
href="symbols.html#x190-382951r951">t</a></b>)}.
<!--l. 6558--><p class="noindent" >Классы <b>cinnamon</b> и <b>fruit</b> не имеют предшественников, поэтому
следующим будет тот, у которого прямые подклассы в вычисленном
списке приоритетности классов стоят правее. Класс <b>apple</b> прямой
подкласс <b>fruit</b>, и класс <b>pie</b> прямой подкласс <b>cinnamon</b>. Так как <b>apple</b>
стоит правее чем <b>pie</b> в списке приоритетности, следующим становиться
<b>fruit</b> и результат выглядит <b>(pie apple fruit)</b>. S={<b>cinnamon</b>, <b>spice</b>,
<b>food</b>, <b>standard-object</b>, <b><a 
href="symbols.html#x190-382951r951">t</a></b>}; R={(<b>cinnamon</b>, <b>standard-object</b>),
(<b>cinnamon</b>, <b>spice</b>), (<b>spice</b>, <b>standard-object</b>), (<b>food</b>,
<b>standard-object</b>), (<b>spice</b>, <b>food</b>), (<b>standard-object</b>, <b><a 
href="symbols.html#x190-382951r951">t</a></b>)}.
<!--l. 6581--><p class="noindent" >Класс <b>cinnamon</b> следующий, и результат получается <b>(pie apple fruit
                                                                          

                                                                          
cinnamon)</b>. В данный момент: S={<b>spice</b>, <b>food</b>, <b>standard-object</b>, <b><a 
href="symbols.html#x190-382951r951">t</a></b>};
R={(<b>spice</b>, <b>standard-object</b>), (<b>food</b>, <b>standard-object</b>), (<b>spice</b>, <b>food</b>),
(<b>standard-object</b>, <b><a 
href="symbols.html#x190-382951r951">t</a></b>)}.</div>
<!--l. 6596--><p class="indent" >   Затем добавляются классы <b>spice</b>, <b>food</b>, <b>standard-object</b> и <b><a 
href="symbols.html#x190-382951r951">t</a></b> в таком же
порядке. Результат списка приоритетности классов для <b>pie</b> является
<div class="lisp"><tt><div class="tabbing">
(pie apple fruit cinnamon spice food standard-object t)
   <br>
<!--l. 6601--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6603--><p class="indent" >   Можно записать множество определений классов, которые не могут быть
упорядочены. Например: <div class="lisp"><tt><div class="tabbing">
(defclass new-class (fruit apple) ())
   <br>                                                              (defclass apple (fruit) ())<br>
<!--l. 6608--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6610--><p class="indent" >   Класс <b>fruit</b> должен быть приоритетнее <b>apple</b>, так как должен
быть сохранён локальный порядок приоритетности суперклассов.
Класс <b>apple</b> должен быть приоритетным <b>fruit</b>, так как класс всегда
стоит перед его суперклассами. При возникновении данной ситуации
при вычислении списка приоритетности классов, сигнализируется
ошибка.
<!--l. 6616--><p class="indent" >   Следующий набор определений классов может показаться противоречивым:
<div class="lisp"><tt><div class="tabbing">
(defclass pie (apple cinnamon) ())
   <br>          (defclass pastry (cinnamon apple) ())<br>          (defclass apple () ())<br>
(defclass cinnamon () ())<br>
                                                                          

                                                                          
<!--l. 6622--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6624--><p class="indent" >   Список приоритетности классов для <b>pie</b> <div class="lisp"><tt><div class="tabbing">
(pie apple cinnamon standard-object t)
   <br>
<!--l. 6627--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6629--><p class="indent" >   Список приоритетности классов для <b>pastry</b> <div class="lisp"><tt><div class="tabbing">
(pastry cinnamon apple standard-object t)
   <br>
<!--l. 6632--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6634--><p class="indent" >   В упорядочении суперклассов для <b>pie</b> <b>apple</b> может быть приоритетнее
<b>cinnamon</b>, но в упорядочении <b>pastry</b> это невозможно. Так или иначе,
создать новый класс, у которого два суперкласса <b>pie</b> и <b>pastry</b>, невозможно.
<!--l. 6639--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.6   </span> <a 
href="frontmatter.html#QQ2-177-313" id="x177-27000028.1.6">Обобщённые функции и методы</a></h4>
<em>
<!--l. 6641--><p class="noindent" >Обобщённая функция</em> — это функция, поведение которой зависит от
передаваемых аргументов. <em>Методы</em> определяют поведение и операции этой
функции для конкретных классов аргументов. Следующий раздел описывает
обобщённые функции и методы.
                                                                          

                                                                          
<!--l. 6645--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-27100028.1.6" id="x177-27100028.1.6">Введение в обобщённые функции</a></h5>
<!--l. 6647--><p class="noindent" >Объект обобщённой функции содержит множество методов, лямбда-список,
тип сочетания методов и другую информацию.
<!--l. 6650--><p class="indent" >   Как и обычная Lisp&#x2019;овая функция, обобщённая функция принимает
аргументы, выполняет последовательность операций, и, возможно,
возвращает полезные значения. Обычная функция имеет одно тело с кодом,
которое выполняется во всех случаях вызова функции. Обобщённая функция
имеет множество тел с кодом, и при вызове для исполнения из данного
множества выделяется подмножество. Выбранное подмножество и порядок
этих тел устанавливается с помощью класса(ов) одного или нескольких
переданных аргументов и типа сочетания методов.
<!--l. 6658--><p class="indent" >   Синтаксис вызова обычной и обобщённой функции одинаков.
<!--l. 6660--><p class="indent" >   Обобщённые функции являются обычными функциями. Их можно
передать в качестве аргументов, вернуть в качестве результата, и
использовать первым аргументом в <b><a 
href="symbols.html#x190-382444r444">funcall</a></b> и <b><a 
href="symbols.html#x190-382101r101">apply</a></b>, и вообще везде, где
можно использовать обычные функции.
<!--l. 6665--><p class="indent" >   Макрос <b><a 
href="symbols.html#x190-382452r452">generic-function</a></b> создаёт анонимную обобщённую функцию со
множеством методов, указанных в форме <b><a 
href="symbols.html#x190-382452r452">generic-function</a></b>.
<!--l. 6668--><p class="indent" >   При вычислении формы <b><a 
href="symbols.html#x190-382312r312">defgeneric</a></b> происходит одно из трёх действий:
      <ul class="itemize1">
      <li class="itemize">Если обобщённая функция с данным именем уже существует, тогда
      модифицируется  её  объект.  Методы  указанные  в  новой  форме
      <b><a 
href="symbols.html#x190-382312r312">defgeneric</a></b> добавляются,  а  методы  созданные  ранее  с  помощью
      старой  формы  <b><a 
href="symbols.html#x190-382312r312">defgeneric</a></b>  удаляются.  Методы  добавленные  из
      новой формы <b><a 
href="symbols.html#x190-382312r312">defgeneric</a></b> могут заменять методы определённые с
      помощью  <b><a 
href="symbols.html#x190-382321r321">defmethod</a></b> или  <b><a 
href="symbols.html#x190-382310r310">defclass</a></b>.  Другие  методы  для  данной
      обобщённой функции не меняются и не удаляются.
      </li>
      <li class="itemize">Если данное имя определяет необобщённую функцию, макрос или
      специальный оператор, тогда сигнализируется ошибка.
      </li>
      <li class="itemize">В противном случае создаётся обобщённая функция с методами
      указанными в данной форме <b><a 
href="symbols.html#x190-382312r312">defgeneric</a></b>.</li></ul>
                                                                          

                                                                          
<!--l. 6685--><p class="indent" >   Некоторые формы содержат параметры обобщённой функции, такие как
тип сочетания методов или порядок приоритета аргументов. Они будут
называться, как «формы, которые указывают параметры обобщённой
функции». Это формы: <b><a 
href="symbols.html#x190-382312r312">defgeneric</a></b>, <b><a 
href="symbols.html#x190-382452r452">generic-function</a></b>.
<!--l. 6690--><p class="indent" >   Некоторые формы определяют методы для обобщённой функции. Они
называются «формы определяющие методы». Это формы: <b><a 
href="symbols.html#x190-382312r312">defgeneric</a></b>,
<b><a 
href="symbols.html#x190-382321r321">defmethod</a></b>, <b><a 
href="symbols.html#x190-382452r452">generic-function</a></b> и <b><a 
href="symbols.html#x190-382310r310">defclass</a></b>. Следует отметить, что все эти
формы за исключением <b><a 
href="symbols.html#x190-382310r310">defclass</a></b> и <b><a 
href="symbols.html#x190-382321r321">defmethod</a></b> также определяют параметры
обобщённой функции.
<!--l. 6696--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-27200028.1.6" id="x177-27200028.1.6">Введение в методы</a></h5>
<!--l. 6699--><p class="noindent" >Объект метода содержит функцию метода, последовательность
<em>специализаторов параметров</em>, который указывают для чего применим
данный метод, лямбда-список и последовательность <em>квалификаторов</em>,
которые используются для функциональности сочетания методов.
<!--l. 6704--><p class="indent" >   Объект метода не является функцией и не может быть вызван как
функция. Различные механизмы в OS принимают объект метода и вызывают
функцию этого метода, как в случае вызова обобщённой функции. В этом
случае говорится, что метод вызывается.
<!--l. 6708--><p class="indent" >   Форма, определяющая метод, содержит код, который будет выполнен,
когда аргументы обобщённой функции такие, что должен быть вызван
данный метод. Когда такая форма вычисляется, создаётся объект метода и
происходит одно из четырёх действий:
      <ul class="itemize1">
      <li class="itemize">Если  обобщённая  функция  с  данным  именем  уже  существует  и
      если  объект  метода  уже  существует,  и  этот  объект  согласуется
      с   новым   в   специализаторах   параметров   и   квалификаторах,
      существующий  объект  обобщённой  функции  модифицируется  и
      будет содержать новый объект метода. Для определения того, как
      методы согласуются между собой в специализаторах параметров и
      квалификаторах смотрите раздел <a 
href="#x177-27300028.1.6">28.1.6<!--tex4ht:ref: Agreement-on-Parameter-Specializers-and-Qualifiers-SECTION --></a>.
      </li>
      <li class="itemize">Если  обобщённая  функция  с  данным  именем  уже  существует  и
                                                                          

                                                                          
      если  не  существует  объекта  метода,  согласующегося  с  новым  в
      специализаторах  параметров  и  квалификаторах,  существующий
      объект обобщённой функции модифицируется и будет содержать
      новый объект метода.
      </li>
      <li class="itemize">Если данное имя указывает на необобщённую функцию, макрос
      или специальный оператор, сигнализируется ошибка.
      </li>
      <li class="itemize">В противном случае создаётся обобщённая функция с методами
      указанными в форме.</li></ul>
<!--l. 6732--><p class="indent" >   Если лямбда-список нового метода не соответствует лямбда-списку
обобщённой функции, сигнализируется ошибка. Если форма, определяющая
метод и которая не может задавать параметры обобщённой функции, создаёт
новую обобщённую функцию, лямбда-список для этой обобщённой функции
будет производным от и согласованным с лямбда-списком формы, которая
определила метод. Для детального описания <em>согласованности</em>, смотрите
раздел <a 
href="#x177-27400028.1.6">28.1.6<!--tex4ht:ref: Congruent-Lambda-Lists-for-All-Methods-of-a-Generic-Function-SECTION --></a>.
<!--l. 6740--><p class="indent" >   Каждый метод имеет <em>специализированный лямбда-список</em>, который
устанавливает, в каких случаях данный метод может быть применён.
Специализированный лямбда-список похож на обычный, однако содержит
<em>специализированные параметры</em>, которые могут быть использованы на месте
обычных обязательных параметров. Специализированный параметр
является списком <b><em>(variable-name parameter-specializer-name)</em></b>, где
<em>parameter-specializer-name</em> является или именем класса, или списком <b>(<b><a 
href="symbols.html#x190-382379r379">eql</a></b>
<em>form</em>)</b>. Имя специализатора параметра означает следующее:
      <ul class="itemize1">
      <li class="itemize">Имя, которое указывает на класс означает класс.
      </li>
      <li class="itemize">Список <b>(<b><a 
href="symbols.html#x190-382379r379">eql</a></b> <em>form</em>)</b> обозначает спецификатор типа <b>(<b><a 
href="symbols.html#x190-382379r379">eql</a></b> <em>object</em>)</b>,
      где объект т<em>object</em> является результатом вычисления формы <em>form</em>.
      Форма  <em>form</em>  вычисляется  в  лексическом  окружении,  в  котором
      вычислялась форма, определяющая метод. Следует отметить, что
      форма <em>form</em> вычисляется только единожды во время определения
      метода, а не каждый раз при вызове обобщённой функции.</li></ul>
                                                                          

                                                                          
<!--l. 6761--><p class="indent" >   Имена специализаторов параметров используются в макросах,
предназначенных для пользовательского интерфейса (<b><a 
href="symbols.html#x190-382321r321">defmethod</a></b>), тогда
как специализаторы параметров используются в функциональном
интерфейсе.
<!--l. 6765--><p class="indent" >   [It is very important to understand clearly the distinction made in the
preceding paragraph. A parameter specializer name has the form of a type
speciﬁer but is semantically quite diﬀerent from a type speciﬁer: a parameter
specializer name of the form <b>(<b><a 
href="symbols.html#x190-382379r379">eql</a></b> <em>form</em>)</b> is not a type speciﬁer, for it contains a
<em>form</em> to be evaluated. Type speciﬁers never contain forms to be evaluated.
All parameter specializers (as opposed to parameter specializer names)
are valid type speciﬁers, but not all type speciﬁers are valid parameter
specializers. Macros such as <b><a 
href="symbols.html#x190-382321r321">defmethod</a></b> take parameter specializer names
and treat them as speciﬁcations for constructing certain type speciﬁers
(parameter specializers) that may then be used with such functions as
<b><a 
href="symbols.html#x190-382418r418">ﬁnd-method</a></b>.—GLS]
<!--l. 6778--><p class="indent" >   Только обязательные параметры могут быть специализированы, и
наоборот специализатор параметра может быть только для обязательного
параметра. Для упрощения записи, если некоторый обязательный параметр в
специализированном лямбда-списке в форме, определяющей метод, является
просто именем переменной, то специализатор параметра по-умолчанию
указывает на класс с именем <b><a 
href="symbols.html#x190-382951r951">t</a></b>.
<!--l. 6784--><p class="indent" >   В рамках заданной обобщённой функции и списка аргументов,
<em>применимый метод</em> — это метод для данной функции, у которого
специализаторы параметров удовлетворяют соответствующим аргументам.
Следующее определение разъясняет, что имеется ввиду под применимым
методом и под аргументом, удовлетворяющим специализатору параметра.
<!--l. 6790--><p class="indent" >   Пусть <span class="math">⟨A<sub>1</sub>,…,A<sub>n</sub>⟩</span> будут обязательными аргументами обобщённой
функции. Пусть <span class="math">⟨P<sub>1</sub>,…,P<sub>n</sub>⟩</span> будут специализаторами параметров,
соответствующие обязательным параметрам метода <em>M</em>. Метод <em>M</em> является
<em>применимым</em>, когда <span class="math">A<sub>i</sub></span> <em>удовлетворяет</em> <span class="math">P<sub>i</sub></span>. Если <span class="math">P<sub>i</sub></span> является классом, и
если <span class="math">A<sub>i</sub></span> является экземпляром класса <em>C</em>, тогда говорится, что <span class="math">A<sub>i</sub></span>
<em>удовлетворяет</em> <span class="math">P<sub>i</sub></span>, когда <span class="math">C = P<sub>i</sub></span> или когда <em>C</em> является подклассом
<span class="math">P<sub>i</sub></span>. Если <span class="math">P<sub>i</sub></span> является формой <b>(<b><a 
href="symbols.html#x190-382379r379">eql</a></b> <em>object</em>)</b>, тогда говорится, что <span class="math">A<sub>i</sub></span>
<em>удовлетворяет</em> <span class="math">P<sub>i</sub></span>, когда функция <b><a 
href="symbols.html#x190-382379r379">eql</a></b> применённая к <span class="math">A<sub>i</sub></span> и <em>object</em>
истинна.
<!--l. 6801--><p class="indent" >   Так как специализатор параметра является спецификатором типа, во
время выбора метода для определения того, удовлетворяют ли аргумента
спецификатору параметра может использоваться функция <b><a 
href="symbols.html#x190-382976r976">typep</a></b>.
                                                                          

                                                                          
Специализатор параметра не может быть списком спецификатора
типа, таким как <b>(<b>vector single-ﬂoat</b>)</b>. Специализатор параметра
может быть только таким списком как <b>(<b><a 
href="symbols.html#x190-382379r379">eql</a></b> <em>object</em>)</b>. Common Lisp
определяет спецификатор типа <b><a 
href="symbols.html#x190-382379r379">eql</a></b>, как если бы было выполнено следующее
выражение:
<div class="lisp">
<tt>
<!--l. 6809--><p class="indent" >   <div class="tabbing">
(deftype eql (<em>object</em>) ‘(member ,<em>object</em>))
   <br>
<!--l. 6811--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6812--><p class="indent" >   [Смотрите раздел  <a 
href="clmse20.html#x29-450004.3">4.3<!--tex4ht:ref: PREDICATING-TYPE-SPECIFIERS-SECTION --></a>.—GLS]
<!--l. 6814--><p class="indent" >   Метод, у которого все специализаторы параметров являются классами <b><a 
href="symbols.html#x190-382951r951">t</a></b>,
называется <em>метод по-умолчанию</em>. Такое метод применим всегда, но может
быть скрыт с помощью более специализированного метода.
<!--l. 6818--><p class="indent" >   Методы могут иметь <em>квалификаторы</em>, которые указывают процедуре
сочетания методов способ вызова методов. Метод, который имеет один или
более квалификатор, называется <em>квалифицированным</em> методом. Метод
без квалификаторов называется <em>неквалифицированным методом</em>.
Квалификатором является любой объект, кроме списка, т.е. любой
не-<b><a 
href="symbols.html#x190-382670r670">nil</a></b> атом. Квалификаторы, определённые с помощью стандартного
сочетания методов и системного типа сочетания методов, являются
символами.
<!--l. 6826--><p class="indent" >   В данной спецификации, термины <em>главный метод</em> и <em>вспомогательный
метод</em> используются для разделения методов по типу сочетания. В стандартном
типе сочетания методов, главные методы это неквалифицированные методы,
и вспомогательные методы это методы с одним из квалификаторов <b>:around</b>,
<b>:before</b> или <b>:after</b>. Когда определяется тип сочетания методов с помощью
краткой формы <b><a 
href="symbols.html#x190-382316r316">deﬁne-method-combination</a></b>, главные методы это те,
которые квалифицированы с помощью имени сочетания методов, и
вспомогательные методы имеют квалификатор <b>:around</b>. Таким образом
определение терминов <em>главный метод</em> и <em>вспомогательный метод</em> имеет
значение относительно текущего типу сочетания методов.
                                                                          

                                                                          
<!--l. 6837--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-27300028.1.6" id="x177-27300028.1.6">Согласованность в специализаторах параметров и квалификаторах</a></h5>
<!--l. 6840--><p class="noindent" >Два метода согласованы друг с другом в специализаторах параметров и
квалификаторах, если выполняются следующие условия:
      <ul class="itemize1">
      <li class="itemize">Оба    метода    имеют    одинаковое    количество    обязательных
      параметров.
      <!--l. 6847--><p class="noindent" >Предположим,  что  специализаторы  параметров  двух  методов
      являются <span class="math">P<sub>1,1</sub>…P<sub>1,n</sub></span> и <span class="math">P<sub>2,1</sub>…P<sub>2,n</sub></span> соответственно.
      </li>
      <li class="itemize">Для каждого <span class="math">1  ≤ i ≤ n</span>, <span class="math">P<sub>1,i</sub></span>  согласуется с <span class="math">P<sub>2,i</sub></span>. Специализатор
      параметра  <span class="math">P<sub>1,i</sub></span>  согласуется  с  <span class="math">P<sub>2,i</sub></span>,  если  <span class="math">P<sub>1,i</sub></span>  и  <span class="math">P<sub>2,i</sub></span>  являются
      одним  и  тем  же  классом  или  если  <span class="math">P<sub>1,i</sub>  =  (<b><a 
href="symbols.html#x190-382379r379">eql</a></b>object<sub>1</sub>)</span>,  <span class="math">P<sub>2,i</sub>  =
      (<b><a 
href="symbols.html#x190-382379r379">eql</a></b>object<sub>2</sub>)</span>, и <b>(<b><a 
href="symbols.html#x190-382379r379">eql</a></b> <span class="math">object<sub>1</sub></span>  <span class="math">object<sub>2</sub></span>)</b>. В противном случае <span class="math">P<sub>1,i</sub></span> и <span class="math">P<sub>2,i</sub></span>
      несогласованны.</li></ul>
<!--l. 6860--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-27400028.1.6" id="x177-27400028.1.6">Гармония лямбда-списков для всех методов обобщённой функции</a></h5>
<!--l. 6863--><p class="noindent" >Следующие правила определяют гармонию множества лямбда-списков,
включая лямбда-списки каждого метода некоторой обобщённой функции и
лямбда-список определённый для самой этой функции, если он, конечно, был
указан.
      <ul class="itemize1">
      <li class="itemize">Каждый лямбда-список должен содержать одинаковое количество
      обязательных параметров.
      </li>
      <li class="itemize">Каждый  лямбда-список  должен  иметь  одинаковое  количество
      необязательных  параметров.  Каждый  метод  может  определять
      свои значения по-умолчанию для необязательных параметров.
                                                                          

                                                                          
      </li>
      <li class="itemize">Если  какой-либо  лямбда-список  содержит  <b>&#x0026;rest</b>  или  <b>&#x0026;key</b>,
      каждый  лямбда-список  должен  содержать  один  или  оба  этих
      символа.
      </li>
      <li class="itemize">Если   лямбда-список   обобщённой   функции   содержит   <b>&#x0026;key</b>,
      каждый  метод  должен  принимать  все  именованные  параметры
      указанные  в  обобщённой  функции  или  явно,  или  с  помощью
      <b>&#x0026;allow-other-keys</b>,  или  с  помощью  указания  <b>&#x0026;rest</b>,  но  не
      <b>&#x0026;key</b>.  Каждый  метод  может  принимать  свои  дополнительные
      именованные параметры. Проверка на корректность именованный
      параметров производится в обобщённой функции, а не в каждом
      методе.  Метод  вызывается  так,  как  если  указан  именованный
      аргумент  <b>:allow-other-keys</b>  со  значением  <b>t</b>,  однако  сам  этот
      аргумент не указывается.
      </li>
      <li class="itemize">Использование <b>&#x0026;allow-other-keys</b> не обязательно согласовывать
      между лямбда-списками. Если <b>&#x0026;allow-other-keys</b> содержится в
      лямбда-списке какого-либо применимого метода или обобщённой
      функции,  в  вызове  обобщённой  функции  может  использоваться
      любые именованные параметры.
      </li>
      <li class="itemize">Использования   <b>&#x0026;aux</b>   не   обязательно   согласовывать   между
      методами.</li></ul>
<!--l. 6896--><p class="indent" >   Если форма, которая определяет метод и не может указывать параметры
обобщённой функции, создаёт обобщённую функцию, и если лямбда-список
для метода содержит именованные параметры, тогда лямбда-список
обобщённой функции будет содержать символ <b>&#x0026;key</b> (но сами параметры
содержать не будет).
<!--l. 6901--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-27500028.1.6" id="x177-27500028.1.6">Именованные параметры в обобщённых функциях и методах</a></h5>
<!--l. 6903--><p class="noindent" >Когда обобщённая функция или любой из её методов содержат в своих
лямбда-списках <b>&#x0026;key</b>, определённый набор именованный параметров,
                                                                          

                                                                          
принятых обобщённой функцией, меняется в зависимости от применяемых
методов. Набор именованных параметров, принимаемых обобщённой
функцией для отдельного вызова, является объединением всех именованных
параметров, принимаемых всеми применимыми методами, и именованных
параметров, указанных после <b>&#x0026;key</b> в определении обобщённой функции.
Метод, который содержит <b>&#x0026;rest</b>, но не содержит <b>&#x0026;key</b>, не попадает в список
применимых методов. Если лямбда-список любого применимого метода или
обобщённой функции содержит <b>&#x0026;allow-other-keys</b>, обобщённая функция
принимает все именованные параметры.
<!--l. 6914--><p class="indent" >   Правила согласования лямбда-списков требуют, чтобы каждый метод
принимал все именованные параметры, указанные после <b>&#x0026;key</b> в определении
обобщённой функции, причём делал это явно указанием <b>&#x0026;allow-other-keys</b>
или указанием <b>&#x0026;rest</b>, но не <b>&#x0026;key</b>. Каждый метод может принимать свои
дополнительные именованные параметры в дополнение к тем, которые были
в определении обобщённой функции.
<!--l. 6921--><p class="indent" >   Если в обобщённую функцию передан именованный параметр такой, что
применимого метода найдено не было, генерируется ошибка.
<!--l. 6924--><p class="indent" >   Например, определим два метода для <b>width</b>.
<div class="lisp">
<tt>
<!--l. 6926--><p class="indent" >   <div class="tabbing">
(defmethod width ((c character-class) &#x0026;key font) ...)
   <br>                                                                                               <br>
(defmethod width ((p picture-class) &#x0026;key pixel-size) ...)<br>
<!--l. 6930--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6932--><p class="indent" >   Предположим, что больше методов нет, и определения обобщённой
функции для <b>width</b> тоже нет. Вычисление следующей формы сигнализирует
ошибку, потому что именованный параметр <b>:pixel-size</b> не может быть
передан в применяемый метод.
<div class="lisp">
<tt>
<!--l. 6937--><p class="indent" >   <div class="tabbing">
                                                                          

                                                                          
(width (make-instance &#x2019;character-class :char #\Q)
   <br>                                                  :font &#x2019;baskerville :pixel-size 10)<br>
<!--l. 6940--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6942--><p class="indent" >   Вычисление следующей формы сигнализирует ошибку.
<div class="lisp">
<tt>
<!--l. 6944--><p class="indent" >   <div class="tabbing">
(width (make-instance &#x2019;picture-class :glyph (glyph #\Q))
   <br>                                                  :font &#x2019;baskerville :pixel-size 10)<br>
<!--l. 6947--><p class="noindent" ></div>
</tt>
</div>
<!--l. 6949--><p class="indent" >   Вычисление следующей формы не сигнализирует ошибку, если
класс <b>character-picture-class</b> является подклассом и <b>picture-class</b> и
<b>character-class</b>.
<div class="lisp">
<tt>
<!--l. 6952--><p class="indent" >   <div class="tabbing">
(width (make-instance &#x2019;character-picture-class :char #\Q)
   <br>                                                  :font &#x2019;baskerville :pixel-size 10)<br>
<!--l. 6955--><p class="noindent" ></div>
</tt>
</div>
                                                                          

                                                                          
<!--l. 6957--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.7   </span> <a 
href="frontmatter.html#QQ2-177-319" id="x177-27600028.1.7">Выбор и сочетание методов</a></h4>
<!--l. 6960--><p class="noindent" >Когда общая функция вызывается с конкретными аргументами, она должна
определить какой код выполнять. Этот код называется <em>действующий
(рабочий) метод</em> для этих аргументов. Действующий метод является
<em>сочетанием</em> применимых методов в обобщённой функции. Сочетание методов
— это Lisp&#x2019;овое выражение, которые содержит вызовы к некоторым или всем
методам. Если обобщённая функция вызвана и при этом методов
для применения найдено не было, вызывается обобщённая функция
<b><a 
href="symbols.html#x190-382673r673">no-applicable-method</a></b>.
<!--l. 6968--><p class="indent" >   Когда установлен действующий метод, он вызывает с теми же
аргументами, что были переданы в обобщённую функцию. Все значения
возвращённые этим методом, возвращаются из обобщённой функции.
<!--l. 6972--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-27700028.1.7" id="x177-27700028.1.7">Определение действующего метода</a></h5>
<!--l. 6975--><p class="noindent" >Действующий метод для набора аргументов устанавливается следующими
тремя шагами:
<!--l. 6977--><p class="indent" >
      <ol  class="enumerate1" >
      <li 
  class="enumerate" id="x177-277002x1">Выбор применимых методов.
      </li>
      <li 
  class="enumerate" id="x177-277004x2">Сортировка  применимых  методов  в  порядке  приоритетности,
      размещение первым наиболее специфичного метода.
      </li>
      <li 
  class="enumerate" id="x177-277006x3">Применение  процедуры  сочетания  методов  к  сортированному
      списку применимых методов, создание действующего метода.
      </li></ol>
<b>
<!--l. 6989--><p class="indent" >   Выбор применимых методов</b> Этот шаг описан в разделе <a 
href="#x177-27200028.1.6">28.1.6<!--tex4ht:ref: Introduction-to-Methods-SECTION --></a>.
<b>
<!--l. 6992--><p class="indent" >   Сортировка применимых методов в порядке приоритетности.</b> Для
сравнения того, кто из двух методов приоритетнее, по порядку исследуются
их специализаторы параметров. По-умолчанию порядок исследования слева
                                                                          

                                                                          
направо, но в параметре <b>:argument-precedence-order</b> в функции
<b><a 
href="symbols.html#x190-382312r312">defgeneric</a></b> или в любой другой форме, задающей параметры обобщённой
функции, можно изменить этот порядок.
<!--l. 6999--><p class="indent" >   Из каждого метода сравниваются специализаторы параметров. Когда
пара специализаторов параметров эквивалентна, сравнивается следующая
пара. Если все соответствующие пары эквивалентны, два метода должны
иметь разные квалификаторы. В этом случае один из двух методов может
быть приоритетнее другого.
<!--l. 7004--><p class="indent" >   Если соответствующие специализаторы параметров не эквивалентны,
первая же неэквивалентная пара определяет порядок следования методов.
Если оба специализатора параметра являются классами, наиболее
специфичным является тот метод, у которого в данном специализаторе
указан класс, который приоритетнее класса, указанному в другом
специализаторе. А так как до этого из всех методов были выбраны только
применимые, эти два класса гарантированно находятся в одном списке
приоритетности классов.
<!--l. 7012--><p class="indent" >   Если один из специализаторов выглядит <b>(<b><a 
href="symbols.html#x190-382379r379">eql</a></b> <em>object</em>)</b>, то его содержащий
метод будет приоритетнее другого метода. Если оба специализатора
являются формами <b><a 
href="symbols.html#x190-382379r379">eql</a></b>, то они должны быть одинаковыми (иначе два метода
не могли бы быть применимыми к этому аргументу).
<!--l. 7017--><p class="indent" >   Результирующий список применимых методов первым содержит наиболее
специфичный метод, и последним наименее специфичный.
<b>
<!--l. 7021--><p class="indent" >   Применение процедуры сочетания методов к отсортированному
списке применимых методов.</b>
<!--l. 7023--><p class="indent" >   В простейшем случае — если используется стандартное сочетание методов
и все применимые методы являются главными — рабочим методом
является наиболее специфичный метод. Этот метод, используя функцию
<b><a 
href="symbols.html#x190-382190r190">call-next-method</a></b>, может вызвать следующий наиболее специфичный
метод. Метод, который будет вызван функцией <b><a 
href="symbols.html#x190-382190r190">call-next-method</a></b>,
называется следующим методом. Предикат <b><a 
href="symbols.html#x190-382669r669">next-method-p</a></b> проверяет
существование следующего метода. Если вызывается <b><a 
href="symbols.html#x190-382190r190">call-next-method</a></b>,
а следующего метода нет, тогда вызывается обобщённая функция
<b><a 
href="symbols.html#x190-382674r674">no-next-method</a></b>.
<!--l. 7032--><p class="indent" >   В общем случае, рабочий метод — это некоторое сочетание применимых
методов. Она определяется Lisp&#x2019;овой формой, которая содержит вызовы к
некоторым или всем применимым методам, и возвращает значение(я),
которые будут возвращены из обобщённой функции, и опционально делает
                                                                          

                                                                          
доступными через <b><a 
href="symbols.html#x190-382190r190">call-next-method</a></b> некоторые методы. Эта Lisp&#x2019;овая
форма является телом рабочего метода. Она расширяется соответствующим
лямбда-списком для создания из него функции.
<!--l. 7040--><p class="indent" >   Роль каждого метода в рабочем методе устанавливается с помощью его
квалификаторов и специфичности. Квалификатор служит для обозначения
метода, и смысл квалификатора определяется таким образом, что это
обозначение используется этим шагом процедуры. Если применимый метод
имеет непризнанный квалификатор, этот шаг сигнализирует ошибку и не
включает этот метод в рабочий.
<!--l. 7047--><p class="indent" >   Когда используется стандартный тип сочетания методов и используются
квалифицированные методы, рабочий метод составляется так, как описано в
разделе <a 
href="#x177-27800028.1.7">28.1.7<!--tex4ht:ref: Standard-Method-Combination-SECTION --></a>.
<!--l. 7051--><p class="indent" >   Другой тип сочетания методов может быть указан с помощью параметра
<b>:method-combination</b> функции <b><a 
href="symbols.html#x190-382312r312">defgeneric</a></b> или любой другой формы,
определяющей параметры обобщённой функции. В таком случае данный шаг
процедуры может быть изменён.
<!--l. 7056--><p class="indent" >   Новые типы сочетания методов могут быть определены с помощью
макроса <b><a 
href="symbols.html#x190-382316r316">deﬁne-method-combination</a></b>.
<!--l. 7059--><p class="indent" >   Уровень метаобъектов также содержит механизм для определения новых
типов сочетаний методов. Обобщённая функция <b><a 
href="symbols.html#x190-382275r275">compute-eﬀective-method</a></b>
принимает в качестве аргументов: обобщённую функцию, объект сочетания
методов, и отсортированный список применимых методов. Она
возвращает Lisp&#x2019;овую форму, которая определяет рабочий метод. Метод
для <b><a 
href="symbols.html#x190-382275r275">compute-eﬀective-method</a></b> может быть определён напрямую
с использованием <b><a 
href="symbols.html#x190-382321r321">defmethod</a></b> или не напрямую с использованием
<b><a 
href="symbols.html#x190-382316r316">deﬁne-method-combination</a></b>. <em>Объект сочетания методов</em> — это объект,
который инкапсулирует тип сочетания методов и параметры указанные в
параметре <b>:method-combination</b> в формах, которые указывают параметры
для обобщённых функций.
_______________________________________________<div class="implementation">
<!--l. 7072--><p class="noindent" ><b>Заметка для реализации:</b>
<!--l. 7074--><p class="indent" >    В простейших реализациях, обобщённые функции будут вычислять рабочий
метод при каждом вызове. На практике это будет неэффективной стратегией.
Вместо этого эти реализации могут использовать ряд оптимизация данных шагов.
Некоторые примеры таких оптимизаций:
        <ul class="itemize1">
                                                                          

                                                                          
      <li class="itemize">Использование  хеш-таблицы  с  ключами:  классами  аргументов,  для
      сохранения рабочих методов.
      </li>
      <li class="itemize">Компиляция рабочего метода и сохранения результирующей функции в
      таблице.
      </li>
      <li class="itemize">Распознавание Lisp&#x2019;овой формы, как экземпляра шаблона управляющей
      структуры и замещение на замыкание, которое реализует эту структуру.
      </li>
      <li class="itemize">Исследование                     специализаторов                     параметров
      всех методов для обобщённой функции и перечисление всех возможных
      рабочих методов. Сочетание рабочих методов вместе с кодом для выбора
      среди них в одну функцию, и компиляция этой функции. Вызов этой
      функции всегда, когда вызывается обобщённая функция.</li></ul>
</div>
__________________________________________________________________________
<!--l. 7097--><p class="noindent" >
     <h5 class="subsubsectionHead"><a 
href="#x177-27800028.1.7" id="x177-27800028.1.7">Стандартное сочетание методов</a></h5>
<!--l. 7100--><p class="noindent" >Стандартное сочетание методов поддерживается классом
<b>standard-generic-function</b>. Оно используется, если не указаны другие типы
сочетаний методов или если указан встроенный <b>standard</b> тип сочетания
методов.
<em>
<!--l. 7105--><p class="indent" >     Главные методы</em> определяют главное действие рабочего метода, тогда как
<em>вспомогательные методы</em> изменяют это действие одним из трёх способов.
Главные методы не имеют квалификаторов.
<!--l. 7109--><p class="indent" >     Вспомогательный метод — это метод, у которого квалификатор
является <b>:before</b>, <b>:after</b> или <b>:around</b>. Стандартное сочетание методов
позволяет использовать максимум один квалификатор для метода, в
случае использования более одного квалификатора, сигнализируется
ошибка.
        <ul class="itemize1">
        <li class="itemize">Квалификатор   <b>:before</b>  метода   задаётся   ключевым   символом
        <b>:before</b>. <b>:before</b> метод запускается перед любым главным методом.
                                                                          

                                                                          
      </li>
      <li class="itemize">Квалификатор <b>:after</b> метода задаётся ключевым символом <b>:after</b>.
      <b>:after</b> метод запускается после главных методов.
      </li>
      <li class="itemize">Квалификатор  <b>:around</b>  метода  задаётся  ключевым  символом
      <b>:around</b>. <b>:around</b> метод запускается вместо других применимых
      методов, но также возможно запустить некоторые из них.</li></ul>
<!--l. 7130--><p class="indent" >   Семантика стандартного сочетания методов:
<!--l. 7132--><p class="indent" >   <hr class="figure"><div class="figure" 
>
                                                                          

                                                                          
<a 
 id="x177-2780011"></a>
                                                                          

                                                                          
<br /> <div class="caption" 
><span class="id">Изображение 28.1: </span><span  
class="content">Common Lisp Standard Method Invocation by Rainer
Joswig</span></div><!--tex4ht:label?: x177-2780011 -->
<!--l. 7135--><p class="noindent" ><img 
src="clos1.png" alt="PIC"  
>
                                                                          

                                                                          
<!--l. 7137--><p class="indent" >   </div><hr class="endfigure">
      <ul class="itemize1">
      <li class="itemize">Если присутствуют какие-либо <b>:around</b> методы, из них вызывается
      наиболее  специфичный.  Данный  метод  возвращает  значение(я),
      которые возвращаются из обобщённой функции.
      </li>
      <li class="itemize">Внутри тела <b>:around</b> метода для вызова следующего метода может
      использоваться  функция  <b><a 
href="symbols.html#x190-382190r190">call-next-method</a></b>.  Когда  следующий
      метод возвращает управление, <b>:around</b> метод может продолжить
      своё   выполнение,   в   том   числе   на   основании   возвращённых
      значений.    В    случае    использования    <b><a 
href="symbols.html#x190-382190r190">call-next-method</a></b>    и
      отсутствия следующего метода, вызывается обобщённая функция
      <b><a 
href="symbols.html#x190-382674r674">no-next-method</a></b>.  Для  определения  существует  ли  следующий
      метод может использоваться функция <b><a 
href="symbols.html#x190-382669r669">next-method-p</a></b>.
      </li>
      <li class="itemize">Если <b>:around</b> метод вызывает <b><a 
href="symbols.html#x190-382190r190">call-next-method</a></b>, то вызывается
      следующий  наиболее  специфичный  <b>:around</b> применимый  метод.
      Если  <b>:around</b>  методов  нет,  или  если  <b><a 
href="symbols.html#x190-382190r190">call-next-method</a></b>  была
      вызвана  в  последнем  <b>:around</b>  методе,  то  следующие  методы
      вызываются так, как описано ниже:
           <ul class="itemize2">
           <li class="itemize">Вызывается  все  <b>:before</b>  методы  по  порядку  от  наиболее
           специфичного   к   наименее.   Их   значения   игнорируются.
           Если   <b><a 
href="symbols.html#x190-382190r190">call-next-method</a></b>  используется   в   <b>:before</b>  методе,
           сигнализируется ошибка.
           </li>
           <li class="itemize">Вызывается наиболее специфичный главный метод. Внутри
           тела главного метода для вызова следующего специфичного
           главного  может  использоваться  <b><a 
href="symbols.html#x190-382190r190">call-next-method</a></b>.  Когда
           этот  метод  возвращает  управление,  предыдущий  главный
           метод   может   продолжить   выполнение   некоторого   кода,
           возможно  основываясь  на  результате  вызванного  метода.
           Если была вызвана <b><a 
href="symbols.html#x190-382190r190">call-next-method</a></b>, а применимых главных
           методов   больше   нет,   вызывается   обобщённая   функция
                                                                          

                                                                          
           <b><a 
href="symbols.html#x190-382674r674">no-next-method</a></b>.  Для  проверки  существует  ли  следующий
           метод может использоваться <b><a 
href="symbols.html#x190-382669r669">next-method-p</a></b>. Если функция
           <b><a 
href="symbols.html#x190-382190r190">call-next-method</a></b> не  использовалась,  вызван  будет  только
           один наиболее специфичный главный метод.
           </li>
           <li class="itemize">Вызываются   все   <b>:after</b>  методы   в   порядке   от   наименее
           к   наиболее   специфичному.   Их   значения   игнорируются.
           Если   <b><a 
href="symbols.html#x190-382190r190">call-next-method</a></b>   используется   в   <b>:after</b>   методе,
           сигнализируется ошибка.</li></ul>
      </li>
      <li class="itemize">Если <b>:around</b> методы не вызывались, из обобщённой функции
      возвращаются значение(я), полученные от наиболее специфичного
      главного метода. Значение(я) полученные от вызова <b>call-next-method</b>
      в наименее специфичном <b>:around</b> методе являются теми значениями,
      которые вернул наиболее специфичный метод.</li></ul>
<!--l. 7188--><p class="indent" >   В стандартном сочетании методов если есть применимый метод, но он не
является главным, сигнализируется ошибка.
<b>
<!--l. 7191--><p class="indent" >   :before</b> методы запускаются в порядке от наиболее к наименее
специфичному и <b>:after</b> методы запускаются в порядке от наименее к
наиболее специфичному. Обоснование данного механизма может быть
показан в следующем примере. Предположим класс <span class="math">C<sub>1</sub></span> изменяет поведение
своего суперкласса <span class="math">C<sub>2</sub></span> добавлением <b>:before</b> и <b>:after</b> методов. Определено ли
поведение класса <span class="math">C<sub>2</sub></span> напрямую методами для <span class="math">C<sub>2</sub></span> или унаследовано от его
суперклассов не влияет на относительные вызовы методов для экземпляра
класса <span class="math">C<sub>1</sub></span>. <b>:before</b> метод класса <span class="math">C<sub>1</sub></span> вызывается перед всем методами класса
<span class="math">C<sub>2</sub></span>. <b>:after</b> метод класса <span class="math">C<sub>1</sub></span> вызывается после всех методов класса
<span class="math">C<sub>2</sub></span>.
<!--l. 7202--><p class="indent" >   Методы <b>:around</b> вызываются перед тем, как будет вызван любой другой
метод. Таким образом наименее специфичный <b>:around</b> метод вызывается
перед наиболее специфичным главным методом.
<!--l. 7206--><p class="indent" >   Если используются только главные методы, и не используется
<b><a 
href="symbols.html#x190-382190r190">call-next-method</a></b>, вызываться будет только самый специфичный метод. То
есть наиболее специфичный метод скрывает более общий.
                                                                          

                                                                          
   <h5 class="subsubsectionHead"><a 
href="#x177-27900028.1.7" id="x177-27900028.1.7">Декларация сочетания методов</a></h5>
<!--l. 7212--><p class="noindent" >Макрос <b><a 
href="symbols.html#x190-382316r316">deﬁne-method-combination</a></b> определяет новые формы сочетаний
методов. Он предоставляет механизм для изменения создания рабочего
метода. Процедура по-умолчанию создания рабочего метода описана в
разделе <a 
href="#x177-27700028.1.7">28.1.7<!--tex4ht:ref: Determining-the-Effective-Method-SECTION --></a> Существует две формы <b><a 
href="symbols.html#x190-382316r316">deﬁne-method-combination</a></b>.
Краткая форма содержит простую функциональность. Длинная форма
более мощна и подробна. Длинная форма похожа на <b><a 
href="symbols.html#x190-382320r320">defmacro</a></b> в
том, что тело является выражением. которое вычисляет Lisp&#x2019;овую
форму. Макрос предоставляет механизм для реализации произвольного
функционала в сочетании методов и для произвольной обработки
квалификаторов методов. Синтаксис и использование обеих форм макроса
<b><a 
href="symbols.html#x190-382316r316">deﬁne-method-combination</a></b> описаны в разделе <a 
href="clmse145.html#x178-30400028.2">28.2<!--tex4ht:ref: Functions-in-the-Programmer-Interface-SECTION --></a>.
<!--l. 7225--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-28000028.1.7" id="x177-28000028.1.7">Системные типы сочетания методов</a></h5>
<!--l. 7228--><p class="noindent" >CLOS предоставляет множество системных типов сочетания методов. Для
того, чтобы указать, что обобщённая функция использует один из этих
типов, необходимо в параметр <b>:method-combination</b> для функции
<b><a 
href="symbols.html#x190-382312r312">defgeneric</a></b> или любой другой, задающей параметры для обобщённой
функции, указать имя типа сочетания методов.
<!--l. 7233--><p class="indent" >   Имена системных типов сочетания методов: <b><a 
href="symbols.html#x190-382060r60">+</a></b>, <b><a 
href="symbols.html#x190-382098r98">and</a></b>, <b><a 
href="symbols.html#x190-382099r99">append</a></b>, <b><a 
href="symbols.html#x190-382547r547">list</a></b>, <b><a 
href="symbols.html#x190-382624r624">max</a></b>,
<b><a 
href="symbols.html#x190-382638r638">min</a></b>, <b><a 
href="symbols.html#x190-382666r666">nconc</a></b>, <b><a 
href="symbols.html#x190-382703r703">or</a></b>, <b><a 
href="symbols.html#x190-382761r761">progn</a></b> и <b>standard</b>.
<!--l. 7237--><p class="indent" >   Семантика системного <b>standard</b> типа сочетания методов было описано в
разделе <a 
href="#x177-27800028.1.7">28.1.7<!--tex4ht:ref: Standard-Method-Combination-SECTION --></a>. Другие системные типы сочетания методов называются
<em>простыми системными типами сочетания методов</em>.
<!--l. 7242--><p class="indent" >   Простые системные типы сочетания методов работают так, как если бы
были определены в краткой форме <b><a 
href="symbols.html#x190-382316r316">deﬁne-method-combination</a></b>. Они
предоставляют для методов две роли:
      <ul class="itemize1">
      <li class="itemize"><b>:around</b> метод в качестве единственного квалификатора содержит
      символ   <b>:around</b>.   Смысл   <b>:around</b>  методов   такой   же   как   и
      в  стандартном  типе  сочетания  методов.  В  <b>:around</b>  методах
      поддерживается   использование   функций   <b><a 
href="symbols.html#x190-382190r190">call-next-method</a></b>  и
      <b><a 
href="symbols.html#x190-382669r669">next-method-p</a></b>.
                                                                          

                                                                          
      </li>
      <li class="itemize">Главный метод в качестве единственного квалификатора содержит
      такое  же  имя,  что  и  само  название  типа  сочетания  методов.
      Например,  системный  тип  сочетания  методов  <b>and</b>  распознаёт
      методы, у которых единственный квалификатор <b>and</b>; эти методы
      являются  главными.  В  главных  методах  не  поддерживается
      использование функций <b><a 
href="symbols.html#x190-382190r190">call-next-method</a></b> и <b><a 
href="symbols.html#x190-382669r669">next-method-p</a></b>.
      </li></ul>
<!--l. 7262--><p class="indent" >   Семантика простых системных типов сочетания методов:
      <ul class="itemize1">
      <li class="itemize">Если  существуют  <b>:around</b>  методы,  тогда  вызывается  наиболее
      специфичный  <b>:around</b>  метод.  То  что  вернёт  данный  метод,
      вернётся и из обобщённой функции.
      </li>
      <li class="itemize">Внутри тела <b>:around</b> метода для вызова следующего метода может
      использоваться  функция  <b><a 
href="symbols.html#x190-382190r190">call-next-method</a></b>.  Если  следующего
      метода при использовании этой функции не оказалось, вызывается
      обобщённая           функция           <b><a 
href="symbols.html#x190-382674r674">no-next-method</a></b>.           Для
      определения существует ли следующий метод можно использовать
      <b><a 
href="symbols.html#x190-382669r669">next-method-p</a></b>. После возврата из следующего метода <b>:around</b>
      метод может продолжить выполнения, возможно основываясь на
      полученных значениях.
      </li>
      <li class="itemize">Если <b>:around</b> метод использует <b><a 
href="symbols.html#x190-382190r190">call-next-method</a></b>, тогда вызывается
      следующий наиболее специфичный применимый <b>:around</b> метод. Если
      больше <b>:around</b> методов не осталось, или <b><a 
href="symbols.html#x190-382190r190">call-next-method</a></b> была
      вызвана в последнем таком методе, тогда для возврата значений из
      обобщённой функции выполняется Lisp&#x2019;овая форма, составленная
      из такого же имени, как и тип сочетания методов, и списка
      применимых главных методов. Допустим имя типа сочетания
      методов <em>operator</em> и вызов обобщённой функции выглядит так:
      <div class="lisp"><tt><div class="tabbing">
                                                                          

                                                                          
      (<em>generic-function</em> <span class="math">a<sub>1</sub></span> ... <span class="math">a<sub>n</sub></span>)
      <br>
      <!--l. 7288--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 7289--><p class="noindent" >Пусть <span class="math">M<sub>1</sub>,…,M<sub>k</sub></span> будут применимыми главными методами в таком же
      порядке, тогда производная Lisp&#x2019;овая форма будет выглядеть так:
      <div class="lisp"><tt><div class="tabbing">
      (<em>operator</em> <span class="math">⟨M<sub>1</sub> a<sub>1</sub>…a<sub>n</sub>⟩</span> ... <span class="math">⟨M<sub>k</sub> a<sub>1</sub>…a<sub>n</sub>⟩</span>)
      <br>
      <!--l. 7294--><p class="noindent" ></div>
</tt>
</div>
      <!--l. 7295--><p class="noindent" >Если вычисляется выражение <span class="math">⟨M<sub>i</sub> a<sub>1</sub>…a<sub>n</sub>⟩</span>, тогда метод <span class="math">M<sub>i</sub></span> будет
      применён к аргументам <span class="math">a<sub>1</sub>…a<sub>n</sub></span>. Например, если <em>operator</em> равен <b><a 
href="symbols.html#x190-382703r703">or</a></b>,
      выражение <span class="math">⟨M<sub>i</sub> a<sub>1</sub>…a<sub>n</sub>⟩</span> будет вычислено, только если <span class="math">⟨M<sub>j</sub> a<sub>1</sub>…a<sub>n</sub>⟩</span>,
      <span class="math">1 ≤ j &#x003C; i</span>, вернуло <b><a 
href="symbols.html#x190-382670r670">nil</a></b>.
      <!--l. 7301--><p class="noindent" >Порядок по-умолчанию для главных методов <b>:most-speciﬁc-ﬁrst</b>.
      Однако, порядок может быть изменён указанием <b>:most-speciﬁc-last</b> в
      качестве второго аргумента для параметра <b>:method-combination</b>.</li></ul>
<!--l. 7306--><p class="indent" >   Простые системный типы сочетания методов требуют только один
квалификатор для метода. В случаях, если существуют применимые методы
без квалификаторов или с неподдерживающимися квалификаторами,
сигнализируется ошибка. Если существуют применимые <b>:around</b> методы, и
не существует главных, также сигнализируется ошибка.
<!--l. 7312--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.8   </span> <a 
href="frontmatter.html#QQ2-177-325" id="x177-28100028.1.8">Метаобъекты</a></h4>
                                                                          

                                                                          
<!--l. 7314--><p class="noindent" >Реализация объектной системы управляет классами, методами и обобщёнными
функциями. Метаобъектный протокол определяет множество обобщённых
функций, которые содержат методы для классов. Поведение данных
обобщённых функций определяет поведение объектной системы. Экземпляры
классов, для которых определены эти методы, называются <em>метаобъектами</em>.
Программирование на уровне метаобъектного протокола включает
определение новых классов для метаобъектов вместе с методами для этих
классов.
<!--l. 7322--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-28200028.1.8" id="x177-28200028.1.8">Метаклассы</a></h5>
<em>
<!--l. 7324--><p class="noindent" >Метакласс</em> объекта — это класс класса данного объекта. Метакласс
устанавливает представление экземпляров от экземпляров этого метакласса и
формы наследования, используемые этими экземплярами для описаний слотов и
наследования методов. Механизм метаклассов может использоваться
для оптимизации или модификации объектной системы. Протокол
для определения метаклассов в третьей части CLOS спецификации:
Метаобъектный протокол CLOS <a 
href="amop.html#x185-34000030">30<!--tex4ht:ref: METAOBJECT-PROTOCOL --></a>.
<!--l. 7331--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-28300028.1.8" id="x177-28300028.1.8">Стандартные метаклассы</a></h5>
<!--l. 7333--><p class="noindent" >CLOS содержит ряд уже определённых метаклассов. В них входят классы
<b>standard-class</b>, <b>built-in-class</b> и <b>structure-class</b>:
      <ul class="itemize1">
      <li class="itemize">Класс   <b>standard-class</b>   является   классом   по-умолчанию   для
      классов, определённых с помощью <b><a 
href="symbols.html#x190-382310r310">defclass</a></b>.
      </li>
      <li class="itemize">Класс   <b>built-in-class</b>  является   классов,   экземпляры   которого
      являются  классами  с  ограниченными  возможностями,  которые
      имеют   специальное   предназначение.   Любой   класс,   который
      соответствует стандартному Common Lisp&#x2019;овому типу может быть
      экземпляром класса <b>built-in-class</b>. Встроенные Common Lisp&#x2019;овые
                                                                          

                                                                          
      спецификаторы  типов,  которые  должны  иметь  соответствующие
      классы,  перечислены  в  таблице <a 
href="#x177-2660021">28.1<!--tex4ht:ref: CLOS-PRECEDENCE-TABLE --></a>.  Будут  ли  реализованы
      данные классы как экземпляры класса <b>built-in-class</b> зависит от
      реализации.
      </li>
      <li class="itemize">Все   классы   определённые   с   помощью   <b><a 
href="symbols.html#x190-382325r325">defstruct</a></b>   являются
      экземплярами <b>structure-class</b>.</li></ul>
<!--l. 7353--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-28400028.1.8" id="x177-28400028.1.8">Стандартные метаобъекты</a></h5>
<!--l. 7355--><p class="noindent" >Объектная система содержит стандартный набор метаобъектов, называемых
<em>стандартные метаобъекты</em>. Они включают в себя класс <b>standard-object</b> и
экземпляры классов <b>standard-method</b>, <b>standard-generic-function</b> и
<b>method-combination</b>.
      <ul class="itemize1">
      <li class="itemize">Класс  <b>standard-method</b>  является  классом  по-умолчанию  для
      методов, определённых с помощью форм <b><a 
href="symbols.html#x190-382321r321">defmethod</a></b>, <b><a 
href="symbols.html#x190-382312r312">defgeneric</a></b>,
      <b><a 
href="symbols.html#x190-382452r452">generic-function</a></b>.
      </li>
      <li class="itemize">Класс
      <b>standard-generic-function</b> является классом по-умолчанию для
      обобщённых функций, определённых с помощью форм <b><a 
href="symbols.html#x190-382321r321">defmethod</a></b>,
      <b><a 
href="symbols.html#x190-382312r312">defgeneric</a></b>, <b><a 
href="symbols.html#x190-382452r452">generic-function</a></b> и <b><a 
href="symbols.html#x190-382310r310">defclass</a></b>.
      </li>
      <li class="itemize">Класс  с  именем  <b>standard-object</b> является  экземпляром  класса
      <b>standard-class</b>  и  является  суперклассом  для  любого  класса,
      который является экземпляром <b>standard-class</b>, за исключением
      самого себя.
      </li>
      <li class="itemize">Каждый   объект   сочетания   методов   является   экземпляром
      подкласса класса <b>method-combination</b>.</li></ul>
                                                                          

                                                                          
<!--l. 7384--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.9   </span> <a 
href="frontmatter.html#QQ2-177-329" id="x177-28500028.1.9">Создание и инициализация объекта</a></h4>
<!--l. 7387--><p class="noindent" >Обобщённая функция <b><a 
href="symbols.html#x190-382595r595">make-instance</a></b> создаёт и возвращает новый экземпляр
класса. Первый аргумент является классом или его именем, и остальные
аргументы формируют список <em>инициализационных аргументов</em>.
<!--l. 7391--><p class="indent" >   Инициализация нового экземпляра состоит из нескольких раздельных
шагов: объединение явно указанных инициализационных аргументов со
значениями по-умолчанию для неуказанных аргументов, проверка
корректности инициализационных аргументов, выделение место для
хранения экземпляра, заполнение слотов значениями и выполнение
пользовательских методов, позволяющих выполнить дополнительную
инициализацию. Каждый шаг <b><a 
href="symbols.html#x190-382595r595">make-instance</a></b> реализуется с помощью
обобщённой функции, обеспечивая механизм для настройки этого шага.
Кроме того, <b><a 
href="symbols.html#x190-382595r595">make-instance</a></b> сама по себе является обобщённой функцией и,
следовательно, также может быть настроена.
<!--l. 7401--><p class="indent" >   Объектная система определяет системные главные методы для каждого
шага, и таким образом определяет хорошо описанное стандартное
поведения для всего инициализационного процесса. Стандартное поведение
предоставляет четыре простых механизма для управления инициализацией.
      <ul class="itemize1">
      <li class="itemize">Декларация  символа  для  инициализационного  аргумента  для
      слота.  Инициализационный  аргумент  декларируется  с  помощью
      параметра слота <b>:initarg</b> в <b><a 
href="symbols.html#x190-382310r310">defclass</a></b>. Это механизм для указания
      значения для слота в <b><a 
href="symbols.html#x190-382595r595">make-instance</a></b>.
      </li>
      <li class="itemize">Указание формы значения по-умолчанию для инициализационного
      аргумента.                           Формы                           значения
      по-умолчанию для инициализационного аргумента определяются
      с   помощью   параметра   класса   <b>:default-initargs</b>  в   <b><a 
href="symbols.html#x190-382310r310">defclass</a></b>.
      Если   инициализационный   аргумент   не   предоставляется   явно
      как аргумент для <b><a 
href="symbols.html#x190-382595r595">make-instance</a></b>, вычисляется форма значения
      по-умолчанию  в  том  же  лексическом  окружении,  что  и  форма
      <b><a 
href="symbols.html#x190-382310r310">defclass</a></b>, которая её содержит, и значение используется в качестве
      инициализационного аргумента.
      </li>
                                                                          

                                                                          
      <li class="itemize">Указание  первоначального  значения  по-умолчанию  для  слота.
      Форма   первоначального   значения   по-умолчанию   для   слота
      определяется  с  помощью  параметра  слота  <b>:initform</b> в  <b><a 
href="symbols.html#x190-382310r310">defclass</a></b>.
      Если с данным слотом не связан инициализационный аргумент ни в
      <b><a 
href="symbols.html#x190-382595r595">make-instance</a></b>, ни в <b>:default-initarg</b>, данная форма вычисляется
      в   лексическом   окружении   <b><a 
href="symbols.html#x190-382310r310">defclass</a></b>,   и   полученное   значение
      сохраняется  в  слот.  Форма  <b>:initform</b>  локального  слота  может
      быть использована при создании экземпляра или при обновлении
      экземпляра класса для согласования с переопределённым классом.
      Форма <b>:initform</b> для разделяемого слота может быть использована
      при определении или переопределении класса.
      </li>
      <li class="itemize">Определение                                                               методов
      <b><a 
href="symbols.html#x190-382495r495">initialize-instance</a></b> и <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b>. Описанное выше поведение
      при заполнении слотов реализуется системными главным методом
      для   <b><a 
href="symbols.html#x190-382495r495">initialize-instance</a></b>,   который   вызывает   <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b>.
      Обобщённая                    функция                    <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b>
      реализует части инициализации, разделённой на четыре ситуации:
      при  создании  экземпляра,  при  переинициализации  экземпляра,
      при обновлении экземпляра для согласования с переопределённым
      классом   и   при   обновлении   экземпляра   для   согласования   с
      другим классом. Системный главный метод для <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b>
      напрямую  реализует  поведение  заполнения  слотов,  описанное
      выше, и <b><a 
href="symbols.html#x190-382495r495">initialize-instance</a></b> содержит вызов к <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b>.
      </li></ul>
<!--l. 7446--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-28600028.1.9" id="x177-28600028.1.9">Инициализационные аргументы</a></h5>
<!--l. 7448--><p class="noindent" >Инициализационный аргумент управляет созданием и инициализацией
объекта. Обычно для его имени удобно использовать ключевой символ, но
может использоваться любой символ, включая <b><a 
href="symbols.html#x190-382670r670">nil</a></b>. Инициализационный
аргумент может использоваться двумя методами: для заполнения слота
значением, или для предоставления аргумента в инициализационном методе.
Для обоих методов может использовать один инициализационный
аргумент.
                                                                          

                                                                          
<em>
<!--l. 7455--><p class="indent" >   Список инициализационных аргументов</em> — это список чередующихся
имён инициализационных аргументов и их значений. Его структура
идентична списку свойств и также части списка аргументов для <b>&#x0026;key</b>
параметров. Как и в тех списках, если инициализационный аргумент в списке
встречается более чем один раз, для значения используется наиболее левое
вхождение, остальные игнорируются. Аргументы для <b><a 
href="symbols.html#x190-382595r595">make-instance</a></b> (после
первого аргумента) формируют список инициализационных аргументов.
Проверка имён инициализационных аргумент отключена, если в списке
встречает пара <b>:allow-other-keys</b> и не-<b><a 
href="symbols.html#x190-382670r670">nil</a></b>.
<!--l. 7465--><p class="indent" >   Инициализационный аргумент может быть связан со слотом. Если
инициализационный аргумент имеет значение в списке, это значение
сохраняется в слоте вновь создаваемого объекта, перезаписывая любый
связанные со слотом формы <b>:initform</b>. Один инициализационный аргумент
может задавать значения более чем одному слоту. Инициализационный
аргумент, который инициализирует разделяемый слот, записывает значение в
этот слот, заменяя любое предыдущее.
<!--l. 7472--><p class="indent" >   Инициализационный аргумент может быть связан с методом. Когда
создаётся объект и указан такой инициализационный аргумент, то обобщённые
функции <b><a 
href="symbols.html#x190-382495r495">initialize-instance</a></b>, <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b> и <b><a 
href="symbols.html#x190-382094r94">allocate-instance</a></b>
вызываются с этим аргументом в виде пары: ключевой параметр и
его значение. Если значение для инициализационного аргумента на
было указано в списке, лямбда-список метода используется значение
по-умолчанию.
<!--l. 7479--><p class="indent" >   Инициализационные аргументы используются в четырёх случаях: при
создании экземпляра класса, при переинициализации экземпляра, при
обновлении экземпляра в соответствие с переопределённым классом, и
при обновлении экземпляра в соотвествие с определением другого
класса.
<!--l. 7484--><p class="indent" >   Поскольку инициализационные аргументы используются для управления
созданием и инициализацией экземпляра того или иного класса, мы говорим,
что инициализационный аргумент — это «инициализационный аргумент для»
этого класса.
<!--l. 7489--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-28700028.1.9" id="x177-28700028.1.9">Декларация корректных инициализационных аргументов FIXME</a></h5>
                                                                          

                                                                          
<!--l. 7492--><p class="noindent" >Инициализационные аргументы проверяются на корректность в каждой из
четырёх ситуаций их использования. Инициализационный аргумент может
быть корректен в одном случае и некорректен в другом. Например,
системный главный метод для <b><a 
href="symbols.html#x190-382595r595">make-instance</a></b>, определённый для
<b>standard-class</b>, проверяет корректность инициализационных аргументов и
сигнализирует ошибку, если инициализационный аргумент указан и является
некорректным в данной ситуации.
<!--l. 7499--><p class="indent" >   Существует два случая декларации корректного инициализационного
аргумента.
      <ul class="itemize1">
      <li class="itemize">Инициализационные                  аргументы,                  которые
      заполняют слоты, являются корректными, если декларированы в
      параметры слота <b>:initarg</b> в <b><a 
href="symbols.html#x190-382310r310">defclass</a></b>. Таким образом множество
      корректных инициализационных аргументов, которые заполняют
      слоты,       являются       объединением       всех       корректных
      инициализационных аргументов для слотов данного класса и всех
      его суперклассов. Тогда инициализационные аргументы корректны
      во всех четырёх случаях использования.
      </li>
      <li class="itemize">Инициализационные  аргументы,  которые  передают  значения  в
      методы являются корректными, если определены в этих методах.
      Имя каждого именованного параметра, указанное в лямбда-списке
      метода,
      становится инициализационным аргументом для всех классов, для
      которых  данный  метод  применим.  Таким  образом  наследование
      методов управляет множеством корректных инициализационных
      аргументов,  которые  передают  значения  в  методы.  Обобщённая
      функция для таких методов:
           <ul class="itemize2">
           <li class="itemize">Создание       экземпляра       класса:       <b><a 
href="symbols.html#x190-382094r94">allocate-instance</a></b>,
           <b><a 
href="symbols.html#x190-382495r495">initialize-instance</a></b> и  <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b>.  Инициализационные
           аргументы   декларированные   этими   методами   являются
           корректными при создании экземпляра класса.
                                                                          

                                                                          
           </li>
           <li class="itemize">Переинициализация              экземпляра:              функции
           <b><a 
href="symbols.html#x190-382794r794">reinitialize-instance</a></b>             и               <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b>.
           Инициализационные                                          аргументы
           декларированные этими методами являются корректными при
           переинициализации экземпляра класса.
           </li>
           <li class="itemize">Обновление  экземпляра  в  соответствие  с  переопределённым
           классом:          <b><a 
href="symbols.html#x190-382991r991">update-instance-for-redeﬁned-class</a></b>         и
           <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b>.         Инициализационные         аргументы
           декларированные этими методами являются корректными при
           обновление  экземпляра  в  соответствие  с  переопределённым
           классом.
           </li>
           <li class="itemize">Обновление  экземпляра  в  соответствие  с  другим  классом:
           <b><a 
href="symbols.html#x190-382990r990">update-instance-for-diﬀerent-class</a></b>    и    <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b>.
           Инициализационные   аргументы   декларированные   этими
           методами являются корректными при обновление экземпляра
           в соответствие с другим классом.</li></ul>
      </li></ul>
<!--l. 7545--><p class="indent" >   Корректные инициализационные аргументы это те, которые
устанавливают значения в слоты или те, что передают значения в
методы вместе с предопределённым аргументом <b>:allow-other-keys</b>.
Значение по-умолчанию для <b>:allow-other-keys</b> равно <b><a 
href="symbols.html#x190-382670r670">nil</a></b>. Значение
<b>:allow-other-keys</b> здесь такое же, как и в случае использования в обычной
функции.
<!--l. 7551--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-28800028.1.9" id="x177-28800028.1.9">Значения по-умолчанию для инициализационных аргументов</a></h5>
<!--l. 7554--><p class="noindent" >Форма значения по-умолчанию для инициализационного аргумента может
быть указана с помощью параметра класса <b>:default-initargs</b>. Если
инициализационный аргумент задекларирован в некотором классе, его
значение по-умолчанию может быть обозначено в другом классе. В этом
случае <b>:default-initargs</b> используется для установки значения по-умолчанию
для унаследованного инициализационного аргумента.
                                                                          

                                                                          
<!--l. 7561--><p class="indent" >   Параметр <b>:default-initargs</b> используется только для указания значений
по-умолчанию. Он не декларирует символ в качестве корректного имени
инициализационного аргумента. Кроме того, параметр <b>:default-initargs</b>
используется только для указания значений по-умолчанию при создании
экземпляра объекта.
<!--l. 7567--><p class="indent" >   Аргумент к параметру класса <b>:default-initargs</b> является списком
чередующихся имён инициализационных аргументов и форм. Каждая форма
является значением по-умолчанию для соответствующего инициализационного
аргумента. Форма значения по-умолчанию инициализационного аргумента
используется и вычисляется только, если этот аргумент не встречается в
<b><a 
href="symbols.html#x190-382595r595">make-instance</a></b> и значение по-умолчанию не переопределено в более
специфичном классе. Форма значения по-умолчанию вычисляется в
лексическом окружении <b><a 
href="symbols.html#x190-382310r310">defclass</a></b>, в котором она была указана. Результат
вычисления используется для установки в инициализационный аргумент.
<!--l. 7577--><p class="indent" >   Инициализационные аргументы, указанные в <b><a 
href="symbols.html#x190-382595r595">make-instance</a></b>, объединяются
с аргументами, которые имеют значения по-умолчанию, и получается <em>список
инициализационных аргументов со значениями по-умолчанию</em>. Этот список
является списком чередующихся имён инициализационных аргументов и
значений. Вначале идут пары со значениями переданными в функцию, затем
— со значениями по-умолчанию. Значения по-умолчанию упорядочены в
соотвествие со списком приоритетности классов, в которых они были
определены.
<!--l. 7585--><p class="indent" >   Цели параметров <b>:default-initargs</b> и <b>:initform</b> различаются. Параметр
класса <b>:default-initargs</b> позволяет пользователю указывать формы значения
по-умолчанию для инициализационного аргумента без знания о том: для
слота ли значение, или для метода. Если инициализационный аргумент не
был указан в вызове <b><a 
href="symbols.html#x190-382595r595">make-instance</a></b>, то используется его значение
по-умолчанию и ситуация становится такой, как будто аргумент таки
был указан. В отличие от этого, параметр слота <b>:initform</b> позволяет
пользователю задать для слота значение по-умолчанию. Форма <b>:initform</b>
используется только в случаях когда не было указано инициализационного
аргумента в <b><a 
href="symbols.html#x190-382595r595">make-instance</a></b> и для него в <b>:default-initargs</b> не было указано
значение по-умолчанию.
<!--l. 7596--><p class="indent" >   Порядок вычисления форм значений по-умолчанию для инициализационных
аргумент и порядок вычисления форм <b>:initform</b> не определены. Если
порядок вычисления важен, используйте методы <b><a 
href="symbols.html#x190-382495r495">initialize-instance</a></b> или
<b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b>.
                                                                          

                                                                          
<!--l. 7600--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-28900028.1.9" id="x177-28900028.1.9">Правила для инициализационных аргументов</a></h5>
<!--l. 7603--><p class="noindent" >Параметр слота <b>:initarg</b> для одного может быть указан более одного раза. В
таком случае срабатывают следующие правила:
      <ul class="itemize1">
      <li class="itemize">Данный инициализационный аргумент может использоваться для
      инициализации  более  чем  одно  слота,  если  в  параметре  слота
      <b>:initarg</b> указаны одинаковые аргументы.
      </li>
      <li class="itemize">Данное имя инициализационного аргумента может встречаться в
      лямбда-списках более чем в одном инициализационном методе.
      </li>
      <li class="itemize">Данное имя инициализационного аргумент может встречаться и в
      параметре слота <b>:initarg</b> и в лямбда-списке инициализационного
      метода.</li></ul>
<!--l. 7618--><p class="indent" >   Если в <b><a 
href="symbols.html#x190-382595r595">make-instance</a></b> передано два или более инициализационных
аргументов для одного и того же слота, тогда из них используется только
тот, который стоит левее остальных, даже если имена аргументов
отличаются.
<!--l. 7622--><p class="indent" >   Если два или более инициализационных аргументов задают значение для
одного и того же слота, и ни один из них не указан в <b><a 
href="symbols.html#x190-382595r595">make-instance</a></b>, тогда
из них используется только тот, который встречается в параметре самого
специфичного класса <b>:default-initargs</b>. Если один параметр класса
<b>:default-initargs</b> определяет два или более инициализационных аргументов
для одного и того же слота, используется значение наиболее левого из них,
остальные игнорируются.
<!--l. 7630--><p class="indent" >   Инициализационные аргумент, явно указанные в <b><a 
href="symbols.html#x190-382595r595">make-instance</a></b>, стоят
слева от аргументов со значениями по-умолчанию. Предположим классы <span class="math">C<sub>1</sub></span>
и <span class="math">C<sub>2</sub></span> содержат значения по-умолчанию для инициализационных аргумент
для различных слотов, и предположим, что <span class="math">C<sub>1</sub></span> более специфичен, чем <span class="math">C<sub>2</sub></span>.
Тогда значения по-умолчанию из <span class="math">C<sub>1</sub></span> в списке инициализационных
аргументов будут стоять слева от значений из <span class="math">C<sub>2</sub></span>. Если один параметр класс
<b>:default-initargs</b> содержит значения для нескольких различных слотов, в
списке инициализационных аргументов эти значения будут указаны в таком
же порядке.
                                                                          

                                                                          
<!--l. 7639--><p class="indent" >   Если слот имеет и форму <b>:initform</b>, и параметр слота <b>:initarg</b> и
инициализационный аргумент имеет значение в <b>:default-initargs</b> или в
<b><a 
href="symbols.html#x190-382595r595">make-instance</a></b>, форма <b>:initform</b> не используется и не вычисляется.
<!--l. 7643--><p class="indent" >   Пример вышеназванных правил:
<div class="lisp">
<tt>
<!--l. 7645--><p class="indent" >   <div class="tabbing">
(defclass q () ((x :initarg a)))
   <br>                            <br>                            (defclass r (q) ((x :initarg b))<br>
  (:default-initargs a 1 b 2))<br>
<!--l. 7650--><p class="noindent" ></div>
</tt>
</div>
<div class="flushleft" 
>
<!--l. 7652--><p class="noindent" >
 <!--tex4ht:inline--><div class="tabular"><table width="100%" class="tabular"><tr><td align="left" >                                          </td><td align="left" >Инициализация    </td><td align="left" >Содержимое</td>
</tr><tr><td align="left" >Форма                                 </td><td align="left" >списка аргументов</td><td align="left" >слота          </td>
</tr><tr><td align="left" ><b>(make-instance &#x2019;r)</b>             </td><td align="left" ><b>(a 1 b 2)</b>           </td><td align="left" ><b>1</b>              </td>
</tr><tr><td align="left" ><b>(make-instance &#x2019;r &#x2019;a 3)</b>       </td><td align="left" ><b>(a 3 b 2)</b>           </td><td align="left" ><b>3</b>              </td>
</tr><tr><td align="left" ><b>(make-instance &#x2019;r &#x2019;b 4)</b>       </td><td align="left" ><b>(b 4 a 1)</b>           </td><td align="left" ><b>4</b>              </td>
</tr><tr><td align="left" ><b>(make-instance &#x2019;r &#x2019;a 1 &#x2019;a 2)</b> </td><td align="left" ><b>(a 1 a 2 b 2)</b>      </td><td align="left" ><b>1</b>              </td></tr><tr 
class="hline"><td><hr></td><td><hr></td><td><hr></td></tr><tr><td align="left" >  </td></tr></table>
</div></div>
<!--l. 7665--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-29000028.1.9" id="x177-29000028.1.9">shared-initialize</a></h5>
<!--l. 7668--><p class="noindent" >При создании, переинициализации, при обновлении до изменённого класса,
обновлении до другого класса для заполнения слотов экземпляра класса с
помощью инициализационных аргументов и форм <b>:initform</b> используется
обобщённая функция <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b>. Она использует стандартный тип
сочетания методов. Она принимает следующие аргументы: экземпляр для
инициализации, спецификация набора слотов, доступных в данном
экземпляре, и любое количество инициализационных аргументов. Аргументы
после первых двух должны формировать список инициализационных
аргументов.
                                                                          

                                                                          
<!--l. 7677--><p class="indent" >   Второй аргумент для <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b> может быть одним из:
      <ul class="itemize1">
      <li class="itemize">Он может быть списком имён слотов.
      </li>
      <li class="itemize">Он может быть символом <b><a 
href="symbols.html#x190-382670r670">nil</a></b>, что означает пустой список имён
      слотов.
      </li>
      <li class="itemize">Он может быть символом <b><a 
href="symbols.html#x190-382951r951">t</a></b>, который означает список всех слотов.</li></ul>
<!--l. 7687--><p class="indent" >   В системе установлен главный метод для <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b>, у которого
первый специализатор параметра является классом <b>standard-object</b>. Вне
зависимости от того, разделяемый ли слот, или локальный, данный метод
ведёт себя следующим образом:
      <ul class="itemize1">
      <li class="itemize">Если инициализационный аргумент в списке указывает значение
      для такого слота, тогда значение сохраняется в слоте, даже если
      значение уже было до запуска метода в нем сохранено. Данный
      слот  не  зависит  от  того,  какие  слоты  были  указаны  во  втором
      аргументе <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b>.
      </li>
      <li class="itemize">Любые   слоты,   указанные   во   втором   аргументе,   и   которые
      до   сих   пор   не   были   связаны   с   какими-либо   значениями,
      инициализируются в соответствие с их формами <b>:initform</b>. Для
      любых   таких   слотов,   которые   имеют   форму   <b>:initform</b>,   эта
      форма  выполняется  в  таком  же  лексическом  окружении,  что  и
      выполнялась формы <b><a 
href="symbols.html#x190-382310r310">defclass</a></b>, и её значение сохраняется в слоте.
      Например, если <b>:before</b> метод сохраняет значение в слот, форма
      <b>:initform</b> использоваться не будет. Если второй аргумент это имя,
      которое  не  указывает  ни  на  один  слот  в  экземпляре,  результат
      непредсказуем.
      </li>
      <li class="itemize">А также правила, упомянутые в разделе <a 
href="#x177-28900028.1.9">28.1.9<!--tex4ht:ref: Rules-for-Initialization-Arguments-SECTION --></a>.</li></ul>
                                                                          

                                                                          
<!--l. 7710--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b> вызывается из системных главных
методов для обобщённых функций <b><a 
href="symbols.html#x190-382495r495">initialize-instance</a></b>, <b><a 
href="symbols.html#x190-382794r794">reinitialize-instance</a></b>,
<b><a 
href="symbols.html#x190-382990r990">update-instance-for-diﬀerent-class</a></b> и <b><a 
href="symbols.html#x190-382991r991">update-instance-for-redeﬁned-class</a></b>.
Таким образом для указания действий, которые должны быть выполнены во
всех этих контекстах, можно написать методы для <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b>.
<!--l. 7719--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-29100028.1.9" id="x177-29100028.1.9">initialize-instance</a></h5>
<!--l. 7721--><p class="noindent" >Обобщённая функция <b><a 
href="symbols.html#x190-382495r495">initialize-instance</a></b> вызывается из <b><a 
href="symbols.html#x190-382595r595">make-instance</a></b> для
инициализации вновь создаваемого экземпляра класса. Она используется
стандартный тип сочетания методов. Для <b><a 
href="symbols.html#x190-382495r495">initialize-instance</a></b> могут быть
определены методы для выполнения какого-либо инициализационного
алгоритма.
<b>
<!--l. 7726--><p class="indent" >   <a 
href="symbols.html#x190-382495r495">initialize-instance</a></b> вызывается в процессе инициализации после
выполнения следующих действий.
      <ul class="itemize1">
      <li class="itemize">Вычисляется     список     инициализационных     аргументов     со
      значениями по-умолчанию.
      </li>
      <li class="itemize">Проверяется его корректность. Если хоть один аргумент в списке
      некорректен, сигнализируется ошибка.
      </li>
      <li class="itemize">Создаётся   новый   экземпляр   со   слотами   несвязанными   со
      значениями.
      </li></ul>
<!--l. 7741--><p class="indent" >   Вызывается обобщённая функция <b><a 
href="symbols.html#x190-382495r495">initialize-instance</a></b> с параметрами: новый
экземпляр, инициализационные аргументы. В системе для <b><a 
href="symbols.html#x190-382495r495">initialize-instance</a></b>
установлен главный метод, специализатором параметра которого является
класс <b>standard-object</b>. Данный метод для заполнения слотов значениями в
соответствие с инициализационными аргументами или формами <b>:initform</b>
вызывает обобщённую функцию <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b>. Обобщённая функция
<b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b> вызывается со следующими аргументами: экземпляр, <b><a 
href="symbols.html#x190-382951r951">t</a></b> и
                                                                          

                                                                          
инициализационные аргументы.
<!--l. 7750--><p class="indent" >   Следует отметить, что <b><a 
href="symbols.html#x190-382495r495">initialize-instance</a></b> в вызов <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b>
предоставляет список инициализационных аргументов, таким образом первый
шаг, выполняемый системным главным методом для <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b>
учитывает и аргументы <b><a 
href="symbols.html#x190-382595r595">make-instance</a></b> и список инициализационных
аргументов.
<!--l. 7755--><p class="indent" >   Для указания действий при инициализации экземпляра могут быть
определены методы для <b><a 
href="symbols.html#x190-382495r495">initialize-instance</a></b>. Если для <b><a 
href="symbols.html#x190-382495r495">initialize-instance</a></b>
указаны только <b>:after</b> методы, они будут вызваны после системного метода и
таким образом не будут влиять на поведение по-умолчанию.
<!--l. 7760--><p class="indent" >   Объектная система предоставляет две функции, которые весьма полезны
в телах методов <b><a 
href="symbols.html#x190-382495r495">initialize-instance</a></b>. Функция <b><a 
href="symbols.html#x190-382871r871">slot-boundp</a></b> возвращает
булево значение, которое показывает, имеет ли указанный слот значение.
Это позволяет писать <b>:after</b> методы для <b><a 
href="symbols.html#x190-382495r495">initialize-instance</a></b>, которые
инициализируют слоты, только если они ещё не были инициализированы.
<!--l. 7766--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-29200028.1.9" id="x177-29200028.1.9">Определения make-instance and initialize-instance</a></h5>
<!--l. 7768--><p class="noindent" >Обобщённая функция <b><a 
href="symbols.html#x190-382595r595">make-instance</a></b> ведёт себя так, как если была
определена следующим образом (за исключением возможных оптимизаций):
<div class="lisp">
<tt>
<!--l. 7771--><p class="indent" >   <div class="tabbing">
(defmethod make-instance ((class standard-class) &#x0026;rest initargs)
   <br>                                  (setq initargs (default-initargs class initargs))<br>
  ...<br>             (let ((instance (apply #&#x2019;allocate-instance class initargs)))<br>
    (apply #&#x2019;initialize-instance instance initargs)<br>               instance))<br>
<br>            (defmethod make-instance ((class-name symbol) &#x0026;rest initargs)<br>
  (apply #&#x2019;make-instance (ﬁnd-class class-name) initargs))<br>
<!--l. 7781--><p class="noindent" ></div>
</tt>
</div>
<!--l. 7806--><p class="indent" >   Пропущенный код в определении <b><a 
href="symbols.html#x190-382595r595">make-instance</a></b> проверяет переданные
                                                                          

                                                                          
инициализационные аргументы на корректность. Эта проверка должна
быть выполнена с помощью обобщённых функция <b><a 
href="symbols.html#x190-382247r247">class-prototype</a></b>,
<b><a 
href="symbols.html#x190-382270r270">compute-applicable-methods</a></b>, <b><a 
href="symbols.html#x190-382448r448">function-keywords</a></b> и <b>class-slot-initargs</b>.
Смотрите третью часть спецификации для описания проверки
инициализационных аргументов.
<!--l. 7813--><p class="indent" >   Обобщённая функция ведёт себя так, как если бы была определена
следующим образом (за исключением возможных оптимизаций):
<div class="lisp">
<tt>
<!--l. 7816--><p class="indent" >   <div class="tabbing">
(defmethod initialize-instance
   <br>                                 ((instance standard-object) &#x0026;rest initargs)<br>
  (apply #&#x2019;shared-initialize instance t initargs)))<br>
<!--l. 7820--><p class="noindent" ></div>
</tt>
</div>
<!--l. 7822--><p class="indent" >   Эти процедуры могут быть настроены (модифицированы) и на уровне
функций из интерфейса к CLOS, и на метаобъектном уровне, или даже на
всех двух уровнях.
<!--l. 7825--><p class="indent" >   Настройка на уровне CLOS включает использование параметров <b>:initform</b>,
<b>:initarg</b> и <b>:default-initargs</b> в <b><a 
href="symbols.html#x190-382310r310">defclass</a></b>, а также определение методов для
<b><a 
href="symbols.html#x190-382595r595">make-instance</a></b> и <b><a 
href="symbols.html#x190-382495r495">initialize-instance</a></b>. Также возможно определение
методов для <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b>, которые будут вызваны обобщёнными
функциями <b><a 
href="symbols.html#x190-382794r794">reinitialize-instance</a></b>, <b><a 
href="symbols.html#x190-382991r991">update-instance-for-redeﬁned-class</a></b>,
<b><a 
href="symbols.html#x190-382990r990">update-instance-for-diﬀerent-class</a></b> и <b><a 
href="symbols.html#x190-382495r495">initialize-instance</a></b>. Метаобъектный
уровень поддерживает дополнительные настройки с помощью определения
методов для <b><a 
href="symbols.html#x190-382595r595">make-instance</a></b>, <b>default-initargs</b> и <b><a 
href="symbols.html#x190-382094r94">allocate-instance</a></b>.
<!--l. 7836--><p class="indent" >   Реализации могут оптимизировать <b><a 
href="symbols.html#x190-382495r495">initialize-instance</a></b> и <b>shared-instance</b>.
Описание <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b> в разделе <a 
href="clmse145.html#x178-30400028.2">28.2<!--tex4ht:ref: Functions-in-the-Programmer-Interface-SECTION --></a> содержит возможные
оптимизации.
<!--l. 7841--><p class="indent" >   Из-за оптимизаций, проверка корректности инициализационных
аргументов может не использовать обобщённые функции <b><a 
href="symbols.html#x190-382247r247">class-prototype</a></b>,
<b>compute-applicable-methods</b>, <b><a 
href="symbols.html#x190-382448r448">function-keywords</a></b> и <b>class-slot-initargs</b> Кроме
того, методы обобщённой функции <b>default-initargs</b> и системные главные
методы для <b><a 
href="symbols.html#x190-382094r94">allocate-instance</a></b>, <b><a 
href="symbols.html#x190-382495r495">initialize-instance</a></b> и <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b> могут
                                                                          

                                                                          
вызываться не каждый раз при выполнении <b><a 
href="symbols.html#x190-382595r595">make-instance</a></b> или могут
получать не всех аргументы, которые хотят.
<!--l. 7850--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.10   </span> <a 
href="frontmatter.html#QQ2-177-337" id="x177-29300028.1.10">Переопределение классов</a></h4>
<!--l. 7853--><p class="noindent" >Класс, который является экземпляром <b>standard-class</b> может быть
переопределён, если новый экземпляр также принадлежит классу
<b>standard-class</b>. Переопределение класса — это модификация существующего
объекта класса для соответствия с новым определением. Это не создание
нового объекта класса. Любые объекты методов созданные в соответствие с
параметрами <b>:reader</b>, <b>:writer</b> или <b>:accessor</b> в старом определении класса
удаляются из соответствующих обобщённых функций. А методы указанные в
новом определении класса наоборот добавляются.
<!--l. 7862--><p class="indent" >   Когда переопределяется класс <em>C</em>, изменения затрагивают его экземпляры,
а также экземпляры всех его подклассов. Время обновление такого
экземпляра зависит от реализации, но не позже, чем будет обращение
к его слоту. Обновление экземпляра не меняет его идентичности в
соответствии с определением функции <b><a 
href="symbols.html#x190-382378r378">eq</a></b>. Процесс обновления может только
менять слоты отдельно взятого экземпляра, но не создавать новые
экземпляры. Потребление памяти при процессе обновления зависит от
реализации.
<!--l. 7871--><p class="indent" >   Следует отметить, что переопределение класса может приводить к
добавлению или удалению слотов. Если при переопределении класса
произошло изменения набора слотов для экземпляров, то последние будут
обновлены. Если же локальные слоты изменены не были, процесс обновления
экземпляров зависит от реализации.
<!--l. 7876--><p class="indent" >   Значение слота, который и в старом, и в новом классах является
разделяемым, остаётся неизменным. Если он был несвязанным, он таким же
и останется. Слот, который в старом классе был локальным, а в новом стал
разделяемым, будет заново инициализирован. Вновь добавленные
разделяемые слоты также будут инициализированы.
<!--l. 7882--><p class="indent" >   Каждый вновь добавленный разделяемый слот будет иметь значение
формы <b>:initform</b>, определённой в новом классе. Если такой формы не было,
слот остаётся несвязанным.
<!--l. 7886--><p class="indent" >   Если происходит переопределение класса и при этом изменяется набор
локальных слотов, то обновление всех экземпляров происходит в два шага.
                                                                          

                                                                          
Процесс может быть запущен явно с помощью обобщённой функции
<b>make-instance-obsolete</b>. В некоторых реализациях этот процесс может быть
запущен и при других обстоятельствах. Например, при изменении порядка
слотов.
<!--l. 7892--><p class="indent" >   Первый шаг модифицирует структуру экземпляра, а именно, добавляет
новые локальные слоты и удаляет локальные слоты, которых нет в новом
определении. Второй шаг инициализирует вновь добавленные локальные
слоты и выполняет другие пользовательские действия. Эти шаги описаны в
следующих разделах.
<!--l. 7897--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-29400028.1.10" id="x177-29400028.1.10">Изменение структуры экземпляров классов</a></h5>
<!--l. 7899--><p class="noindent" >Первый шаг изменяет структуру экземпляров переопределяемого класса для
согласования с новым определением. Добавляются локальные слоты,
указанные в новом классе, но отсутствующие или бывшие разделяемыми в
определении старого. Удаляются слоты (и локальные, и разделяемые), не
существующие в определении нового класса, но бывший в определении
старого. Имена этих добавленных и удалённых слотов передаются
в <b><a 
href="symbols.html#x190-382991r991">update-instance-for-redeﬁned-class</a></b> как написано в следующем
разделе.
<!--l. 7907--><p class="indent" >   Значений локальных слотов, указанных и в новом, и в старом
определениях, остаются нетронутыми. Если слот был несвязанным, он таким
и остаётся.
<!--l. 7910--><p class="indent" >   Значения слотов, которые в старом определении были разделяемыми, а в
новом стали локальными, остаются нетронутыми. Если такой слот был
несвязанным, он таким и остаётся.
<!--l. 7914--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-29500028.1.10" id="x177-29500028.1.10">Инициализация вновь добавленных локальных слотов</a></h5>
<!--l. 7916--><p class="noindent" >Второй шаг обновления инициализируется вновь добавленные слоты и
выполняет другие пользовательские действия. Данный шаг реализован
обобщённой функцией <b><a 
href="symbols.html#x190-382991r991">update-instance-for-redeﬁned-class</a></b>, которая
вызывается после того как завершается первый шаг обновления или было
произведено изменение структуры класса.
<!--l. 7922--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x190-382991r991">update-instance-for-redeﬁned-class</a></b> принимает
                                                                          

                                                                          
четыре обязательных аргумента: обновляемый экземпляр после первого шага,
список имён локальных слотов, которые были добавлены, список имён
локальный слотов, которые были удалены, и список свойств, содержащий
имена слотов и из значения, которые были удалены и имели эти значения. В
удалённые слоты включаются также те слоты, которые в старом классе были
локальными, а в новом — разделяемыми.
<!--l. 7929--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x190-382991r991">update-instance-for-redeﬁned-class</a></b> также
принимает любое количество инициализационных аргументов. Когда система
вызывает данную функцию для обновления экземпляра, класс которого был
переопределён, ни одного такого аргумента не указывается.
<!--l. 7934--><p class="indent" >   В системе установлен главный метод для <b><a 
href="symbols.html#x190-382991r991">update-instance-for-redeﬁned-class</a></b>,
у которого специализатор параметра является классом <b>standard-object</b>.
Сначала этот метод проверяет корректность инициализационных аргументов
и сигнализирует ошибку в случае неудачи. Смотрите раздел <a 
href="#x177-28700028.1.9">28.1.9<!--tex4ht:ref: Declaring-the-Validity-of-Initialization-Arguments-SECTION --></a>. Затем он
вызывает обобщённую функцию <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b> со следующими
аргументами: экземпляр класса, список имён вновь добавленных слотов и
принятые инициализационные аргументы.
<!--l. 7944--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-29600028.1.10" id="x177-29600028.1.10">Настройка переопределения класса</a></h5>
<!--l. 7946--><p class="noindent" >Для указания действий, происходящих при обновлении экземпляра класса,
могут быть определены методы для <b><a 
href="symbols.html#x190-382991r991">update-instance-for-redeﬁned-class</a></b>.
Если для <b><a 
href="symbols.html#x190-382991r991">update-instance-for-redeﬁned-class</a></b> определены только <b>:around</b>
методы, они будут запущены после системного главного метода и не будут
влиять на поведение по-умолчанию <b><a 
href="symbols.html#x190-382991r991">update-instance-for-redeﬁned-class</a></b>.
Так как в <b><a 
href="symbols.html#x190-382990r990">update-instance-for-diﬀerent-class</a></b> системой не передаются
инициализационные аргументы, формы <b>:initform</b> для слотов, которые были
заполнены в <b>:before</b> методах, для <b><a 
href="symbols.html#x190-382991r991">update-instance-for-redeﬁned-class</a></b>
вычисляться не будут.
<!--l. 7955--><p class="indent" >   Для настройки переопределения класса могут быть определены методы
для <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b> (смотрите раздел <a 
href="#x177-29000028.1.9">28.1.9<!--tex4ht:ref: Shared-Initialize-SECTION --></a>).
<!--l. 7958--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-29700028.1.10" id="x177-29700028.1.10">Расширения</a></h5>
<!--l. 7960--><p class="noindent" >Существует для расширения для переопределения класса:
                                                                          

                                                                          
      <ul class="itemize1">
      <li class="itemize">Объектная   система   может   быть   расширена   до   того,   чтобы
      разрешить новому классу быть экземпляром другого метакласса,
      не совпадающего со старым.
      </li>
      <li class="itemize">Объектная   система   может   быть   расширена   до   того,   чтобы
      поддерживать   процесс   обновления,   когда   или   старый   или
      новый  класс  является  экземпляром  класса,  отличающегося  от
      <b>standard-class</b>, то есть экземпляром не системного класса.</li></ul>
<!--l. 7972--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.11   </span> <a 
href="frontmatter.html#QQ2-177-342" id="x177-29800028.1.11">Изменение класса для некоторого экземпляра</a></h4>
<!--l. 7975--><p class="noindent" >Функция <b><a 
href="symbols.html#x190-382214r214">change-class</a></b> может использоваться для изменения класс
некоторого экземпляра с текущего <span class="math">C<sub>from</sub></span> на какой-либо другой <span class="math">C<sub>to</sub></span>. Функция
изменяет структуру экземпляра для согласования с определением класса
<span class="math">C<sub>to</sub></span>.
<!--l. 7979--><p class="indent" >   Следует отметить, что изменение класса экземпляра может вызвать
добавление или удаление слотов.
<!--l. 7982--><p class="indent" >   При вызове <b><a 
href="symbols.html#x190-382214r214">change-class</a></b> для некоторого экземпляра, происходят два
шага его обновления. Первый шаг модифицирует структуру экземпляра, а,
именно, добавляет новые локальные и/или удаляет старые локальные
слоты, которые не были определены в новом классе. Второй шаг
инициализирует добавленные локальные слоты и выполняет некоторые
действия, определённые пользователем. Эти шаги описаны в следующих
разделах.
<!--l. 7989--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-29900028.1.11" id="x177-29900028.1.11">Модификация структуры экземпляра</a></h5>
<!--l. 7991--><p class="noindent" >Для того, согласовать экземпляр с классом <span class="math">C<sub>to</sub></span>, добавляются локальные
слоты, указанные в классе <span class="math">C<sub>to</sub></span>, но не указанные в <span class="math">C<sub>from</sub></span>, и удаляются
локальные слоты не определённые в <span class="math">C<sub>to</sub></span>, но определённые в <span class="math">C<sub>from</sub></span>.
                                                                          

                                                                          
<!--l. 7995--><p class="indent" >   Значения локальных слотов указанные и в классе <span class="math">C<sub>to</sub></span> и в классе <span class="math">C<sub>from</sub></span>
сохраняются как есть. Если такой локальный слот не связан с каким-либо
значение, он остаётся несвязанным.
<!--l. 7999--><p class="indent" >   Значения слотов, определённых в классе <span class="math">C<sub>from</sub></span> как разделяемые, и в
классе <span class="math">C<sub>to</sub></span> как локальные, остаются неизменными.
<!--l. 8002--><p class="indent" >   Данный первый шаг обновления экземпляра не затрагивает значения
каких-либо разделяемых слотов.
<!--l. 8005--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-30000028.1.11" id="x177-30000028.1.11">Инициализация вновь добавленных локальных слотов</a></h5>
<!--l. 8007--><p class="noindent" >Второй шаг обновления инициализируется вновь добавленные слоты и
выполняет другие пользовательские действия. Данный шаг реализован
обобщённой функцией <b><a 
href="symbols.html#x190-382990r990">update-instance-for-diﬀerent-class</a></b>. Обобщённая
функция <b><a 
href="symbols.html#x190-382990r990">update-instance-for-diﬀerent-class</a></b> вызывается функцией
<b><a 
href="symbols.html#x190-382214r214">change-class</a></b>, после того как завершается первый шаг обновления.
<!--l. 8013--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x190-382990r990">update-instance-for-diﬀerent-class</a></b> вызывается с
двумя аргументами, вычисленными в <b><a 
href="symbols.html#x190-382214r214">change-class</a></b>. Первый передаваемый
аргумент — копия обновляемого экземпляра, который принадлежит классу
<span class="math">C<sub>from</sub></span>. Данная копия имеет динамическую продолжительность видимости
внутри обобщённой функции <b><a 
href="symbols.html#x190-382214r214">change-class</a></b>. Второй аргумент — обновляемый
экземпляр класса <span class="math">C<sub>t</sub></span>.
<!--l. 8019--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x190-382990r990">update-instance-for-diﬀerent-class</a></b> также
принимает любое количество инициализационных аргументов. При вызове из
<b><a 
href="symbols.html#x190-382214r214">change-class</a></b> таких аргументов ни одного не указывается.
<!--l. 8023--><p class="indent" >   В системе установлен главный метод для <b><a 
href="symbols.html#x190-382990r990">update-instance-for-diﬀerent-class</a></b>,
у которого есть два специализатора параметров, каждый из которых
является классом <b>standard-object</b>. Сначала этот метод проверяет
корректность инициализационных аргументов и сигнализирует ошибку в
случае неудачи. Смотрите раздел <a 
href="#x177-28700028.1.9">28.1.9<!--tex4ht:ref: Declaring-the-Validity-of-Initialization-Arguments-SECTION --></a>. Затем он вызывает обобщённую
функцию <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b> со следующими аргументами: экземпляр класса,
список имён вновь добавленных слотов и принятые инициализационные
аргументы.
<!--l. 8033--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-30100028.1.11" id="x177-30100028.1.11">Настройка изменения класса экземпляра</a></h5>
                                                                          

                                                                          
<!--l. 8035--><p class="noindent" >Для указания действий, происходящих при обновлении экземпляра класса,
могут быть определены методы для <b><a 
href="symbols.html#x190-382990r990">update-instance-for-diﬀerent-class</a></b>.
Если для <b><a 
href="symbols.html#x190-382990r990">update-instance-for-diﬀerent-class</a></b> определены только <b>:around</b>
методы, они будут запущены после системного главного метода и не будут
влиять на поведение по-умолчанию <b><a 
href="symbols.html#x190-382990r990">update-instance-for-diﬀerent-class</a></b>. Так
как функция <b><a 
href="symbols.html#x190-382214r214">change-class</a></b> не передаёт в <b><a 
href="symbols.html#x190-382990r990">update-instance-for-diﬀerent-class</a></b>
инициализационные аргументы, формы <b>:initform</b> для слотов, которые были
заполнены в <b>:before</b> методах, для <b><a 
href="symbols.html#x190-382990r990">update-instance-for-diﬀerent-class</a></b>
вычисляться не будут.
<!--l. 8045--><p class="indent" >   Для настройки переопределения класса могут быть определены методы
для <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b> (смотрите раздел <a 
href="#x177-29000028.1.9">28.1.9<!--tex4ht:ref: Shared-Initialize-SECTION --></a>).
<!--l. 8048--><p class="noindent" >
   <h4 class="subsectionHead"><span class="titlemark">28.1.12   </span> <a 
href="frontmatter.html#QQ2-177-346" id="x177-30200028.1.12">Переинициализация экземпляра</a></h4>
<!--l. 8051--><p class="noindent" >Для изменения значений слотов в соответствии с инициализационными
аргументами может использоваться обобщённая функция <b><a 
href="symbols.html#x190-382794r794">reinitialize-instance</a></b>.
<!--l. 8054--><p class="indent" >   Процесс переинициализации изменяет значения некоторых слотов и
выполняет определённые пользователем действия.
<!--l. 8057--><p class="indent" >   Переинициализация не модифицирует структуру экземпляра класса, и
не используется какие-либо формы <b>:initform</b> для инициализации
слотов.
<!--l. 8060--><p class="indent" >   Обобщённая функция <b><a 
href="symbols.html#x190-382794r794">reinitialize-instance</a></b> может быть вызвана
напрямую. Она принимает один обязательный аргумент, экземпляр класса.
Она также принимает любое количество инициализационных аргументов для
их использования в методов <b><a 
href="symbols.html#x190-382794r794">reinitialize-instance</a></b> или для <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b>.
Аргументы после обязательного экземпляра класса, должны формировать
инициализирующий список аргументов.
<!--l. 8067--><p class="indent" >   В системе установлен главный метод для <b><a 
href="symbols.html#x190-382794r794">reinitialize-instance</a></b>, у
которого специализатором параметра является <b>standard-object</b>.
Сначала этот метод проверяет корректность инициализационных
аргументов и в случае некорректности сигнализирует ошибку (смотрите
раздел <a 
href="#x177-28700028.1.9">28.1.9<!--tex4ht:ref: Declaring-the-Validity-of-Initialization-Arguments-SECTION --></a>). Затем он вызывает обобщённую функцию <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b> со
следующими аргументами: экземпляр класса, <b><a 
href="symbols.html#x190-382670r670">nil</a></b>, и инициализационные
аргументы.
                                                                          

                                                                          
<!--l. 8075--><p class="noindent" >
   <h5 class="subsubsectionHead"><a 
href="#x177-30300028.1.12" id="x177-30300028.1.12">Настройка переинициализации</a></h5>
<!--l. 8077--><p class="noindent" >Для указания действий при обновлении экземпляра класса могут быть
определены методы для обобщённой функции <b><a 
href="symbols.html#x190-382794r794">reinitialize-instance</a></b>.
Если определены только <b>:after</b> методы, они будут выполнены после
установленного системой главного метода и таким образом не будут изменять
стандартного поведения <b><a 
href="symbols.html#x190-382794r794">reinitialize-instance</a></b>.
<!--l. 8083--><p class="indent" >   Для настройки переопределения класса могут быть определены методы
для <b><a 
href="symbols.html#x190-382849r849">shared-initialize</a></b>. Смотрите раздел <a 
href="#x177-29000028.1.9">28.1.9<!--tex4ht:ref: Shared-Initialize-SECTION --></a>.
                                                                          

                                                                          
<!--l. 8086--><p class="indent" >   <div id="bottomlinks">&#x003C;<a 
href="clmse145.html" >Далее</a>&#x003E;&#x003C;<a 
href="clos.html" >Назад</a>&#x003E;&#x003C;<a 
href="clos.html#tailclos.html" >Назад-и-вниз</a>&#x003E;&#x003C;<a 
href="clmse144.html" >В-начало</a>&#x003E;&#x003C;<a 
href="clos.html#clmse144.html" >Наверх</a>&#x003E;<br> &lt;<a href="../index.html">Главная</a>&gt; &lt;<a href="symbols.html">Символы</a>&gt;</div><a 
 id="tailclmse144.html"></a>
 
</body></html> 

%Part{KSeque, Root = "CLM.MSS"}
%%% Chapter of Common Lisp Manual.  Copyright 1984, 1988, 1989 Guy L. Steele Jr.

\clearpage\def\pagestatus{FINAL PROOF}

\ifx \rulang\Undef

\chapter{Sequences}
\label{KSEQUE}

The type \cdf{sequence} encompasses both lists and vectors (one-dimensional
arrays).
While these are different data structures with different structural
properties leading to different algorithmic uses, they do have a common
property: each contains an ordered set of elements.
Note that {\nil} is considered to be a sequence of length zero.

Some operations are useful on both lists and arrays
because they deal with ordered sets of elements.  One may ask the number
of elements, reverse the ordering, extract a subsequence, and so on.  For
such purposes Common Lisp provides a set of generic functions on sequences.

\begin{new}
Note that this remark, predating the design of the Common Lisp Object System,
uses the term ``generic'' in a generic sense, and not necessarily
in the technical sense used by CLOS
(see chapter~\ref{DTYPES}).
\end{new}

\begin{flushleft}
\cf
\begin{tabular*}{\textwidth}{@{}l@{\extracolsep{\fill}}lll@{}}
elt&reverse&map&remove \\
length&nreverse&some&remove-duplicates \\
subseq&concatenate&every&delete \\
copy-seq&position&notany&delete-duplicates \\
fill&find&notevery&substitute \\
replace&sort&reduce&nsubstitute \\
count&merge&search&mismatch
\end{tabular*}
\end{flushleft}
Some of these operations come in more than one version.
Such versions are indicated by adding a suffix (or occasionally a prefix)
to the basic name of the operation.
In addition, many operations accept one or more optional keyword
arguments that can modify the operation in various ways.

If the operation requires testing sequence elements according to
some criterion, then the criterion may be specified in one of two ways.
The basic operation accepts an item,
and elements are tested for being \cdf{eql} to that item.
(A test other than \cdf{eql} can be specified by the \cd{:test}
or \cd{:test-not} keyword.  It is an error to use both
of these keywords in the same call.)
The variants formed by adding \cdf{-if} and \cdf{-if-not}
to the basic operation name do not take an item,
but instead a one-argument predicate,
and elements are tested for satisfying or not satisfying the predicate.
As an example,
\begin{lisp}
(remove \emph{item} \emph{sequence})
\end{lisp}
returns a copy of \emph{sequence} from which all elements \cdf{eql} to \emph{item}
have been removed;
\begin{lisp}
(remove \emph{item} \emph{sequence} \cd{:test} \#'equal)
\end{lisp}
returns a copy of \emph{sequence} from which all elements \cdf{equal} to \emph{item}
have been removed;
\begin{lisp}
(remove-if \#'numberp \emph{sequence})
\end{lisp}
returns a copy of \emph{sequence} from which all numbers have been removed.

If an operation tests elements of a sequence in any manner,
the keyword argument \cd{:key}, if not {\false}, should be a function
of one argument that will extract from an element the part to be tested
in place of the whole element.
For example, the effect of the MacLisp expression
\cd{(assq item seq)} could be obtained by
\begin{lisp}
(find \emph{item} \emph{sequence} \cd{:test} \#'eq \cd{:key} \#'car)
\end{lisp}
This searches for the first element of \emph{sequence} whose \emph{car} is \cdf{eq}
to \emph{item}.
\begin{newer}
X3J13 voted in June 1988 \issue{FUNCTION-TYPE} to allow the \cd{:key} function
to be only of type \cdf{symbol} or \cdf{function}; a lambda-expression
is no longer acceptable as a functional argument.  One must use the
\cdf{function} special form or the abbreviation \cd{\#'} before
a lambda-expression that appears as an  explicit argument form.
\end{newer}

For some operations it can be useful to specify the direction
in which the sequence is conceptually processed.  In this case the basic
operation normally processes the sequence in the forward direction,
and processing in the reverse direction is indicated by a non-{\false}
value for the keyword argument \cd{:from-end}.  (The processing order
specified by the \cd{:from-end} is purely conceptual.  Depending on
the object to be processed and on the implementation, the actual processing
order may be different.  For this reason a user-supplied \emph{test} function
should be free of side effects.)

Many operations allow the specification of a subsequence to be operated
upon.  Such operations have keyword arguments
called \cd{:start} and \cd{:end}.  These arguments should be integer indices
into the sequence, with $\emph{start}\leq\emph{end}$
(it is an error if $\emph{start}>\emph{end}$).  They indicate
the subsequence starting with and \emph{including} element \emph{start}
and up to but \emph{excluding} element \emph{end}.  The length of the subsequence
is therefore $\emph{end}-\emph{start}$.  If \emph{start} is omitted,
it defaults to zero; and if \emph{end} is omitted or {\false}, it defaults to
the length of the sequence.
Therefore if both \emph{start} and \emph{end} are omitted, the entire sequence
is processed by default.
For the most part, subsequence specification
is permitted purely for the sake of efficiency;
one could simply call \cdf{subseq} instead to extract the subsequence
before operating on it.  Note, however, that operations that
calculate indices
return indices into the original sequence, not into the subsequence:
\begin{lisp}
(position \#{\Xbackslash}b "foobar" \cd{:start} 2 \cd{:end} 5) \EV\ 3 \\
(position \#{\Xbackslash}b (subseq "foobar" 2 5)) \EV\ 1
\end{lisp}
If two sequences are involved, then
the keyword arguments
\cd{:start1}, \cd{:end1}, \cd{:start2}, and \cd{:end2} are used to
specify separate subsequences for each sequence.

\begin{newer}
X3J13 voted in June 1988 \issue{SUBSEQ-OUT-OF-BOUNDS}
(and further clarification was voted in January 1989
\issue{RANGE-OF-START-AND-END-PARAMETERS})
to specify that these rules apply not
only to all built-in functions that have keyword parameters named
\cd{:start}, \cd{:start1}, \cd{:start2}, \cd{:end}, \cd{:end1},
or \cd{:end2} but also to functions such as \cdf{subseq}
that take required or optional parameters that are documented
as being named \emph{start} or \emph{end}.
\begin{itemize}
\item A ``start'' argument must always be a non-negative integer and
defaults to zero if not supplied; it is not permissible to pass \cdf{nil}
as a ``start'' argument.
\item An ``end'' argument must be either a
non-negative integer or \cdf{nil} (which indicates the end of the
sequence) and defaults to \cdf{nil}
if not supplied; therefore supplying \cdf{nil} is equivalent to
not supplying such an argument.
\item If the ``end'' argument is an integer, it must be no greater than the
active length of the corresponding sequence
(as returned by the function \cdf{length}).
\item The default value for the ``end'' argument is the active length
of the corresponding sequence.
\item The ``start'' value (after defaulting, if necessary) must not be greater than the
corresponding ``end'' value (after defaulting, if necessary).
\end{itemize}
This may be summarized as follows.
Let \emph{x} be the sequence within which indices are to be considered.  Let \emph{s} be
the ``start'' argument for that sequence of any standard function,
whether explicitly specified or defaulted, through omission, to
zero.  Let \emph{e} be the ``end'' argument for that sequence
of any standard function, whether explicitly specified or defaulted, through
omission or an explicitly passed \cdf{nil} value, to the active length of \emph{x}, as
returned by \cdf{length}.  Then it is an error if the test
\cd{(<=~0~\emph{s}~\emph{e}~(length \emph{x}))}
is not true.
\end{newer}

For some functions, notably \cdf{remove} and \cdf{delete}, the keyword argument
\cd{:count} is used to specify how many occurrences of the item should
be affected.  If this is {\false} or is not supplied, all matching items are
affected.

In the following function descriptions, an element \emph{x} of a sequence
``satisfies the test'' if any of the following holds:
\begin{itemize}
\item
A basic function was called,
\emph{testfn} was specified by the keyword \cd{:test}, and
\cd{(funcall \emph{testfn} \emph{item} (\emph{keyfn} \emph{x}))} is true.

\item
A basic function was called,
\emph{testfn} was specified by the keyword \cd{:test-not}, and
\cd{(funcall \emph{testfn} \emph{item} (\emph{keyfn} \emph{x}))} is false.

\item
An \cdf{-if} function was called, and
\cd{(funcall \emph{predicate} (\emph{keyfn} \emph{x}))} is true.

\item
An \cdf{-if-not} function was called, and
\cd{(funcall \emph{predicate} (\emph{keyfn} \emph{x}))} is false.
\end{itemize}
In each case \emph{keyfn} is the
value of the \cd{:key} keyword argument (the default being the identity
function).  See, for example, \cdf{remove}.

In the following function descriptions,
two elements \emph{x} and \emph{y} taken from sequences ``match'' if
either of the following holds:
\begin{itemize}
\item
\emph{testfn} was specified by the keyword \cd{:test}, and
\cd{(funcall \emph{testfn} (\emph{keyfn} \emph{x}) (\emph{keyfn} \emph{y}))} is true.

\item
\emph{testfn} was specified by the keyword \cd{:test-not}, and
\cd{(funcall \emph{testfn} (\emph{keyfn} \emph{x}) (\emph{keyfn} \emph{y}))} is false.
\end{itemize}
See, for example, \cdf{search}.


\begin{newer}
X3J13 voted in June 1988 \issue{FUNCTION-TYPE} to allow the \emph{testfn}
or \cdf{predicate}
to be only of type \cdf{symbol} or \cdf{function}; a lambda-expression
is no longer acceptable as a functional argument.  One must use the
\cdf{function} special form or the abbreviation \cd{\#'} before
a lambda-expression that appears as an  explicit argument form.
\end{newer}

You may depend on the order in which arguments
are given to \emph{testfn}; this permits the use of non-commutative
test functions in a predictable manner.
The order of the arguments to \emph{testfn} corresponds
to the order in which those arguments (or the sequences containing
those arguments)
were given to the sequence function in question.
If a sequence function gives two elements from the same
sequence argument to \emph{testfn}, they are given in the same order in
which they appear in the sequence.

Whenever a sequence function must construct and return
a new vector, it always returns a \emph{simple}
vector (see section~\ref{ARRAY-TYPE-SECTION}).
Similarly, any strings constructed will be simple strings.

\begin{new}
X3J13 voted in January 1989
\issue{TEST-NOT-IF-NOT}
to \emph{deprecate} the use of \cd{:test-not} keyword arguments
and \cdf{-if-not} functions. This means that these features are very
likely to be retained in the forthcoming standard but are regarded as
candidates for removal in a future revision of the ANSI standard.
X3J13 also voted in January 1989
\issue{FUNCTION-COMPOSITION}
to add the \cdf{complement} function, intended to reduce or eliminate the
need for these deprecated features.  Time will tell.  I note that
many features in Fortran have been deprecated but very few indeed
have actually been removed or altered incompatibly.

\begin{defun}[Function]
complement fn

Returns a function whose value is the same as that of \cdf{not}
applied to the result of applying the function \emph{fn} to the same
arguments.  One could define \cdf{complement} as follows:
\begin{lisp}
(defun complement (fn) \\*
~~\#'(lambda (\&rest arguments) \\*
~~~~~~(not (apply fn arguments))))
\end{lisp}

One intended use of \cdf{complement} is to supplant the use of
\cd{:test-not} arguments and \cdf{-if-not} functions.
\begin{lisp}
(remove-if-not \#'virtuous senators) {\EQ} \\*
~~~(remove-if (complement \#'virtuous) senators) \\
\\
(remove-duplicates telephone-book \\*
~~~~~~~~~~~~~~~~~~~:test-not \#'mismatch) {\EQ} \\*
~~~(remove-duplicates telephone-book \\*
~~~~~~~~~~~~~~~~~~~~~~:test (complement \#'mismatch))
\end{lisp}
\end{defun}
\end{new}

\section{Simple Sequence Functions}

Most of the following functions perform simple operations on a single
sequence; \cdf{make-sequence} constructs a new sequence.

\begin{defun}[Function]
elt sequence index

This returns the element of \emph{sequence} specified by \emph{index},
which must be a non-negative integer less than the length of the \emph{sequence}
as returned by \cdf{length}.
The first element of a sequence has index \cd{0}.

(Note that \cdf{elt} observes the fill pointer in those vectors that have
fill pointers.  The array-specific function \cdf{aref} may be used
to access vector elements that are beyond the vector's fill pointer.)

\cdf{setf} may be used with \cdf{elt} to destructively replace
a sequence element with a new value.
\end{defun}

\begin{defun}[Function]
subseq sequence start &optional end

This returns the subsequence of \emph{sequence} specified by \emph{start} and
\emph{end}.
\cdf{subseq} \emph{always} allocates a new sequence for a result; it never
shares storage with an old sequence.  The result subsequence is always of
the same type as the argument \emph{sequence}.

\cdf{setf} may be used with \cdf{subseq} to destructively replace
a subsequence with a sequence of new values; see also \cdf{replace}.
\end{defun}

\begin{defun}[Function]
copy-seq sequence

A copy is made of the argument \emph{sequence}; the result is \cdf{equalp}
to the argument but not \cdf{eq} to it.
\begin{lisp}
(copy-seq \emph{x}) \EQ\ (subseq \emph{x} 0)
\end{lisp}
but the name \cdf{copy-seq} is more perspicuous when applicable.
\end{defun}

\begin{defun}[Function]
length sequence

The number of elements in \emph{sequence} is returned as a non-negative integer.
If the sequence is a vector with a fill pointer,
the ``active length'' as specified by the fill pointer is returned
(see section~\ref{FILL-POINTER}).
\end{defun}

\begin{defun}[Function]
reverse sequence

The result is a new sequence of the same kind as \emph{sequence},
containing the same elements but in reverse order.
The argument is not modified.
\end{defun}

\begin{defun}[Function]
nreverse sequence

The result is a sequence containing the same elements as \emph{sequence}
but in reverse order.  The argument may be destroyed and re-used to
produce the result.  The result may or may not be \cdf{eq} to the
argument, so it is usually wise to say something like
\cd{(setq x (nreverse x))}, because simply \cd{(nreverse x)} is not
guaranteed to leave a reversed value in \cdf{x}.
\begin{newer}
X3J13 voted in March 1989 \issue{REMF-DESTRUCTION-UNSPECIFIED}
to clarify the permissible side effects of certain operations.
When the \emph{sequence} is a list,
\cdf{nreverse} is permitted to perform a \cdf{setf} on any part,
\emph{car} or \emph{cdr}, of the top-level list structure of that list.
When the \emph{sequence} is an array,
\cdf{nreverse} is permitted to re-order the elements of the given array
in order to produce the resulting array.
\end{newer}
\end{defun}

\begin{defun}[Function]
make-sequence type size &key :initial-element

This returns a sequence of type \emph{type} and of length \emph{size}, each of
whose elements
has been initialized to the \cd{:initial-element} argument.
If specified, the \cd{:initial-element} argument must be an object that
can be an element of a sequence of type \emph{type}.
For example:
\begin{lisp}
(make-sequence '(vector double-float) \\*
~~~~~~~~~~~~~~~100 \\*
~~~~~~~~~~~~~~~:initial-element 1d0)
\end{lisp}
If an \cd{:initial-element} argument is not specified, then the sequence will
be initialized in an implementation-dependent way.

\begin{new}
X3J13 voted in January 1989
\issue{ARGUMENTS-UNDERSPECIFIED}
to clarify that the \emph{type} argument
must be a type specifier, and the \emph{size} argument
must be a non-negative integer less than the value of
\cdf{array-dimension-limit}.
\end{new}

\begin{newer}
X3J13 voted in June 1989 \issue{SEQUENCE-TYPE-LENGTH} to specify that
\cdf{make-sequence} should signal an error if the sequence \emph{type} specifies the
number of elements and the \emph{size} argument is different.
\end{newer}

\begin{newer}
X3J13 voted in March 1989 \issue{CHARACTER-PROPOSAL}
to specify that if \emph{type} is \cdf{string}, the result is the same
as if \cdf{make-string} had been called with the same \emph{size}
and \cd{:initial-element} arguments.
\end{newer}
\end{defun}

\section{Concatenating, Mapping, and Reducing Sequences}

The functions in this section each operate on an arbitrary number of
sequences except for \cdf{reduce}, which is included here because
of its conceptual relationship to the mapping functions.

\begin{defun}[Function]
concatenate result-type &rest sequences

The result is a new sequence that contains all the elements of all the
sequences in order.  All of the sequences are copied from; the result
does not share any structure with any of the argument sequences (in this
\cdf{concatenate} differs from \cdf{append}).  The type of the result is
specified by \emph{result-type}, which must be a subtype of \cdf{sequence},
as for the function \cdf{coerce}.
It must be possible for every element of the argument sequences to be an
element of a sequence of type \emph{result-type}.

If only one \emph{sequence} argument is provided
and it has the type specified by \emph{result-type},
\cdf{concatenate} is required to copy the argument rather than simply
returning it.  If a copy is not required, but only possibly type conversion,
then the \cdf{coerce} function may be appropriate.

\begin{newer}
X3J13 voted in June 1989 \issue{SEQUENCE-TYPE-LENGTH} to specify that
\cdf{concatenate} should signal an error if the sequence type specifies the
number of elements and the sum of the argument lengths is different.
\end{newer}
\end{defun}

\begin{defun}[Function]
map result-type function sequence &rest more-sequences

The \emph{function} must take as many arguments as there are sequences
provided; at least one sequence must be provided.
The result of \cdf{map} is a sequence such that element \emph{j} is the result
of applying \emph{function} to element \emph{j} of each of the argument
sequences.  The result sequence is as long as the shortest of the
input sequences.

If the \emph{function} has side effects, it can count on being called
first on all the elements numbered \cd{0}, then on all those
numbered \cd{1}, and so on.

The type of the result sequence is specified by the argument \emph{result-type}
(which must be a subtype of the type \cdf{sequence}),
as for the function \cdf{coerce}.
In addition, one may specify {\nil} for the result type, meaning that no
result sequence is to be produced; in this case the \emph{function} is invoked
only for effect, and \cdf{map} returns {\nil}.  This gives an effect similar
to that of \cdf{mapc}.

\begin{newer}
X3J13 voted in June 1989 \issue{SEQUENCE-TYPE-LENGTH} to specify that
\cdf{map} should signal an error if the sequence type specifies the number of
elements and the minimum of the argument lengths is different.
\end{newer}

\begin{new}
X3J13 voted in January 1989
\issue{MAPPING-DESTRUCTIVE-INTERACTION}
to restrict user side effects; see section~\ref{STRUCTURE-TRAVERSAL-SECTION}.
\end{new}

\beforenoterule
\begin{incompatibility}
In MacLisp, Lisp Machine Lisp, Interlisp, and indeed even
Lisp 1.5, the function \cdf{map} has always meant a non-value-returning
version.  However, standard computer science literature, including
in particular
the recent wave of papers on ``functional programming,'' have come
to use \cdf{map} to mean
what in the past Lisp implementations have called \cdf{mapcar}.
To simplify things henceforth, Common Lisp follows current usage,
and what was formerly called \cdf{map} is named \cdf{mapl} in Common Lisp.
\end{incompatibility}
\afternoterule

\noindent
For example:
\begin{lisp}
(map 'list \#'- '(1 2 3 4)) \EV\ (-1 -2 -3 -4) \\
(map 'string \\
~~~~~\#'(lambda (x) (if (oddp x) \#{\Xbackslash}1 \#{\Xbackslash}0)) \\
~~~~~'(1 2 3 4)) \\
~~~\EV\ "1010"
\end{lisp}
\end{defun}


\begin{defun}[Function]
map-into result-sequence function &rest sequences

Function \cdf{map-into} destructively modifies the \emph{result-sequence} to
contain the results of applying \emph{function} to corresponding elements of
    the argument \emph{sequences} in turn; it then
    returns \emph{result-sequence}.

    The arguments \emph{result-sequence}
    and each element of \emph{sequences} can each be
    either a list or a vector (one-dimensional array).
    The \emph{function} must accept at least as many arguments as the
    number of argument \emph{sequences} supplied to \cdf{map-into}.
    If \emph{result-sequence} and
    the other argument \emph{sequences} are not all the same length, the iteration
    terminates when the shortest sequence is exhausted.  If \emph{result-sequence}
    is a vector with a fill pointer, the fill pointer is ignored when
    deciding how many iterations to perform, and afterwards the
    fill pointer is set to the number of times the \emph{function} was applied.

If the \emph{function} has side effects, it can count on being called
first on all the elements numbered \cd{0}, then on all those
numbered \cd{1}, and so on.

    If \emph{result-sequence} is longer than the shortest element of \emph{sequences},
    extra elements at the end of \emph{result-sequence} are unchanged.

    The function \cdf{map-into} differs from \cdf{map} in that it modifies
an existing sequence rather than creating a new one.  In addition,
\cdf{map-into} can be called with only two arguments (\emph{result-sequence}
and \emph{function}), while \cdf{map} requires at least three arguments.

If \emph{result-sequence} is \cdf{nil}, \cdf{map-into} immediately returns
\cdf{nil}, because \cdf{nil} is a sequence of length zero.
\end{defun}


\begin{defun}[Function]
some predicate sequence &rest more-sequences \\
every predicate sequence &rest more-sequences \\
notany predicate sequence &rest more-sequences \\
notevery predicate sequence &rest more-sequences

These are all predicates.
The \emph{predicate} must take as many arguments as there are sequences
provided.  The \emph{predicate} is first applied to the elements
with index \cd{0} in each of the sequences, and possibly then to
the elements with index \cd{1}, and so on, until a termination
criterion is met or the end of the shortest of the \emph{sequences} is reached.

If the \emph{predicate} has side effects, it can count on being called
first on all the elements numbered \cd{0}, then on all those
numbered \cd{1}, and so on.

\cdf{some} returns as soon as any invocation of \emph{predicate}
returns a non-{\false} value; \cdf{some} returns that value.
If the end of a sequence is reached, \cdf{some} returns {\false}.
Thus, considered as a predicate, it is true if \emph{some} invocation of
\emph{predicate} is true.

\cdf{every} returns {\false} as soon as any invocation of \emph{predicate}
returns {\false}.
If the end of a sequence is reached, \cdf{every} returns a non-{\false} value.
Thus, considered as a predicate, it is true if \emph{every} invocation of
\emph{predicate} is true.

\cdf{notany} returns {\false} as soon as any invocation of \emph{predicate}
returns a non-{\false} value.
If the end of a sequence is reached, \cdf{notany} returns a non-{\false} value.
Thus, considered as a predicate, it is true if \emph{no} invocation of
\emph{predicate} is true.

\cdf{notevery} returns a non-{\false} value as soon as any invocation
of \emph{predicate} returns {\false}.  If the end of a sequence is reached,
\cdf{notevery} returns
{\false}.  Thus, considered as a predicate, it is true if \emph{not every} invocation of
\emph{predicate} is true.

\begin{new}
X3J13 voted in January 1989
\issue{MAPPING-DESTRUCTIVE-INTERACTION}
to restrict user side effects; see section~\ref{STRUCTURE-TRAVERSAL-SECTION}.
\end{new}

\beforenoterule
\begin{incompatibility}
The order of the arguments here is not compatible
with Interlisp and Lisp Machine Lisp.  This is to stress the similarity
of these functions to \cdf{map}.  The functions are therefore extended
here to functions of more than one argument, and to multiple sequences.
\end{incompatibility}
\afternoterule
\end{defun}

\begin{defun}[Function]
reduce function sequence &key :from-end :start :end :initial-value

The \cdf{reduce} function combines all the elements of a sequence using
a binary operation; for example, using \cdf{+} one can add up all the
elements.

The specified subsequence of the \emph{sequence} is combined
or ``reduced'' using the
\emph{function}, which must accept two arguments.  The reduction is
left-associative, unless the \cd{:from-end} argument is true (it defaults
to {\nil}), in which case it is right-associative.  If an
\cd{:initial-value} argument is given, it is logically placed before the
subsequence (after it if \cd{:from-end} is true) and included in the
reduction operation.

If the specified subsequence contains exactly one element
and the keyword argument \cd{:initial-value}
is not given, then that element
is returned and the \emph{function} is not called.
If the specified subsequence is empty and an \cd{:initial-value} is given,
then the \cd{:initial-value} is returned
and the \emph{function} is not called.

If the specified subsequence is empty and no \cd{:initial-value} is given,
then the \emph{function} is called with zero
arguments, and \cdf{reduce} returns whatever the function does.  (This is
the only case where the \emph{function} is called with other than two
arguments.)

\begin{lisp}
(reduce \#'+ '(1 2 3 4)) \EV\ 10 \\
(reduce \#'- '(1 2 3 4)) \EQ\ (- (- (- 1 2) 3) 4) \EV\ -8 \\
(reduce \#'- '(1 2 3 4) :from-end t)~~~~~;\textrm{Alternating sum} \\
~~~\EQ\ (- 1 (- 2 (- 3 4))) \EV\ -2 \\
(reduce \#'+ '()) \EV\ 0 \\
(reduce \#'+ '(3)) \EV\ 3 \\
(reduce \#'+ '(foo)) \EV\ foo \\
(reduce \#'list '(1 2 3 4)) \EV\ (((1 2) 3) 4) \\
(reduce \#'list '(1 2 3 4) :from-end t) \EV\ (1 (2 (3 4))) \\
(reduce \#'list '(1 2 3 4) :initial-value 'foo) \\
~~~\EV\ ((((foo 1) 2) 3) 4) \\
(reduce \#'list '(1 2 3 4) \\
~~~~~~~~:from-end t :initial-value 'foo) \\
~~~\EV\ (1 (2 (3 (4 foo))))
\end{lisp}
If the \emph{function} produces side effects, the order of the calls
to the \emph{function} can be correctly predicted from the reduction ordering
demonstrated above.

The name ``reduce'' for this function is borrowed from {APL}.

\begin{new}
X3J13 voted in March 1988 \issue{REDUCE-ARGUMENT-EXTRACTION}
to extend the \cdf{reduce} function to take
an additional keyword argument named \cd{:key}.  As usual, this argument
defaults to the identity function.  The value of this argument must be
a function that accepts at least one argument.  This function is applied once
to each element of the
sequence that is to participate in the reduction operation, in the order
implied by the \cd{:from-end} argument; the values returned by this
function are combined by the reduction \emph{function}.
However, the \cd{:key} function is \emph{not} applied
to the \cd{:initial-value} argument (if any).
\end{new}

\begin{new}
X3J13 voted in January 1989
\issue{MAPPING-DESTRUCTIVE-INTERACTION}
to restrict user side effects; see section~\ref{STRUCTURE-TRAVERSAL-SECTION}.
\end{new}
\end{defun}

\section{Modifying Sequences}

Each of these functions alters the contents of a sequence or produces
an altered copy of a given sequence.

\begin{defun}[Function]
fill sequence item &key :start :end

The \emph{sequence} is destructively modified by replacing each element of
the subsequence specified by the \cd{:start} and \cd{:end} parameters
with the \emph{item}.  The \emph{item} may be any Lisp object but must be a
suitable element for the \emph{sequence}.  The \emph{item} is stored into all
specified components of the \emph{sequence}, beginning at the one specified
by the \cd{:start} index (which defaults to zero), up to but not
including the one specified by the \cd{:end} index (which defaults to the
length of the sequence).  \cdf{fill} returns the modified \emph{sequence}.
For example:
\begin{lisp}
(setq x (vector 'a 'b 'c 'd 'e)) \EV\ \#(a b c d e) \\
(fill x 'z \cd{:start} 1 \cd{:end} 3) \EV\ \#(a z z d e) \\
~~\textrm{and now} x \EV\ \#(a z z d e) \\
(fill x 'p) \EV\ \#(p p p p p) \\
~~\textrm{and now} x \EV\ \#(p p p p p)
\end{lisp}
\end{defun}

\begin{defun}[Function]
replace sequence1 sequence2 &key :start1 :end1 :start2~:end2

The sequence \emph{sequence1} is destructively modified by copying successive
elements into it from \emph{sequence2}.  The elements of
\emph{sequence2} must be of a type that may be stored into
\emph{sequence1}.  The subsequence of \emph{sequence2}
specified by \cd{:start2} and \cd{:end2} is copied into the
subsequence of \emph{sequence1} specified by \cd{:start1} and \cd{:end1}.
(The arguments \cd{:start1} and \cd{:start2} default to zero.
The arguments \cd{:end1} and \cd{:end2} default
to {\false}, meaning the end of the appropriate sequence.)
If these subsequences are not of the same length, then
the shorter length determines how many elements are copied; the extra
elements near the end of the longer subsequence are not involved in the
operation.
The number of elements copied may be expressed as:
\begin{lisp}
(min (- \emph{end1} \emph{start1}) (- \emph{end2} \emph{start2}))
\end{lisp}
The value returned by \cdf{replace} is the modified \emph{sequence1}.

If \emph{sequence1} and \emph{sequence2} are the same (\cdf{eq}) object
and the region being modified overlaps the region being copied
from, then it is as if the entire source region were copied to another
place and only then copied back into the target region.
However, if \emph{sequence1} and \emph{sequence2} are \emph{not} the same,
but the region being modified overlaps the region being copied from
(perhaps because of shared list structure or displaced arrays),
then after the \cdf{replace} operation
the subsequence of \emph{sequence1} being modified will have
unpredictable contents.
\end{defun}

\begin{defun}[Function]
remove item sequence &key :from-end :test :test-not :start :end :count :key \\
remove-if predicate sequence &key :from-end :start :end :count :key \\
remove-if-not predicate sequence &key :from-end :start :end :count :key

The result is a sequence of the same kind as the argument \emph{sequence}
that has the same elements except that those in the subsequence
delimited by \cd{:start} and \cd{:end} and satisfying the test (see
above) have been removed.  This is a non-destructive operation; the result
is a copy of the input \emph{sequence}, save that some elements are not
copied.  Elements not removed occur in the same order in the result
as they did in the argument.

The \cd{:count} argument, if supplied, limits the number of elements
removed; if more than \cd{:count} elements satisfy the test,
then of these elements only the leftmost are removed,
as many as specified by \cd{:count}.

\begin{new}
X3J13 voted in January 1989
\issue{RANGE-OF-COUNT-KEYWORD}
to clarify that the \cd{:count} argument must be either \cdf{nil}
or an integer, and that supplying a negative integer produces the
same behavior as supplying zero.
\end{new}

A non-{\false} \cd{:from-end} specification
matters only when the \cd{:count} argument
is provided; in that case only the rightmost \cd{:count} elements satisfying
the test are removed.
For example:
\begin{lisp}
(remove 4 '(1 2 4 1 3 4 5)) \EV\ (1 2 1 3 5) \\
(remove 4 '(1 2 4 1 3 4 5) \cd{:count} 1) \EV\ (1 2 1 3 4 5) \\
(remove 4 '(1 2 4 1 3 4 5) \cd{:count} 1 \cd{:from-end} t) \\
~~~\EV\ (1 2 4 1 3 5) \\
(remove 3 '(1 2 4 1 3 4 5) \cd{:test} \#'>) \EV\ (4 3 4 5) \\
(remove-if \#'oddp '(1 2 4 1 3 4 5)) \EV\ (2 4 4) \\
(remove-if \#'evenp '(1 2 4 1 3 4 5) \cd{:count} 1 \cd{:from-end} t) \\
~~~\EV\ (1 2 4 1 3 5)
\end{lisp}
The result of \cdf{remove} may share
with the argument \emph{sequence}; a list result may share a tail
with an input list, and the result may be \cdf{eq} to the input \emph{sequence}
if no elements need to be removed.

\begin{new}
X3J13 voted in January 1989
\issue{MAPPING-DESTRUCTIVE-INTERACTION}
to restrict user side effects; see section~\ref{STRUCTURE-TRAVERSAL-SECTION}.
\end{new}
\end{defun}

\begin{defun}[Function]
delete item sequence &key :from-end :test :test-not :start~:end~:count~:key \\
delete-if predicate sequence &key :from-end :start~:end~:count~:key \\
delete-if-not predicate sequence &key :from-end :start~:end~:count~:key

This is the destructive counterpart to \cdf{remove}.
The result is a sequence of the same kind as the argument \emph{sequence}
that has the same elements except that those in the subsequence
delimited by \cd{:start} and \cd{:end} and satisfying the test (see
above) have been deleted.  This is a destructive operation.
The argument \emph{sequence} may be destroyed and used to construct
the result; however, the result may or may not be \cdf{eq} to \emph{sequence}.
Elements not deleted occur in the same order in the result
as they did in the argument.

The \cd{:count} argument, if supplied, limits the number of elements
deleted; if more than \cd{:count} elements satisfy the test,
then of these elements only the leftmost are deleted,
as many as specified by \cd{:count}.

\begin{new}
X3J13 voted in January 1989
\issue{RANGE-OF-COUNT-KEYWORD}
to clarify that the \cd{:count} argument must be either \cdf{nil}
or an integer, and that supplying a negative integer produces the
same behavior as supplying zero.
\end{new}

A non-{\false} \cd{:from-end} specification
matters only when the \cd{:count} argument
is provided; in that case only the rightmost \cd{:count} elements satisfying
the test are deleted.
For example:
\begin{lisp}
(delete 4 '(1 2 4 1 3 4 5)) \EV\ (1 2 1 3 5) \\
(delete 4 '(1 2 4 1 3 4 5) \cd{:count} 1) \EV\ (1 2 1 3 4 5) \\
(delete 4 '(1 2 4 1 3 4 5) \cd{:count} 1 \cd{:from-end} t) \\
~~~\EV\ (1 2 4 1 3 5) \\
(delete 3 '(1 2 4 1 3 4 5) \cd{:test} \#'>) \EV\ (4 3 4 5) \\
(delete-if \#'oddp '(1 2 4 1 3 4 5)) \EV\ (2 4 4) \\
(delete-if \#'evenp '(1 2 4 1 3 4 5) \cd{:count} 1 \cd{:from-end} t) \\
~~~\EV\ (1 2 4 1 3 5)
\end{lisp}

\begin{new}
X3J13 voted in January 1989
\issue{MAPPING-DESTRUCTIVE-INTERACTION}
to restrict user side effects; see section~\ref{STRUCTURE-TRAVERSAL-SECTION}.
\end{new}

\begin{newer}
X3J13 voted in March 1989 \issue{REMF-DESTRUCTION-UNSPECIFIED}
to clarify the permissible side effects of certain operations.
When the \emph{sequence} is a list,
\cdf{delete} is permitted to perform a \cdf{setf} on any part,
\emph{car} or \emph{cdr}, of the top-level list structure of that list.
When the \emph{sequence} is an array,
\cdf{delete} is permitted to alter the dimensions of the given array
and to slide some of its elements into new positions without permuting them
in order to produce the resulting array.

Furthermore, \cd{(delete-if \emph{predicate} \emph{sequence}~...)}
is required to behave exactly like
\begin{lisp}
(delete nil \emph{sequence} \\*
~~~~~~~~:test \#'(lambda (unused item) \\*
~~~~~~~~~~~~~~~~~~~(declare (ignore unused)) \\*
~~~~~~~~~~~~~~~~~~~(funcall \emph{predicate} item)) \\*
~~~~~~~~...)
\end{lisp}
\end{newer}

\beforenoterule
\begin{incompatibility}
In MacLisp, the \cdf{delete} function uses
an \cdf{equal} comparison rather than \cdf{eql}, which is the default
test for \cdf{delete} in Common Lisp.  Where in MacLisp one would write
\cd{(delete x y)}, one must in Common Lisp write \cd{(delete x y :test \#'equal)}
to get the completely identical effect.  Similarly, one can get the
precise effect, and no more, of the MacLisp \cd{(delq x y)}
by writing in Common Lisp \cd{(delete x y :test \#'eq)}.
\end{incompatibility}
\afternoterule
\end{defun}

\begin{defun}[Function]
remove-duplicates sequence &key :from-end :test :test-not :start :end :key \\
delete-duplicates sequence &key :from-end :test :test-not :start :end :key

The elements of \emph{sequence} are compared pairwise, and if any two match,
then the one occurring earlier in the sequence
is discarded (but if the \cd{:from-end} argument is true, then the one
later in the sequence is discarded).
The result is a sequence of the same kind as the
argument sequence with enough elements removed so that no two of the remaining
elements match.  The order of the elements remaining in the result
is the same as the order in which they appear in \emph{sequence}.

\cdf{remove-duplicates} is the non-destructive version
of this operation.
The result of \cdf{remove-duplicates} may share
with the argument \emph{sequence}; a list result may share a tail
with an input list, and the result may be \cdf{eq} to the input \emph{sequence}
if no elements need to be removed.

\cdf{delete-duplicates} may destroy the argument \emph{sequence}.

Some examples:
\begin{lisp}
(remove-duplicates '(a b c b d d e)) \EV\ (a c b d e) \\
(remove-duplicates '(a b c b d d e) \cd{:from-end} t) \EV\ (a b c d e) \\
(remove-duplicates '((foo \#{\Xbackslash}a) (bar \#{\Xbackslash}\%) (baz \#{\Xbackslash}A)) \\
~~~~~~~~~~~~~~~~~~~\cd{:test} \#'char-equal \cd{:key} \#'cadr) \\
~~~\EV\ ((bar \#{\Xbackslash}\%) (baz \#{\Xbackslash}A)) \\
(remove-duplicates '((foo \#{\Xbackslash}a) (bar \#{\Xbackslash}\%) (baz \#{\Xbackslash}A)) \\
~~~~~~~~~~~~~~~~~~~\cd{:test} \#'char-equal \cd{:key} \#'cadr \cd{:from-end} t) \\
~~~\EV\ ((foo \#{\Xbackslash}a) (bar \#{\Xbackslash}\%))
\end{lisp}

These functions are useful for converting a sequence into a canonical
form suitable for representing a set.

\begin{new}
X3J13 voted in January 1989
\issue{MAPPING-DESTRUCTIVE-INTERACTION}
to restrict user side effects; see section~\ref{STRUCTURE-TRAVERSAL-SECTION}.
\end{new}

\begin{newer}
X3J13 voted in March 1989 \issue{REMF-DESTRUCTION-UNSPECIFIED}
to clarify the permissible side effects of certain operations.
When the \emph{sequence} is a list,
\cdf{delete-duplicates} is permitted to perform a \cdf{setf} on any part,
\emph{car} or \emph{cdr}, of the top-level list structure of that list.
When the \emph{sequence} is an array,
\cdf{delete-duplicates} is permitted to alter the dimensions of the given array
and to slide some of its elements into new positions without permuting them
in order to produce the resulting array.
\end{newer}
\end{defun}

\begin{defun}[Function]
substitute newitem olditem sequence &key :from-end :test :test-not :start :end :count :key \\
substitute-if newitem test sequence &key :from-end :start~:end :count :key \\
substitute-if-not newitem test sequence &key :from-end :start :end :count :key

The result is a sequence of the same kind as the argument \emph{sequence}
that has the same elements except that those in the subsequence
delimited by \cd{:start} and \cd{:end} and satisfying the test (see
above) have been replaced by \emph{newitem}.  This is a non-destructive
operation; the result is a copy of the input \emph{sequence}, save that some
elements are changed.

The \cd{:count} argument, if supplied, limits the number of elements
altered; if more than \cd{:count} elements satisfy the test,
then of these elements only the leftmost are replaced,
as many as specified by \cd{:count}.

\begin{new}
X3J13 voted in January 1989
\issue{RANGE-OF-COUNT-KEYWORD}
to clarify that the \cd{:count} argument must be either \cdf{nil}
or an integer, and that supplying a negative integer produces the
same behavior as supplying zero.
\end{new}

A non-{\false} \cd{:from-end} specification
matters only when the \cd{:count} argument
is provided; in that case only the rightmost \cd{:count} elements satisfying
the test are replaced.
For example:
\begin{lisp}
(substitute 9 4 '(1 2 4 1 3 4 5)) \EV\ (1 2 9 1 3 9 5) \\
(substitute 9 4 '(1 2 4 1 3 4 5) \cd{:count} 1) \EV\ (1 2 9 1 3 4 5) \\
(substitute 9 4 '(1 2 4 1 3 4 5) \cd{:count} 1 \cd{:from-end} t) \\
~~~\EV\ (1 2 4 1 3 9 5) \\
(substitute 9 3 '(1 2 4 1 3 4 5) \cd{:test} \#'>) \EV\ (9 9 4 9 3 4 5) \\
(substitute-if 9 \#'oddp '(1 2 4 1 3 4 5)) \EV\ (9 2 4 9 9 4 9) \\
(substitute-if 9 \#'evenp '(1 2 4 1 3 4 5) \cd{:count} 1 \cd{:from-end} t) \\
~~~\EV\ (1 2 4 1 3 9 5)
\end{lisp}
The result of \cdf{substitute} may share
with the argument \emph{sequence}; a list result may share a tail
with an input list, and the result may be \cdf{eq} to the input \emph{sequence}
if no elements need to be changed.

See also \cdf{subst}, which performs substitutions throughout a tree.

\begin{new}
X3J13 voted in January 1989
\issue{MAPPING-DESTRUCTIVE-INTERACTION}
to restrict user side effects; see section~\ref{STRUCTURE-TRAVERSAL-SECTION}.
\end{new}
\end{defun}

\begin{defun}[Function]
nsubstitute newitem olditem sequence &key :from-end :test :test-not :start :end :count :key \\
nsubstitute-if newitem test sequence &key :from-end :start~:end :count :key \\
nsubstitute-if-not newitem test sequence &key :from-end :start :end :count :key

This is the destructive counterpart to \cdf{substitute}.
The result is a sequence of the same kind as the argument \emph{sequence}
that has the same elements except that those in the subsequence
delimited by \cd{:start} and \cd{:end} and satisfying the test (see
above) have been replaced by \emph{newitem}.  This is a destructive operation.
The argument \emph{sequence} may be destroyed and used to construct
the result; however, the result may or may not be \cdf{eq} to \emph{sequence}.

See also \cdf{nsubst}, which performs destructive
substitutions throughout a tree.
\begin{new}
X3J13 voted in January 1989
\issue{MAPPING-DESTRUCTIVE-INTERACTION}
to restrict user side effects; see section~\ref{STRUCTURE-TRAVERSAL-SECTION}.
\end{new}

\begin{newer}
X3J13 voted in March 1989 \issue{REMF-DESTRUCTION-UNSPECIFIED}
to clarify the permissible side effects of certain operations.
When the \emph{sequence} is a list,
\cdf{nsubstitute} or \cdf{nsubstitute-if}
is required to perform a \cdf{setf} on any
\emph{car} of the top-level list structure of that list
whose old contents must be replaced with \emph{newitem}
but is forbidden to perform a \cdf{setf} on any \cdf{cdr} of the list.
When the \emph{sequence} is an array,
\cdf{nsubstitute} or \cdf{nsubstitute-if}
is required to perform a \cdf{setf} on any element of the array
whose old contents must be replaced with \emph{newitem}.
These functions, therefore, may successfully be
used solely for effect, the caller discarding the returned value
(though some programmers find this stylistically distasteful).
\end{newer}
\end{defun}

\section{Searching Sequences for Items}

Each of these functions searches a sequence to locate one or more
elements satisfying some test.

\begin{defun}[Function]
find item sequence &key :from-end :test :test-not :start~:end :key \\
find-if predicate sequence &key :from-end :start :end :key \\
find-if-not predicate sequence &key :from-end :start~:end~:key

If the \emph{sequence} contains an element satisfying the test,
then the leftmost such element
is returned; otherwise {\false} is returned.

If \cd{:start} and \cd{:end} keyword arguments are given,
only the specified subsequence of \emph{sequence} is searched.

If a non-{\false} \cd{:from-end} keyword argument is specified, then the result is
the \emph{rightmost} element satisfying the test.

\begin{new}
X3J13 voted in January 1989
\issue{MAPPING-DESTRUCTIVE-INTERACTION}
to restrict user side effects; see section~\ref{STRUCTURE-TRAVERSAL-SECTION}.
\end{new}
\end{defun}

\begin{defun}[Function]
position item sequence &key :from-end :test :test-not :start~:end~:key \\
position-if predicate sequence &key :from-end :start~:end~:key \\
position-if-not predicate sequence &key :from-end :start~:end~:key

If the \emph{sequence} contains an element satisfying the test,
then the index within the sequence of the leftmost such element
is returned as a non-negative integer; otherwise {\false} is returned.

If \cd{:start} and \cd{:end} keyword arguments are given,
only the specified subsequence of \emph{sequence} is searched.
However, the index returned is relative to the entire sequence,
not to the subsequence.

If a non-{\false} \cd{:from-end} keyword argument is specified, then the result is
the index of the \emph{rightmost} element satisfying the test.  (The index
returned, however, is an index from the left-hand end, as usual.)

\begin{new}
X3J13 voted in January 1989
\issue{MAPPING-DESTRUCTIVE-INTERACTION}
to restrict user side effects; see section~\ref{STRUCTURE-TRAVERSAL-SECTION}.
\end{new}
\end{defun}

\begin{newer}
Here is a simple piece of code that uses several of the sequence
functions, notably \cdf{position-if} and \cdf{find-if},
to process strings.  Note one use of \cdf{loop} as well.
\begin{lisp}
(defun debug-palindrome (s) \\*
~~(flet ((match (x) (char-equal (first x) (third x)))) \\*
~~~~(let* ((pairs (loop for c across s \\*
~~~~~~~~~~~~~~~~~~~~~~~~for j from 0 \\*
~~~~~~~~~~~~~~~~~~~~~~~~when (alpha-char-p c) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~collect (list c j))) \\*
~~~~~~~~~~~(quads (mapcar \#'append pairs (reverse pairs))) \\*
~~~~~~~~~~~(diffpos (position-if (complement \#'match) quads))) \\
~~~~~~(when diffpos \\*
~~~~~~~~(let* ((diff (elt quads diffpos)) \\*
~~~~~~~~~~~~~~~(same (find-if \#'match quads \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~:start (+ diffpos 1)))) \\
~~~~~~~~~~(if same \\*
~~~~~~~~~~~~~~(format nil \\*
~~~~~~~~~~~~~~~~~~~~~~"/{\Xtilde}A/ (at {\Xtilde}D) is not the reverse of /{\Xtilde}A/" \\*
~~~~~~~~~~~~~~~~~~~~~~(subseq s (second diff) (second same)) \\*
~~~~~~~~~~~~~~~~~~~~~~(second diff) \\*
~~~~~~~~~~~~~~~~~~~~~~(subseq s (+ (fourth same) 1) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(+ (fourth diff) 1))) \\*
~~~~~~~~~~~~~~"This palindrome is completely messed up!"))))))
\end{lisp}
Here is an example of its behavior.
\begin{lisp}
(setq panama~~~~~;\textrm{A putative palindrome?} \\*
~~~~~~"A man, a plan, a canoe, pasta, heros, rajahs, \\*
~~~~~~~a coloratura, maps, waste, percale, macaroni, a gag, \\*
~~~~~~~a banana bag, a tan, a tag, a banana bag again \\*
~~~~~~~(or a camel), a crepe, pins, Spam, a rut, a Rolo, \\*
~~~~~~~cash, a jar, sore hats, a peon, a canal--Panama!")
\end{lisp}
\begin{lisp}
(debug-palindrome panama) \\*
~~\EV\ "/wast/ (at 73) is not the reverse of /, pins/" \\
\\
(replace panama "snipe" :start1 73)~~~~~;\textrm{Repair it} \\*
~~\EV\ "A man, a plan, a canoe, pasta, heros, rajahs, \\*
~~~~~~~a coloratura, maps, snipe, percale, macaroni, a gag, \\*
~~~~~~~a banana bag, a tan, a tag, a banana bag again \\*
~~~~~~~(or a camel), a crepe, pins, Spam, a rut, a Rolo, \\*
~~~~~~~cash, a jar, sore hats, a peon, a canal--Panama!" \\
\\
(debug-palindrome panama) \EV\ nil~~~~~;\textrm{Copacetic---a true palindrome} \\
\\
(debug-palindrome "Rubber baby buggy bumpers") \\*
~~\EV\ "/Rubber / (at 0) is not the reverse of /umpers/" \\
\\
(debug-palindrome "Common Lisp: The Language") \\*
~~\EV\ "/Commo/ (at 0) is not the reverse of /guage/" \\
\\
(debug-palindrome "Complete mismatches are hard to find") \\*
~~\EV\ \\
~~"/Complete mism/ (at 0) is not the reverse of /re hard to find/" \\
\\
(debug-palindrome "Waltz, nymph, for quick jigs vex Bud") \\*
~~\EV\ "This palindrome is completely messed up!" \\
\\
(debug-palindrome "Doc, note: I dissent.~~A fast never \\*
~~~~~~~~~~~~~~~~~~~prevents a fatness.~~I diet on cod.") \\*
~~\EV\nil~~~~~;\textrm{Another winner} \\
\\
(debug-palindrome "Top step's pup's pet spot") \EV\ nil
\end{lisp}
\end{newer}


\begin{defun}[Function]
count item sequence &key :from-end :test :test-not :start~:end~:key \\
count-if predicate sequence &key :from-end :start~:end~:key \\
count-if-not predicate sequence &key :from-end :start~:end~:key

The result is always a non-negative integer, the number of
elements in the specified subsequence of \emph{sequence} satisfying
the test.

The \cd{:from-end} argument does not affect the result returned;
it is accepted purely for compatibility with other sequence functions.

\begin{new}
X3J13 voted in January 1989
\issue{MAPPING-DESTRUCTIVE-INTERACTION}
to restrict user side effects; see section~\ref{STRUCTURE-TRAVERSAL-SECTION}.
\end{new}
\end{defun}

\begin{defun}[Function]
mismatch sequence1 sequence2 &key :from-end :test :test-not :key :start1 :start2 :end1 :end2

The specified subsequences of
\emph{sequence1} and \emph{sequence2} are compared element-wise.
If they are of equal length and match in every element, the result is
{\false}.  Otherwise, the result is a non-negative integer.
This result is the index within
\emph{sequence1} of the leftmost position at which the two
subsequences fail to match; or,
if one subsequence is shorter than and a matching prefix of the other,
the result is the index
relative to \emph{sequence1} beyond the last position tested.

If a non-{\false} \cd{:from-end} keyword argument is given, then
\emph{one plus} the index of the \emph{rightmost}
position in which the sequences differ is returned.  In effect, the (sub)sequences
are aligned at their right-hand ends; then, the last elements are compared,
the penultimate elements, and so on.  The index returned is again
an index relative to \emph{sequence1}.

\begin{new}
X3J13 voted in January 1989
\issue{MAPPING-DESTRUCTIVE-INTERACTION}
to restrict user side effects; see section~\ref{STRUCTURE-TRAVERSAL-SECTION}.
\end{new}
\end{defun}

\begin{defun}[Function]
search sequence1 sequence2 &key :from-end :test :test-not :key :start1 :start2 :end1 :end2

A search is conducted for a subsequence of \emph{sequence2} that
element-wise matches \emph{sequence1}.
If there is no such subsequence, the result is {\false}; if there is,
the result is the index into \emph{sequence2} of the leftmost element
of the leftmost such matching subsequence.

If a non-{\false} \cd{:from-end} keyword argument is given,
the index of the leftmost
element of the \emph{rightmost} matching subsequence is returned.

The implementation may choose to search the sequence in any order;
there is no guarantee on the number of times the test is made.
For example, \cdf{search} with a non-{\nil} \cd{:from-end}
argument might actually search a list from left to right
instead of from right to left (but in either case would return
the rightmost matching subsequence, of course).  Therefore it is a good
idea for a user-supplied predicate to be free of side effects.

\begin{new}
X3J13 voted in January 1989
\issue{MAPPING-DESTRUCTIVE-INTERACTION}
to restrict user side effects; see section~\ref{STRUCTURE-TRAVERSAL-SECTION}.
\end{new}
\end{defun}

\section{Sorting and Merging}

These functions may destructively modify argument sequences
in order to put a sequence into sorted order or to merge two
already sorted sequences.

\begin{defun}[Function]
sort sequence predicate &key :key \\
stable-sort sequence predicate &key :key

\indexterm{sorting}
The \emph{sequence} is destructively sorted according to an order determined by
the \emph{predicate}.  The \emph{predicate} should take two
arguments, and return non-{\false} if and only if the first argument is
strictly less than the second (in some appropriate sense). 
If the first argument is greater than or equal to the second
(in the appropriate sense), then the \emph{predicate} should return {\false}.

The \cdf{sort} function determines the relationship between two elements
by giving keys extracted from the elements to the \emph{predicate}.
The \cd{:key} argument, when applied to an element, should return
the key for that element.  The \cd{:key} argument defaults to the identity
function, thereby making the element itself be the key.

The \cd{:key} function should not have any side effects.
A useful example of a \cd{:key} function would be a component
selector function for a \cdf{defstruct} structure, used in sorting
a sequence of structures.
\begin{lisp}
(sort \emph{a} \emph{p} \cd{:key} \emph{s})
   \EQ\ (sort \emph{a} \#'(lambda (x y) (\emph{p} (\emph{s} x) (\emph{s} y))))
\end{lisp}
While the above two expressions are equivalent, the first may be more
efficient in some implementations for certain types of arguments.  For
example, an implementation may choose to apply \emph{s} to each
item just once, putting the resulting keys into a separate table, and
then sort the parallel tables, as opposed to applying
\emph{s} to an item every time just before applying the \emph{predicate}.

If the \cd{:key} and \emph{predicate} functions always return, then the
sorting operation will always terminate, producing a sequence containing
the same elements as the original sequence (that is, the result is a
permutation of \emph{sequence}).  This is guaranteed even if the
\emph{predicate} does not really consistently represent a total order
(in which case the elements will be scrambled in some unpredictable
way, but no element will be lost).  If
the \cd{:key} function consistently returns meaningful keys,
and the \emph{predicate}
does reflect some total ordering criterion on those keys, then the
elements of the result sequence will be properly sorted according
to that ordering.

The sorting operation performed by \cdf{sort} is not guaranteed \emph{stable}.
Elements considered equal by the \emph{predicate} may or may not
stay in their original order.  (The \emph{predicate} is assumed to
consider two elements \emph{x} and \emph{y} to be equal if
\cd{(funcall \emph{predicate} \emph{x} \emph{y})} and
\cd{(funcall \emph{predicate} \emph{y} \emph{x})} are both false.)
The function \cdf{stable-sort} guarantees
stability but may be slower than \cdf{sort} in some situations.

The sorting operation may be destructive in all cases.  In the case of an
array argument, this is accomplished by permuting the elements in place.
In the case of a list, the list is
destructively reordered in the same manner as for
\cdf{nreverse}.  Thus if the argument should not be destroyed, the
user must sort a copy of the argument.

Should execution of the \cd{:key} function or the \emph{predicate} cause an error,
the state of the list or array being sorted is
undefined.  However, if the error is corrected, the sort will, of
course, proceed correctly. 

Note that since sorting requires many comparisons, and thus
many calls to the \emph{predicate}, sorting will be much faster if the
\emph{predicate} is a compiled function rather than interpreted. 

An example:
\begin{lisp}
(setq foovector (sort foovector \#'string-lessp \cd{:key} \#'car))
\end{lisp}
If \cdf{foovector} contained these items before the sort
\begin{lisp}
("Tokens" "The Lion Sleeps Tonight") \\
("Carpenters" "Close to You") \\
("Rolling Stones" "Brown Sugar") \\
("Beach Boys" "I Get Around") \\
("Mozart" "Eine Kleine Nachtmusik" (K 525)) \\
("Beatles" "I Want to Hold Your Hand")
\end{lisp}
then after the sort \cdf{foovector} would contain
\begin{lisp}
("Beach Boys" "I Get Around") \\
("Beatles" "I Want to Hold Your Hand") \\
("Carpenters" "Close to You") \\
("Mozart" "Eine Kleine Nachtmusik" (K 525)) \\
("Rolling Stones" "Brown Sugar") \\
("Tokens" "The Lion Sleeps Tonight")
\end{lisp}

\begin{new}
X3J13 voted in January 1989
\issue{MAPPING-DESTRUCTIVE-INTERACTION}
to restrict user side effects; see section~\ref{STRUCTURE-TRAVERSAL-SECTION}.
\end{new}
\end{defun}

\begin{defun}[Function]
merge result-type sequence1 sequence2 predicate &key :key

The sequences \emph{sequence1} and \emph{sequence2} are destructively
merged according to an order determined by
the \emph{predicate}.  The result is a sequence of type \emph{result-type},
which must be a subtype of \cdf{sequence}, as for the function \cdf{coerce}.
The \emph{predicate} should take two
arguments and return non-{\false} if and only if the first argument is
strictly less than the second (in some appropriate sense). 
If the first argument is greater than or equal to the second
(in the appropriate sense), then the \emph{predicate} should return {\false}.

The \cdf{merge} function determines the relationship between two elements
by giving keys extracted from the elements to the \emph{predicate}.
The \cd{:key} function, when applied to an element, should return
the key for that element; the \cd{:key} function defaults to the identity
function, thereby making the element itself be the key.

The \cd{:key} function should not have any side effects.
A useful example of a \cd{:key} function would be a component
selector function for a \cdf{defstruct} structure, used to merge
a sequence of structures.

If the \cd{:key} and \emph{predicate} functions always return, then the
merging operation will always terminate.
The result of merging two sequences \emph{x} and \emph{y} is a new sequence
\emph{z}, such that the length of \emph{z} is the sum of the lengths of \emph{x}
and \emph{y}, and \emph{z} contains all the elements of \emph{x} and \emph{y}.
If \emph{x1} and \emph{x2} are two elements of \emph{x}, and \emph{x1} precedes
\emph{x2} in \emph{x}, then \emph{x1} precedes \emph{x2} in \emph{z}, and similarly for
elements of \emph{y}.  In short, \emph{z} is an \emph{interleaving} of \emph{x}
 and \emph{y}.

Moreover, if \emph{x} and \emph{y} were correctly sorted according to the
\emph{predicate}, then \emph{z} will also be correctly sorted,
as shown in this example.
\begin{lisp}
(merge 'list '(1 3 4 6 7) '(2 5 8) \#'<) \EV\ (1 2 3 4 5 6 7 8)
\end{lisp}
If \emph{x} or \emph{y} is not so sorted then \emph{z} will not be sorted,
but will nevertheless be an interleaving of \emph{x} and \emph{y}.

The merging operation is guaranteed
\emph{stable}; if two or more elements are considered equal by the
\emph{predicate}, then the elements from \emph{sequence1} will
precede those from \emph{sequence2} in the result.
(The \emph{predicate} is assumed to
consider two elements \emph{x} and \emph{y} to be equal if
\cd{(funcall \emph{predicate} \emph{x} \emph{y})} and
\cd{(funcall \emph{predicate} \emph{y} \emph{x})} are both false.)
For example:
\begin{lisp}
(merge 'string "BOY" "nosy" \#'char-lessp) \EV\ "BnOosYy"
\end{lisp}
The result can \emph{not} be \cd{"BnoOsYy"}, \cd{"BnOosyY"}, or \cd{"BnoOsyY"}.
The function \cdf{char-lessp} ignores case, and so considers
the characters \cdf{Y} and \cdf{y} to be equal, for example;
the stability property then guarantees that the character from the
first argument (\cdf{Y}) must precede the one from the second
argument (\cdf{y}).

\begin{newer}
X3J13 voted in June 1989 \issue{SEQUENCE-TYPE-LENGTH} to specify that
\cdf{merge} should signal an error if the sequence type specifies the number of
elements and the sum of the lengths of the two sequence arguments is
different.
\end{newer}

\begin{new}
X3J13 voted in January 1989
\issue{MAPPING-DESTRUCTIVE-INTERACTION}
to restrict user side effects; see section~\ref{STRUCTURE-TRAVERSAL-SECTION}.
\end{new}
\end{defun}

%RUSSIAN
\else

\chapter{}
\label{KSEQUE}

 \cdf{sequence}     ( ).
        
,     ,  
 :     .

        ,   
    .  
 ,     , 
 ()   .    Common Lisp
     .

\begin{flushleft}
\cf
\begin{tabular*}{\textwidth}{@{}l@{\extracolsep{\fill}}lll@{}}
elt&reverse&map&remove \\
length&nreverse&some&remove-duplicates \\
subseq&concatenate&every&delete \\
copy-seq&position&notany&delete-duplicates \\
fill&find&notevery&substitute \\
replace&sort&reduce&nsubstitute \\
count&merge&search&mismatch
\end{tabular*}
\end{flushleft}
       .
    ( )    .
 ,        
,     .

        
 ,          .
         
   \cdf{eql}.
(        \cd{:test} 
\cd{:test-not}.      .)
       \cdf{-if} 
\cdf{-if-not}.  ,    ,   , 
   .       
    .
  ,
\begin{lisp}
(remove \emph{item} \emph{sequence})
\end{lisp}
   \emph{sequence},    
  \cdf{eql}  \emph{emph}.
\begin{lisp}
(remove \emph{item} \emph{sequence} \cd{:test} \#'equal)
\end{lisp}
   \emph{sequence},    
  \cdf{equal}  \emph{emph}.
\begin{lisp}
(remove-if \#'numberp \emph{sequence})
\end{lisp}
   \emph{sequence},    
.

      , 
    \cdf{:key}   {\false},    
  ,       
 .
,
\begin{lisp}
(find \emph{item} \emph{sequence} \cd{:test} \#'eq \cd{:key} \#'car)
\end{lisp}
      \emph{sequence}, \emph{car}
   \cdf{eq}  \emph{item}.

        
.       
   .   
   -{\false}    
\cd{:from-end}. (    \cd{:from-end} 
.       ,
    .  
 \emph{test}     .)

      . 
    \cd{:start}  \cd{:end}.  
    , 
$\emph{start}\leq\emph{end}$.  $\emph{start}>\emph{end}$ 
.        \emph{start}
    \emph{end} .  
   $\emph{end}-\emph{start}$.  
\emph{start} ,   - .  
\emph{end} ,   -  .
  ,    
 .       
\cdf{subseq}. ,  ,  ,   
 ,    ,  
:
\begin{lisp}
(position \#{\Xbackslash}b "foobar" \cd{:start} 2 \cd{:end} 5) \EV\ 3 \\
(position \#{\Xbackslash}b (subseq "foobar" 2 5)) \EV\ 1
\end{lisp}
     ,   
\cd{:start1}, \cd{:end1}, \cd{start2}  \cd{:end2}   
    .

  ,   \cdf{remove}  \cdf{delete}, 
 \cd{:count}   ,    
 .    {\false}   ,  
 .

   ,  \emph{x} 
<< >>,      :
\begin{itemize}
\item
   , 
 \emph{testfn}    \cd{:test},  
 \cd{(funcall \emph{testfn} \emph{item} (\emph{keyfn} \emph{x}))}
.

\item
   , 
 \emph{testfn}     \cd{:test-not}, 
 \cd{(funcall \emph{testfn} \emph{item} (\emph{keyfn} \emph{x}))}
.

\item
   \cdf{-if},  
\cd{(funcall \emph{predicate} (\emph{keyfn} \emph{x}))} .

\item
   \cdf{-if-not},  
\cd{(funcall \emph{predicate} (\emph{keyfn} \emph{x}))} 
\end{itemize}
  ,  \emph{keyfn}    \cd{:key}
(-  ).  ,  \cdf{remove}.

   
  \emph{x}  \emph{y},   ,
<<>>,      :
\begin{itemize}
\item
 \emph{testfn}    \cd{:test},  

\cd{(funcall \emph{testfn} (\emph{keyfn} \emph{x}) (\emph{keyfn}  \emph{y}))}
.

\item
 \emph{testfn}    \cd{:test-not},  

\cd{(funcall \emph{testfn} (\emph{keyfn} \emph{x}) (\emph{keyfn} \emph{y}))}
.
\end{itemize}
 ,  \cdf{search}.

         \emph{testfn}.
        .
    \emph{testfn}  ,   
 (   )    
.
         
 \emph{testfn},       ,   
 .

       ,    
\emph{}  ( ~\ref{ARRAY-TYPE-SECTION}).
  ,      .

\section{   }

       
. \cdf{make-sequence}   .

\begin{defun}[]
elt sequence index

    \emph{sequence}, 
 \emph{index}.       
   \emph{sequence}.  ,  
,   \cdf{length}.
     \cd{0}.

( ,  \cdf{elt}     ,
 .         
  \cdf{aref}.)

      
\cdf{setf}    \cdf{elt}.
\end{defun}

\begin{defun}[]
subseq sequence start &optional end

    
\emph{sequence}    \emph{start}   
\emph{end}. 
\cdf{subseq} \emph{}    
.       ,  
 .

      \cdf{setf} 
  \cdf{subseq}.   \cdf{replace}.
\end{defun}

\begin{defun}[]
copy-seq sequence

    \emph{sequence}.   \cdf{equalp}
. ,     \cdf{eq} .
\begin{lisp}
(copy-seq \emph{x}) \EQ\ (subseq \emph{x} 0)
\end{lisp}
  \cdf{copy-seq}    .
\end{defun}

\begin{defun}[]
length sequence

    
\emph{sequence}.     .
      , 
<< >>,       (
~\ref{FILL-POINTER}).
\end{defun}

\begin{defun}[]
reverse sequence

      ,  
 \emph{sequence}.   
   .
    .
\end{defun}

\begin{defun}[]
nreverse sequence

  ,    ,  
 \emph{sequence},    .   
     .     
  \cdf{eq} .     
\cd{(setq x (nreverse x))},    \cd{(nreverse x)}  
    \cdf{x}.
\end{defun}

\begin{defun}[]
make-sequence type size &key :initial-element

     \emph{type}  
\emph{size},       
\cd{:initial-element}.
   \cd{:initial-element},     
 \emph{type}.
:
\begin{lisp}
(make-sequence '(vector double-float) \\*
~~~~~~~~~~~~~~~100 \\*
~~~~~~~~~~~~~~~:initial-element 1d0)
\end{lisp}
  \cd{:initial-element}  ,  
  .
\end{defun}

\section{,    }

       
    \cdf{reduce},   
 -     .

\begin{defun}[]
concatenate result-type &rest sequences

   ,     
  .     
 (  \cdf{concatenate}   \cdf{append}). 
    \emph{result-type},   
 \cdf{sequence},    \cdf{coerce}.
,      
 \emph{result-type}.

    ,      , 
  \emph{result-type}, \cdf{concatenate}     
  .     ,  
   ,  
\cdf{coerce}.
\end{defun}

\begin{defun}[]
map result-type function sequence &rest more-sequences

 \emph{function}    , 
    \cdf{map}. 
  \cdf{map} --- ,   
   \emph{function}   
 .     
  .

  \emph{function}   ,    
,         \cd{0}- ,  
  \cd{1}-   .

      \emph{result-type} (
   \cdf{sequence}).
 ,     {\nil},   ,   
 .     \emph{function}    
,  \cdf{map}  {\nil}.    \cdf{map}  
\cdf{mapc}.

:
\begin{lisp}
(map 'list \#'- '(1 2 3 4)) \EV\ (-1 -2 -3 -4) \\
(map 'string \\
~~~~~\#'(lambda (x) (if (oddp x) \#{\Xbackslash}1 \#{\Xbackslash}0)) \\
~~~~~'(1 2 3 4)) \\
~~~\EV\ "1010"
\end{lisp}
\end{defun}


\begin{defun}[]
map-into result-sequence function &rest sequences

 \cdf{map-into}      
\emph{function}      
    \emph{result-sequence}.
  \emph{result-sequence}.

 \emph{result-sequence}   \emph{sequences}   
  ( ).
 \emph{function}    ,  
  .
 \emph{result-sequence}    \emph{sequences}  
,      . 
\emph{result-sequence}     ,  
    ,      
 ,      \emph{function}.

  \emph{function}   ,    
,         \cd{0}- ,  
  \cd{1}-   .

 \cdf{map-into}   \cdf{map} ,   
 ,    .  , \cdf{map-into}
       (\emph{result-sequence} 
\emph{function}),   \cdf{map}     .

 \emph{result-sequence}  \cdf{nil}, \cdf{map-into} 
 \cdf{nil},    \cdf{nil}  
.
\end{defun}


\begin{defun}[]
some predicate sequence &rest more-sequences \\
every predicate sequence &rest more-sequences \\
notany predicate sequence &rest more-sequences \\
notevery predicate sequence &rest more-sequences

  .
 \emph{predicate}    ,  
 .  \emph{predicate}   
 \cd{0}- , , ,   \cd{1}- , 
 ,           
    \emph{sequences}.

 \emph{predicate}   ,    
,         \cd{0}- ,   
  \cd{1}-   .

\cdf{some} ,    \emph{predicate}  -{\false}
.  \cdf{some}  ,    .
         \emph{predicate}
  -{\false},    {\false}.
 ,  ,   \cdf{some} , 
\emph{- (some)}  \emph{predicate} .

\cdf{every}  {\false},    \emph{predicate}
 {\false}.
    , \cdf{every}  -{\false}.
 ,  ,   \cdf{every} , 
\emph{ (every)}  \emph{predicate} .

\cdf{notany}  {\false},    \emph{predicate} 
 -{\false}.
    , \cdf{notany}  -{\false}.
 ,  ,   \cdf{notany} , 
\emph{  (notany)}  \emph{predicate}  .

\cdf{notevery}  -{\false},    \emph{predicate} 
 {\false}.
    , \cdf{notevery}  {\false}.
 ,  ,   \cdf{notevery} , 
\emph{  (notany)}  \emph{predicate} .
\end{defun}

\begin{defun}[]
reduce function sequence &key :from-end :start :end :initial-value

 \cdf{reduce}     
 ( binary) .  \cdf{+}   
 .

   \emph{sequence} 
 <<>>    \emph{function},   
 .  (, ) 
,   \cd{:from-end}   ,  
   . -
\cd{:from-end}  {\nil}.
   \cd{:initial-value},     
 (     \cd{:from-end}) 
   .

        
\cd{:initial-value}  ,    ,  
\emph{function}    .
   ,    \cd{:initial-value},
  \cd{:initial-value},   \emph{function}  .

   ,   \cd{:initial-value}  ,
  \emph{function}   ,  \cdf{reduce}
 ,    .      
,   \emph{function}    .

\begin{lisp}
(reduce \#'+ '(1 2 3 4)) \EV\ 10 \\
(reduce \#'- '(1 2 3 4)) \EQ\ (- (- (- 1 2) 3) 4) \EV\ -8 \\
(reduce \#'- '(1 2 3 4) :from-end t)~~~~~;\textrm{ } \\
~~~\EQ\ (- 1 (- 2 (- 3 4))) \EV\ -2 \\
(reduce \#'+ '()) \EV\ 0 \\
(reduce \#'+ '(3)) \EV\ 3 \\
(reduce \#'+ '(foo)) \EV\ foo \\
(reduce \#'list '(1 2 3 4)) \EV\ (((1 2) 3) 4) \\
(reduce \#'list '(1 2 3 4) :from-end t) \EV\ (1 (2 (3 4))) \\
(reduce \#'list '(1 2 3 4) :initial-value 'foo) \\
~~~\EV\ ((((foo 1) 2) 3) 4) \\
(reduce \#'list '(1 2 3 4) \\
~~~~~~~~:from-end t :initial-value 'foo) \\
~~~\EV\ (1 (2 (3 (4 foo))))
\end{lisp}
  \emph{function}   ,    
  ,    .

 <<reduce>>    {APL}.
\end{defun}

\section{ }

      ,  
 .

\begin{defun}[]
fill sequence item &key :start :end

  ,   
,     \cd{:start} 
\cd{:end},  \emph{item}. \emph{item}    Lisp' 
,      \emph{sequence}. 
 \emph{item}     
 \emph{sequence},    \cd{:start} (-
 0)     \cd{:end} (- 
 ). \cd{fill}   .
:
\begin{lisp}
(setq x (vector 'a 'b 'c 'd 'e)) \EV\ \#(a b c d e) \\
(fill x 'z \cd{:start} 1 \cd{:end} 3) \EV\ \#(a z z d e) \\
~~\textrm{and now} x \EV\ \#(a z z d e) \\
(fill x 'p) \EV\ \#(p p p p p) \\
~~\textrm{and now} x \EV\ \#(p p p p p)
\end{lisp}
\end{defun}

\begin{defun}[]
replace sequence1 sequence2 &key :start1 :end1 :start2~:end2

   \emph{sequence1}    
  \emph{sequence2}.  \emph{sequence2} 
   \emph{sequence1}. 
\emph{sequence2},     \cd{:start2}  \cd{:end2},
   \emph{sequence2},   
 \cd{:start1}  \cd{:end1}.  \cd{:start1}  \cd{:start2}
-  .  \cd{:end1}  \cd{:end2} -
{\false},     .
      ,   
     .  
   .
     :
\begin{lisp}
(min (- \emph{end1} \emph{start1}) (- \emph{end2} \emph{start2}))
\end{lisp}
  \cdf{replace}   
\emph{sequence1}.

    (\cdf{eq}),    
   ,   ,    
     ,     
.
,    ,     
 (,   \emph{} ), 
  \cdf{replace},    .
\end{defun}

\begin{defun}[]
remove item sequence &key :from-end :test :test-not :start :end :count :key \\
remove-if predicate sequence &key :from-end :start :end :count :key \\
remove-if-not predicate sequence &key :from-end :start :end :count :key

     ,   
\emph{sequence}. ,      
  \cd{:start}-\cd{:end},   .
     \emph{sequence} 
 .       .

   \cd{:count},      . 
    ,    
     \cd{:count}.

   \cd{:count}  
\cd{:from-end}  -{\false} ,    
    \cd{:count}.
:
\begin{lisp}
(remove 4 '(1 2 4 1 3 4 5)) \EV\ (1 2 1 3 5) \\
(remove 4 '(1 2 4 1 3 4 5) \cd{:count} 1) \EV\ (1 2 1 3 4 5) \\
(remove 4 '(1 2 4 1 3 4 5) \cd{:count} 1 \cd{:from-end} t) \\
~~~\EV\ (1 2 4 1 3 5) \\
(remove 3 '(1 2 4 1 3 4 5) \cd{:test} \#'>) \EV\ (4 3 4 5) \\
(remove-if \#'oddp '(1 2 4 1 3 4 5)) \EV\ (2 4 4) \\
(remove-if \#'evenp '(1 2 4 1 3 4 5) \cd{:count} 1 \cd{:from-end} t) \\
~~~\EV\ (1 2 4 1 3 5)
\end{lisp}
 \cdf{remove}   \emph{}  
.      \cdf{eq} 
,       .
\end{defun}

\begin{defun}[]
delete item sequence &key :from-end :test :test-not :start~:end~:count~:key \\
delete-if predicate sequence &key :from-end :start~:end~:count~:key \\
delete-if-not predicate sequence &key :from-end :start~:end~:count~:key

     \cdf{remove}  
.      ,   
\emph{sequence}. ,      
  \cd{:start}-\cd{:end},   .
     \emph{sequence} 
 .       .
 \emph{sequence}   ,  
   \cdf{eq}    .

   \cd{:count},      . 
    ,    
     \cd{:count}.

   \cd{:count}  
\cd{:from-end}  -{\false} ,    
    \cd{:count}.
:
\begin{lisp}
(delete 4 '(1 2 4 1 3 4 5)) \EV\ (1 2 1 3 5) \\
(delete 4 '(1 2 4 1 3 4 5) \cd{:count} 1) \EV\ (1 2 1 3 4 5) \\
(delete 4 '(1 2 4 1 3 4 5) \cd{:count} 1 \cd{:from-end} t) \\
~~~\EV\ (1 2 4 1 3 5) \\
(delete 3 '(1 2 4 1 3 4 5) \cd{:test} \#'>) \EV\ (4 3 4 5) \\
(delete-if \#'oddp '(1 2 4 1 3 4 5)) \EV\ (2 4 4) \\
(delete-if \#'evenp '(1 2 4 1 3 4 5) \cd{:count} 1 \cd{:from-end} t) \\
~~~\EV\ (1 2 4 1 3 5)
\end{lisp}
\end{defun}

\begin{defun}[]
remove-duplicates sequence &key :from-end :test :test-not :start :end :key \\
delete-duplicates sequence &key :from-end :test :test-not :start :end :key

     \emph{sequence},  
 ,      (  \cd{:from-end} 
,   ).
     ,   , 
  .      
    .

\cdf{remove-duplicates}      .
 \cdf{remove-duplicates}   \emph{}  
.      \cdf{eq} 
,       .

\cdf{delete-duplicates}    \emph{sequence}.

:
\begin{lisp}
(remove-duplicates '(a b c b d d e)) \EV\ (a c b d e) \\
(remove-duplicates '(a b c b d d e) \cd{:from-end} t) \EV\ (a b c d e) \\
(remove-duplicates '((foo \#{\Xbackslash}a) (bar \#{\Xbackslash}\%) (baz \#{\Xbackslash}A)) \\
~~~~~~~~~~~~~~~~~~~\cd{:test} \#'char-equal \cd{:key} \#'cadr) \\
~~~\EV\ ((bar \#{\Xbackslash}\%) (baz \#{\Xbackslash}A)) \\
(remove-duplicates '((foo \#{\Xbackslash}a) (bar \#{\Xbackslash}\%) (baz \#{\Xbackslash}A)) \\
~~~~~~~~~~~~~~~~~~~\cd{:test} \#'char-equal \cd{:key} \#'cadr \cd{:from-end} t) \\
~~~\EV\ ((foo \#{\Xbackslash}a) (bar \#{\Xbackslash}\%))
\end{lisp}

        
 .
\end{defun}

\begin{defun}[]
substitute newitem olditem sequence &key :from-end :test :test-not :start :end :count :key \\
substitute-if newitem test sequence &key :from-end :start~:end :count :key \\
substitute-if-not newitem test sequence &key :from-end :start :end :count :key

        
\emph{sequence}
  ,      
\cd{:start}-\cd{:end}     \emph{newitem}.  
       .

   \cd{:count},      
.  
    ,    
     \cd{:count}.

   \cd{:count}  
\cd{:from-end}  -{\false} ,    
    \cd{:count}.
:
\begin{lisp}
(substitute 9 4 '(1 2 4 1 3 4 5)) \EV\ (1 2 9 1 3 9 5) \\
(substitute 9 4 '(1 2 4 1 3 4 5) \cd{:count} 1) \EV\ (1 2 9 1 3 4 5) \\
(substitute 9 4 '(1 2 4 1 3 4 5) \cd{:count} 1 \cd{:from-end} t) \\
~~~\EV\ (1 2 4 1 3 9 5) \\
(substitute 9 3 '(1 2 4 1 3 4 5) \cd{:test} \#'>) \EV\ (9 9 4 9 3 4 5) \\
(substitute-if 9 \#'oddp '(1 2 4 1 3 4 5)) \EV\ (9 2 4 9 9 4 9) \\
(substitute-if 9 \#'evenp '(1 2 4 1 3 4 5) \cd{:count} 1 \cd{:from-end} t) \\
~~~\EV\ (1 2 4 1 3 9 5)
\end{lisp}
 \cdf{substitute}   \emph{}  
.      \cdf{eq} 
,       .

  \cdf{subst},      .

\end{defun}

\begin{defun}[]
nsubstitute newitem olditem sequence &key :from-end :test :test-not :start :end :count :key \\
nsubstitute-if newitem test sequence &key :from-end :start~:end :count :key \\
nsubstitute-if-not newitem test sequence &key :from-end :start :end :count :key

      \cdf{substitute}.  ,
    .
        
\emph{sequence}
  ,      
\cd{:start}-\cd{:end}     \emph{newitem}.
 \emph{sequence}   ,  
   \cdf{eq}    .

  \cdf{nsubst},     
 .
\end{defun}

\section{  }

       , 
 .

\begin{defun}[]
find item sequence &key :from-end :test :test-not :start~:end :key \\
find-if predicate sequence &key :from-end :start :end :key \\
find-if-not predicate sequence &key :from-end :start~:end~:key

  \emph{sequence}  , 
,      ,  
{\false}.

   \cd{:start}  \cd{:end},     
.

 \cd{:from-end}   -{\false},    
  .
\end{defun}

\begin{defun}[]
position item sequence &key :from-end :test :test-not :start~:end~:key \\
position-if predicate sequence &key :from-end :start~:end~:key \\
position-if-not predicate sequence &key :from-end :start~:end~:key

  \emph{sequence}  , 
,      ,  
{\false}.

   \cd{:start}  \cd{:end},     
.       
  .

 \cd{:from-end}   -{\false},    
   . (,  , , 
,    .)
\end{defun}
      ,
 \cdf{position-if}  \cdf{find-if},   .
  \cdf{loop}.
\begin{lisp}
(defun debug-palindrome (s) \\*
~~(flet ((match (x) (char-equal (first x) (third x)))) \\*
~~~~(let* ((pairs (loop for c across s \\*
~~~~~~~~~~~~~~~~~~~~~~~~for j from 0 \\*
~~~~~~~~~~~~~~~~~~~~~~~~when (alpha-char-p c) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~collect (list c j))) \\*
~~~~~~~~~~~(quads (mapcar \#'append pairs (reverse pairs))) \\*
~~~~~~~~~~~(diffpos (position-if (complement \#'match) quads))) \\
~~~~~~(when diffpos \\*
~~~~~~~~(let* ((diff (elt quads diffpos)) \\*
~~~~~~~~~~~~~~~(same (find-if \#'match quads \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~:start (+ diffpos 1)))) \\
~~~~~~~~~~(if same \\*
~~~~~~~~~~~~~~(format nil \\*
~~~~~~~~~~~~~~~~~~~~~~"/{\Xtilde}A/ (at {\Xtilde}D) is not the reverse of /{\Xtilde}A/" \\*
~~~~~~~~~~~~~~~~~~~~~~(subseq s (second diff) (second same)) \\*
~~~~~~~~~~~~~~~~~~~~~~(second diff) \\*
~~~~~~~~~~~~~~~~~~~~~~(subseq s (+ (fourth same) 1) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(+ (fourth diff) 1))) \\*
~~~~~~~~~~~~~~"This palindrome is completely messed up!"))))))
\end{lisp}
    
\begin{lisp}
(setq panama~~~~~;\textrm{ ?} \\*
~~~~~~"A man, a plan, a canoe, pasta, heros, rajahs, \\*
~~~~~~~a coloratura, maps, waste, percale, macaroni, a gag, \\*
~~~~~~~a banana bag, a tan, a tag, a banana bag again \\*
~~~~~~~(or a camel), a crepe, pins, Spam, a rut, a Rolo, \\*
~~~~~~~cash, a jar, sore hats, a peon, a canal--Panama!")
\end{lisp}
\begin{lisp}
(debug-palindrome panama) \\*
~~\EV\ "/wast/ (at 73) is not the reverse of /, pins/" \\
\\
(replace panama "snipe" :start1 73)~~~~~;\textrm{} \\*
~~\EV\ "A man, a plan, a canoe, pasta, heros, rajahs, \\*
~~~~~~~a coloratura, maps, snipe, percale, macaroni, a gag, \\*
~~~~~~~a banana bag, a tan, a tag, a banana bag again \\*
~~~~~~~(or a camel), a crepe, pins, Spam, a rut, a Rolo, \\*
~~~~~~~cash, a jar, sore hats, a peon, a canal--Panama!" \\
\\
(debug-palindrome panama) \EV\ nil~~~~~;\textrm{--- } \\
\\
(debug-palindrome "Rubber baby buggy bumpers") \\*
~~\EV\ "/Rubber / (at 0) is not the reverse of /umpers/" \\
\\
(debug-palindrome "Common Lisp: The Language") \\*
~~\EV\ "/Commo/ (at 0) is not the reverse of /guage/" \\
\\
(debug-palindrome "Complete mismatches are hard to find") \\*
~~\EV\ \\
~~"/Complete mism/ (at 0) is not the reverse of /re hard to find/" \\
\\
(debug-palindrome "Waltz, nymph, for quick jigs vex Bud") \\*
~~\EV\ "This palindrome is completely messed up!" \\
\\
(debug-palindrome "Doc, note: I dissent.~~A fast never \\*
~~~~~~~~~~~~~~~~~~~prevents a fatness.~~I diet on cod.") \\*
~~\EV\nil~~~~~;\textrm{ } \\
\\
(debug-palindrome "Top step's pup's pet spot") \EV\ nil
\end{lisp}

\begin{defun}[]
count item sequence &key :from-end :test :test-not :start~:end~:key \\
count-if predicate sequence &key :from-end :start~:end~:key \\
count-if-not predicate sequence &key :from-end :start~:end~:key

    ,   
   ,  .

\cd{:from-end}    ,    
   .
\end{defun}

\begin{defun}[]
mismatch sequence1 sequence2 &key :from-end :test :test-not :key :start1 :start2 :end1 :end2

    .
           , 
  {\false}. ,    
.
      ,      
 \emph{sequence2}.  ,    
  ,     , 
    .

  \cd{:from-end}  -{\false} ,  
  1      . ,
()     ,  
 ,     .  
   \emph{sequence1}.
\end{defun}

\begin{defun}[]
search sequence1 sequence2 &key :from-end :test :test-not :key :start1 :start2 :end1 :end2

     \emph{sequence1} 
 \emph{sequence1}.
    ,    {\false}. ,
        
 \emph{sequence2}.

  \cd{:from-end}  -{\false},   , 
       
 .

       . 
      .
, \cdf{search}  \cd{:from-end}  -{\nil}  
   ,       
 .    
   .
\end{defun}

\section{  }

     :
      .

\begin{defun}[]
sort sequence predicate &key :key \\
stable-sort sequence predicate &key :key

   \emph{sequence}  , 
 \emph{predicate}.    
.  \emph{predicate}    ,
 -{\false}    ,     
 (    ).
       (    ),
  \emph{predicate}   {\false}.

 \cdf{sort}       
 \emph{predicate},      
.  \cd{:key},   ,    
.
 \cd{:key} -   ,  
  .

 \cd{:key}     .
   \cd{:key}   -  
 (   \cdf{defstruct}),   
 .
\begin{lisp}
(sort \emph{a} \emph{p} \cd{:key} \emph{s})
   \EQ\ (sort \emph{a} \#'(lambda (x y) (\emph{p} (\emph{s} x) (\emph{s} y))))
\end{lisp}
    ,     
     .
,        ,
   ,     .

  \cd{:key}  \emph{predicate}   , 
     ,  
       (  
   ).
  ,    \emph{predicate} 
    (    
   ,        ). 
 \cd{:key}     , 
\emph{predicate}       ,
       
   .

 ,    \cdf{sort},  
\emph{}.
,   \emph{predicate}  ,  
    .
(,  \emph{predicate}    \emph{x} 
\emph{y} ,  
\cd{(funcall \emph{predicate} \emph{x} \emph{y})} 
\cd{(funcall \emph{predicate} \emph{y} \emph{x})}  .)
 \cdf{stable-sort}  ,    
    \cdf{sort}.

       .   
,    .
   ,    
   \cdf{nreverse}.
 ,      ,  
   .

   \cd{:key}  \emph{predicate}  , 
      .
,     , ,  , 
 .

 ,        
  \emph{predicate},    , 
\emph{predicate}  ,    .

:
\begin{lisp}
(setq foovector (sort foovector \#'string-lessp \cd{:key} \#'car))
\end{lisp}
 \cdf{foovector}     
\begin{lisp}
("Tokens" "The Lion Sleeps Tonight") \\
("Carpenters" "Close to You") \\
("Rolling Stones" "Brown Sugar") \\
("Beach Boys" "I Get Around") \\
("Mozart" "Eine Kleine Nachtmusik" (K 525)) \\
("Beatles" "I Want to Hold Your Hand")
\end{lisp}
  , \cdf{foovector}  
\begin{lisp}
("Beach Boys" "I Get Around") \\
("Beatles" "I Want to Hold Your Hand") \\
("Carpenters" "Close to You") \\
("Mozart" "Eine Kleine Nachtmusik" (K 525)) \\
("Rolling Stones" "Brown Sugar") \\
("Tokens" "The Lion Sleeps Tonight")
\end{lisp}
\end{defun}

\begin{defun}[]
merge result-type sequence1 sequence2 predicate &key :key

     \emph{sequence1} 
\emph{sequence2}     \emph{predicate}.
    \emph{result-type},  
  \cdf{sequence}.
 \emph{predicate}    ,
 -{\false}    ,     
 (    ).
       (    ),
  \emph{predicate}   {\false}.

 \cdf{merge}       
 \emph{predicate},      
.  \cd{:key},   ,    
.
 \cd{:key} -   ,  
  .

 \cd{:key}     .
   \cd{:key}   -  
 (   \cdf{defstruct}),   
 .

  \cd{:key}  \emph{predicate}   , 
    .
    \emph{x}  \emph{y}  
 \emph{z},       \emph{x} 
\emph{y}. \emph{z}    \emph{x}  \emph{y}.
 \emph{x1}  \emph{x2}   \emph{x},  \emph{x1} 
 \emph{x2},   \emph{z} \emph{x1}     
\emph{x2}.      \emph{y}.  , \emph{z} 
\emph{} \emph{x}  \emph{y}.

 ,  \emph{x}  \emph{y}     
  \emph{predicate},  \emph{z}   
. ,
\begin{lisp}
(merge 'list '(1 3 4 6 7) '(2 5 8) \#'<) \EV\ (1 2 3 4 5 6 7 8)
\end{lisp}
 \emph{x}  \emph{y}   ,  \emph{z}   
.      .

   \emph{}.
       \emph{predicate} 
,      \emph{sequence1}  
  \emph{sequence2}.
(,  \emph{predicate}    \emph{x} 
\emph{y} ,  
\cd{(funcall \emph{predicate} \emph{x} \emph{y})} 
\cd{(funcall \emph{predicate} \emph{y} \emph{x})}  .)
:
\begin{lisp}
(merge 'string "BOY" "nosy" \#'char-lessp) \EV\ "BnOosYy"
\end{lisp}
    \cd{"BnoOsYy"}, \cd{"BnOosyY"}  \cd{"BnoOsyY"}.
 \cdf{char-lessp}  ,  , ,  \cd{Y} 
\cd{y} .   ,     
(\cd{Y})       (\cd{y}).
\end{defun}

\fi
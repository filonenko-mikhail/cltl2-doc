%%%Chapter of Common Lisp Manual.  Copyright 1989 Guy L. Steele Jr.
\clearpage\def\pagestatus{FINAL PROOF}

\def\SU#1{${}_{#1}$}

\ifx \rulang\Undef

\chapter{Conditions}
\label{CONDITION}


Author: Kent M. Pitman

This chapter presents the bulk of the Common Lisp
Condition System proposal, written by Kent~M. Pitman
and amended by X3J13.  I have edited it only very lightly
to conform to the overall style of this book and have inserted a small
number of bracketed remarks identified by the initials GLS.
Please see the Acknowledgments to this second edition for the author's
acknowledgments to others who contributed to the Condition System proposal.

\noindent\hbox to \textwidth{\hss---Guy L. Steele Jr.}

\section{Introduction}

Often we find it useful to describe a function in terms of its behavior in
``normal situations.'' For example, we may say informally that the function
\cdf{+} returns the sum of its arguments or that the function
\cdf{read-char} returns the next available character on a given input
stream.

Sometimes, however, an ``exceptional situation'' will arise that does not fit
neatly into such descriptions. For example, \cdf{+} might receive an argument
that is not a number, or \cdf{read-char} might receive as a single argument
a stream that has no more available characters.  This distinction between normal
and exceptional situations is in some sense arbitrary but is often very
useful in practice.

For example, suppose a function \cdf{f} were defined to allow only
integer arguments but also guaranteed to
detect and signal an error for non-integer arguments.
Such a description is in fact internally inconsistent (that is,
paradoxical) because the function's behavior is well-defined for non-integers.
Yet we would not want this annoying paradox to force description of \cdf{f}
as a function that accepts any kind of argument (just in case \cdf{f}
is being called only as a quick way to signal an error, for example).
Using the normal/exceptional distinction, we can say clearly that \cdf{f} accepts integers
in the normal situation and signals an error in exceptional situations.
Moreover, we can say that when we refer to the definition of a
function informally, it is acceptable to speak only of its normal behavior.
For example, we can speak informally about \cdf{f} as a function that accepts only
integers without feeling that we are committing some awful fraud.

Not all exceptional situations are errors.  For example, a program that is
directing the typing of a long line of text may come to an end-of-line.
It is possible that no real harm will result from failing to signal end-of-line
to its caller because the operating system will simply force a carriage
return on the output device, which will continue typing on the next line. However, it
may still be interesting to establish a protocol whereby the printing program can
inform its caller of end-of-line exceptions. The caller could
then opt to deal with these situations in interesting ways at certain times.
For example, a caller might choose to terminate printing, obtaining an end-of-line
truncation. The important thing, however, is that the failure of the
caller to provide advice about the situation need not prevent
the printer program from operating correctly.

Mechanisms for dealing with exceptional situations vary widely. When an
exceptional situation is encountered, a program may attempt to handle
it by returning a distinguished value, returning an additional value,
setting a variable, calling a function, performing a special transfer of
control, or stopping the program altogether and entering the debugger.

For the most part, the facilities described in this chapter do not introduce
any fundamentally new way of dealing with exceptional situations. Rather, they
encapsulate and formalize useful patterns of data and control flow that have
been seen to be useful in dealing with exceptional situations.

A proper conceptual approach to errors should perhaps begin from first
principles, with a discussion of \emph{conditions} in general, and eventually work
up to the concept of an \emph{error} as just one of the many kinds of
conditions. However, given the primitive state of error-handling
technology, a proper buildup may be as inappropriate as requiring that a
beggar learn to cook a gourmet meal before being allowed to eat.  Thus,
we deal first with the essentials---error handling---and then
go back later to fill in the missing details.

\section{Changes in Terminology}

In this section, we introduce changes to the terminology
defined in section~\ref{INTRO-ERRORS}.

A \emph{condition} is an interesting situation in a program that has been
detected and announced. Later we allow this term also to refer to
objects that programs use to represent such situations.

An \emph{error} is a condition in which normal program execution may not
continue without some form of intervention (either interactively by 
the user
or under some sort of program control, as described below).

The process by which a condition is formally announced by a program is called
\emph{signaling}. The function \cdf{signal} is the primitive mechanism by which such
announcement is done. Other abstractions, such as \cdf{error} and \cdf{cerror}, are built
using \cdf{signal}.

The first edition is ambiguous about the reason why a particular program action
``is an error.'' There are two principal reasons why an action may be an error
without being required to signal an error:
\begin{itemize}
\item Detecting the error might be prohibitively expensive.

   For example, \cd{(+ nil 3)} is an error. It is likely that the designers of
   Common Lisp believed this would be an error in all implementations but
   felt it might be excessively expensive to detect the problem
   in compiled code on stock hardware, so they did not require that it signal
   an error.

\item Some implementations might implement the behavior as an extension.

   For example, \cd{(loop for x from 1 to 3 do (print x))} is an error because \cdf{loop}
   is not defined to take atoms in its body.
   In fact, however, some
   implementations offer an extension that makes this well-defined. In order
   to leave room for such extensions, the first edition used the ``is an error''
   terminology to keep implementors from being forced to signal an error in
   the extended implementations.

   [This example was written well before the vote by X3J13 in January 1989
    to add exactly this extension to the forthcoming draft standard
    (see chapter~\ref{LOOP}).---GLS]
\end{itemize}

In this chapter, we use the following terminology.
[Compare this to the terminology presented
in section~\ref{Error-Terminology-SECTION}.---GLS]
\begin{itemize}
\item
   If the signaling of a condition or error is part of a function's contract
   in all situations, we say that it ``signals'' or ``must signal'' that
   condition or error.

\item
   If the signaling of a condition or error is optional for some important
   reason (such as performance), we say that the program ``might signal''
   that condition or error. In this case, we are defining the operation to be
   illegal in all implementations, but allowing some implementations to fail to
   detect the error.

\item
   If an action is left undefined for the sake of implementation-dependent
   extension, we say that it ``is undefined'' or ``has undefined effect.''
   This means that it is not possible to depend portably upon the effects of
   that action. A program that has undefined effect may enter the debugger,
   transfer control, or modify data in unpredictable ways.

\item
   In the special case where only the return value of an operation is not
   well defined but any side effect and transfer-of-control behavior is
   well defined, we say that it has ``undefined value.'' In this case,
   the number and nature of the return values is not defined, but the
   function can reasonably be expected to return. It is worth noting that
   under this description, there are some (though not many) legitimate ways
   in which such return value(s) can be used. For example, if the function
   \cdf{foo} has no side effects and undefined value, the expression 
   \cd{(length (list (foo)))} is completely well defined even for portable code.
   However, the effect of \cd{(print (list (foo)))} is not well defined.
\end{itemize}


\section{Survey of Concepts}

This section discusses various aspects of the condition system by topic,
illustrating them with extensive examples.  The next section contains
definitions of specific functions, macros, and other facilities.

\subsection{Signaling Errors}

Conceptually, signaling an error in a program is an admission by that program
that it does not know how to continue and requires external intervention. Once
an error is signaled, any decision about how to continue must come from the
``outside.''

The simplest way to signal an error is to use the \cdf{error} function with
\cdf{format}-style arguments describing the error for the sake of the user interface.
If \cdf{error} is called and there are no active handlers (described
in sections~\ref{TRAPPING-ERRORS} and~\ref{HANDLING-CONDITIONS}), the
debugger will be entered and the error message will be typed out. For example:
\begin{lisp}
Lisp> (defun factorial (x) \\*
~~~~~~~~(cond ((or (not (typep x 'integer)) (minusp x)) \\*
~~~~~~~~~~~~~~~(error "{\Xtilde}S is not a valid argument to FACTORIAL." \\*
~~~~~~~~~~~~~~~~~~~~~~x)) \\
~~~~~~~~~~~~~~((zerop x) 1) \\
~~~~~~~~~~~~~~(t (* x (factorial (- x 1)))))) \\*
~\EV\ FACTORIAL \\
Lisp> (factorial 20) \\*
~\EV\ 2432902008176640000 \\
Lisp> (factorial -1) \\*
Error: -1 is not a valid argument to FACTORIAL. \\*
To continue, type :CONTINUE followed by an option number: \\*
~1: Return to Lisp Toplevel. \\*
Debug> 
\end{lisp}
In general, a call to \cdf{error} cannot directly return. Unless special work has
been done to override this behavior, the debugger will be entered and there
will be no option to simply continue.

The only exception may be that some implementations may provide debugger
commands for interactively returning from individual stack frames; even then,
however, such commands should never be used except by someone who has read the
erring code and understands the consequences of continuing from that point. In
particular, the programmer should feel confident
about writing code like this:
\begin{lisp}
(defun wargames:no-win-scenario () \\*
~~(when (true) (error "Pushing the button would be stupid.")) \\*
~~(push-the-button))
\end{lisp}
In this scenario, there should be no chance that the function \cdf{error} will return
and the button will be pushed.

\beforenoterule
\begin{sideremark}
It should be noted that the notion of
``no chance'' that the button will be pushed is relative only to the language
model; it assumes that the language is accurately implemented.  In practice,
compilers have bugs, computers have glitches, and users have been known
to interrupt at inopportune moments and use the debugger to return from
arbitrary stack frames.  Such violations of the language model are
beyond the scope of the condition system but not necessarily beyond the
scope of potential failures that the programmer should consider and defend against.
The possibility of such unusual failures may of course also influence the design of
code meant to handle less drastic situations,
such as maintaining a database uncorrupted.---KMP and GLS
\end{sideremark}
\afternoterule

In some cases, the programmer may have a single, well-defined idea of a
reasonable recovery strategy for this particular error. In that case, he can
use the function \cdf{cerror}, which specifies information about what would happen
if the user did simply continue from the call to \cdf{cerror}. For example:
\begin{lisp}
Lisp> (defun factorial (x) \\*
~~~~~~~~(cond ((not (typep x 'integer)) \\*
~~~~~~~~~~~~~~~(error "{\Xtilde}S is not a valid argument to FACTORIAL." \\*
~~~~~~~~~~~~~~~~~~~~~~x)) \\
~~~~~~~~~~~~~~((minusp x) \\*
~~~~~~~~~~~~~~~(let ((x-magnitude (- x))) \\*
~~~~~~~~~~~~~~~~~(cerror "Compute -({\Xtilde}D!) instead." \\*
~~~~~~~~~~~~~~~~~~~~~~~~~"(-{\Xtilde}D)! is not defined." x-magnitude) \\*
~~~~~~~~~~~~~~~~~(- (factorial x-magnitude)))) \\
~~~~~~~~~~~~~~((zerop x) 1) \\
~~~~~~~~~~~~~~(t (* x (factorial (- x 1)))))) \\*
~\EV\ FACTORIAL \\
Lisp> (factorial -3) \\*
Error: (-3)! is not defined. \\*
To continue, type :CONTINUE followed by an option number: \\*
~1: Compute -(3!) instead. \\*
~2: Return to Lisp Toplevel. \\*
Debug> :continue 1 \\
~\EV\ -6
\end{lisp}

\subsection{Trapping Errors}
\label{TRAPPING-ERRORS}

By default, a call to \cdf{error} will force entry into the debugger.  You can
override that behavior in a variety of ways. The simplest (and most blunt)
tool for inhibiting entry to the debugger on an error is to use \cdf{ignore-errors}.
In the normal situation, forms in the body of \cdf{ignore-errors} are evaluated
sequentially and the last value is returned. If a condition of type \cdf{error} is
signaled, \cdf{ignore-errors} immediately returns two values, namely \cdf{nil} and the
condition that was signaled; the debugger is not entered and no error
message is printed. For example:
\begin{lisp}
Lisp> (setq filename "nosuchfile") \\
~\EV\ "nosuchfile" \\
Lisp> (ignore-errors (open filename :direction :input)) \\
~\EV\ NIL \textrm{and} \#<FILE-ERROR 3437523>
\end{lisp}
The second return value is an object that represents the kind of error. This
is explained in greater detail in section~\ref{OBJECT-0RIENTED-BASIS}.

In many cases, however, \cdf{ignore-errors} is not desirable because it deals with
too many kinds of errors. Contrary to the belief of some, a program that
does not enter the debugger is not necessarily better than one that does.
Excessive use of \cdf{ignore-errors} may keep the program out of the debugger, but it may
not increase the program's reliability, because the program may continue
to run after encountering errors other than those you meant to work past. In
general, it is better to attempt to deal only with the particular kinds of
errors that you believe could legitimately happen. That way, if an unexpected
error comes along, you will still find out about it.

\cdf{ignore-errors} is a useful special case built from a more general facility,
\cdf{handler-case}, that allows the programmer to deal with particular kinds of
conditions (including non-error conditions) without affecting what happens
when other kinds of conditions are signaled. For example, an effect 
equivalent to that of \cdf{ignore-errors} above is achieved in the following example:
\begin{lisp}
Lisp> (setq filename "nosuchfile") \\
~\EV\ "nosuchfile" \\
Lisp> (handler-case (open filename :direction :input) \\
~~~~~~~~(error (condition) \\
~~~~~~~~~~(values nil condition))) \\
~\EV\ NIL \textrm{and} \#<FILE-ERROR 3437525>
\end{lisp}
However, using \cdf{handler-case}, one can indicate a more specific condition
type than just ``error.'' Condition types are explained in detail later, but the
syntax looks roughly like the following:
\begin{lisp}
Lisp> (makunbound 'filename) \\
~\EV\ FILENAME \\
Lisp> (handler-case (open filename :direction :input) \\
~~~~~~~~(file-error (condition) \\
~~~~~~~~~~(values nil condition))) \\
Error: The variable FILENAME is unbound. \\
To continue, type :CONTINUE followed by an option number: \\
~1: Retry getting the value of FILENAME. \\
~2: Specify a value of FILENAME to use this time. \\
~3: Specify a value of FILENAME to store and use. \\
~4: Return to Lisp Toplevel. \\
Debug> 
\end{lisp}

\subsection{Handling Conditions}
\label{HANDLING-CONDITIONS}

Blind transfer of control to a \cdf{handler-case} is only one possible kind
of recovery action that can be taken when a condition is signaled.  The
low-level mechanism offers great flexibility in how to continue once
a condition has been signaled.

The basic idea behind condition handling is that a piece of code called the
\emph{signaler} recognizes and announces the existence of an exceptional
situation using \cdf{signal} or some function built on \cdf{signal} (such as
\cdf{error}). 

The process of signaling involves the search for and invocation of a
\emph{handler}, a piece of code that will attempt to deal appropriately with
the situation. 

If a handler is found, it may either \emph{handle} the situation, by performing
some non-local transfer of control, or \emph{decline} to handle it, by failing to perform a
non-local transfer of control. If it declines, other handlers are sought.

Since the lexical environment of the signaler might not be available to
handlers, a data structure called a \emph{condition} is created to represent
explicitly the relevant state of the situation. A condition either is created
explicitly using \cdf{make-condition} and then passed to a function such as \cdf{signal},
or is created implicitly by a function such as \cdf{signal} when given appropriate
non-condition arguments.

In order to handle the error, a handler is permitted to use any non-local
transfer of control such as \cdf{go} to a tag in a \cdf{tagbody},
\cdf{return} from a \cdf{block}, or
\cdf{throw} to a \cdf{catch}. In addition, structured abstractions of these
primitives are provided for convenience in exception handling.

A handler can be made dynamically accessible to a program by use of
\cdf{handler-bind}. For example, to create a handler for a condition of type
\cdf{arithmetic-error}, one might write:
\begingroup
\makeatletter
\def\@listi{\leftmargin\leftmargini \labelsep\leftmargin
   \parsep 3pt\relax
   \topsep 4pt plus 9pt\relax
   \itemsep\topsep}
\makeatother
\begin{lisp}
(handler-bind ((arithmetic-error \emph{handler}))\emph{body})
\end{lisp}
The handler is a function of one argument, the condition. If a condition of
the designated type is signaled while the \emph{body} is executing (and there are no
intervening handlers), the handler would be invoked on the given condition,
allowing it the option of transferring control. For example, one might write a
macro that executes a body, returning either its value(s) or the two values
\cdf{nil} and the condition:
\begin{lisp}
(defmacro without-arithmetic-errors (\&body forms) \\
~~(let ((tag (gensym))) \\
~~~~`(block ,tag \\
~~~~~~ (handler-bind ((arithmetic-error \\
~~~~~~~~~~~~~~~~~~~~~~~~~\#'(lambda (c)~~~~~;\textrm{Argument \cdf{c} is a condition} \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (return-from ,tag (values nil c))))) \\
~~~~~~~~~,@body)))) \\
\end{lisp}
\endgroup
The handler is executed in the dynamic context of the signaler, except
that the set of available condition handlers will have been rebound to
the value that was active at the time the condition handler was made
active. If a handler decline (that is, it does not transfer control), other 
handlers are sought. If no handler is found and the condition was signaled
by \cdf{error} or \cdf{cerror} (or some function such as \cdf{assert} that behaves like
these functions), the debugger is entered, still in the dynamic context 
of the signaler.

\subsection{Object-Oriented Basis of Condition Handling}
\label{OBJECT-0RIENTED-BASIS}

Of course, the ability of the handler to usefully handle an exceptional
situation is related to the quality of the information it is provided. For
example, if all errors were signaled by
\begin{lisp}
(error "\emph{some format string}")
\end{lisp}
then the only piece of information that would be accessible to the handler
would be an object of type \cdf{simple-error} that had a slot containing the
format string.

If this were done, \cdf{string-equal} would be the preferred way to tell one error
from another, and it would be very hard to allow flexibility in the
presentation of error messages because existing handlers would tend to be
broken by even tiny variations in the wording of an error message. This
phenomenon has been the major failing of most error systems previously
available in Lisp. It is fundamentally important to decouple the error
message string (the human interface) from the objects that formally
represent the error state (the program interface). We therefore have the
notion of typed conditions, and of formal operations on those conditions
that make them inspectable in a structured way.

This object-oriented approach to condition handling has the following
important advantages over a text-based approach:
\begin{itemize}
\item
   Conditions are classified according to subtype relationships, making
   it easy to test for categories of conditions.

\item
   Conditions have named slot values through which parameters are conveyed
   from the program that signals the condition to the program that handles it.

\item
   Inheritance of methods and slots reduces the amount of explicit
   specification necessary to achieve various interesting effects.
\end{itemize}

Some condition types are defined by this document, but the set of 
condition types is extensible using \cdf{define-condition}.
Common Lisp condition types are in fact CLOS classes, and condition objects
are ordinary CLOS objects; \cdf{define-condition} merely
provides an abstract interface that is a bit more convenient than
\cdf{defclass} for defining conditions.

Here, as an example,
we define a two-argument function called \cdf{divide} that is patterned after
the \cdf{/} function but does some stylized error checking:
\begin{lisp}
(defun divide (numerator denominator) \\
~~(cond ((or (not (numberp numerator)) \\
~~~~~~~~~~~~~(not (numberp denominator))) \\
~~~~~~~~~(error "(DIVIDE '{\Xtilde}S '{\Xtilde}S) - Bad arguments." \\
~~~~~~~~~~~~~~~~numerator denominator)) \\
~~~~~~~~((zerop denominator) \\
~~~~~~~~~(error 'division-by-zero \\
~~~~~~~~~~~~~~~~:operator 'divide \\
~~~~~~~~~~~~~~~~:operands (list numerator denominator))) \\
~~~~~~~~(t ...)))
\end{lisp}
Note that in the first clause we have used \cdf{error} with a string argument
and in the second clause we have named a particular condition type,
\cdf{division-by-zero}. In the case of a string argument, the condition type that
will be signaled is \cdf{simple-error}.

The particular kind of error that is signaled may be important
in cases where handlers are active. For example, \cdf{simple-error} inherits 
from type \cdf{error}, which in turn inherits from type \cdf{condition}. On the 
other hand, \cdf{division-by-zero} inherits from \cdf{arithmetic-error}, which 
inherits from \cdf{error}, which inherits from \cdf{condition}. So if a handler
existed for \cdf{arithmetic-error} while a \cdf{division-by-zero} condition was
signaled, that handler would be tried; however, if a \cdf{simple-error}
condition were signaled in the same context, the handler for type
\cdf{arithmetic-error} would not be tried.

\subsection{Restarts}
\label{RESTARTS}

The Common Lisp Condition System creats a clear
separation between the act of signaling an error of a particular type and the
act of saying that a particular way of recovery is appropriate. In the \cdf{divide}
example above, simply signaling an error does not imply a willingness on the
part of the signaler to cooperate in any corrective action. For example, the
following sample interaction illustrates that the only recovery action
offered for this error is ``Return to Lisp Toplevel'':
\begin{lisp}
Lisp> (+ (divide 3 0) 7) \\
Error: Attempt to divide 3 by 0. \\
To continue, type :CONTINUE followed by an option number: \\
~1: Return to Lisp Toplevel. \\
Debug> :continue 1 \\
Returned to Lisp Toplevel. \\
Lisp>
\end{lisp}
When an error is detected and the function \cdf{error} is called, execution cannot
continue normally because \cdf{error} will not directly return. Control can be
transferred to other points in the program, however, by means of specially
established ``restarts.''

\subsection{Anonymous Restarts}

The simplest kind of restart involves structured transfer of control using
a macro called \cdf{restart-case}. The \cdf{restart-case} form allows execution of
a piece of code in a context where zero or more restarts are active, and
where if one of those restarts is ``invoked,'' control will be transferred
to the corresponding clause in the \cdf{restart-case} form. For example, we could
rewrite the previous \cdf{divide} example as follows.
\begin{lisp}
(defun divide (numerator denominator) \\
~~(loop \\
~~~~(restart-case \\
~~~~~~~~(return \\
~~~~~~~~~~(cond ((or (not (numberp numerator)) \\
~~~~~~~~~~~~~~~~~~~~~(not (numberp denominator))) \\
~~~~~~~~~~~~~~~~~(error "(DIVIDE '{\Xtilde}S '{\Xtilde}S) - Bad arguments." \\
~~~~~~~~~~~~~~~~~~~~~~~~~numerator denominator)) \\
~~~~~~~~~~~~~~~~((zerop denominator) \\
~~~~~~~~~~~~~~~~~(error 'division-by-zero \\
~~~~~~~~~~~~~~~~~~~~~~~~:operator 'divide \\
~~~~~~~~~~~~~~~~~~~~~~~~:operands (list numerator denominator))) \\
~~~~~~~~~~~~~~~~(t ...))) \\
~~~~~~(nil (arg1 arg2) \\
~~~~~~~~~~:report "Provide new arguments for use by DIVIDE." \\
~~~~~~~~~~:interactive \\
~~~~~~~~~~~~(lambda () \\
~~~~~~~~~~~~~~~(list (prompt-for 'number "Numerator: ") \\
~~~~~~~~~~~~~~~~~~~~~(prompt-for 'number "Denominator: "))) \\
~~~~~~~~(setq numerator arg1 denominator arg2)) \\
~~~~~~(nil (result) \\
~~~~~~~~~~:report "Provide a value to return from DIVIDE." \\
~~~~~~~~~~:interactive \\
~~~~~~~~~~~~(lambda () (list (prompt-for 'number "Result: "))) \\
~~~~~~~~(return result)))))
\end{lisp}

\beforenoterule
\begin{sideremark}
    The function \cdf{prompt-for} used in this chapter in a number of places is
    not a part of Common Lisp.  It is used in the examples in this chapter only to keep
    the presentation simple.  It is assumed to accept a type specifier
     and optionally a format string and associated arguments.  It uses the
    format string and associated arguments as part of an interactive prompt,
    and uses \cdf{read} to read a Lisp object; however, only an object of the
    type indicated by the type specifier is accepted.

    The question of whether or not \cdf{prompt-for} (or something like it) would be a
    useful addition to Common Lisp is under consideration by X3J13, but as of
    January 1989 no action has been taken. In spite of its use in a number of examples,
    nothing in the Common Lisp Condition System depends on this function.
\end{sideremark}
\afternoterule

In the example, the \cdf{nil} at the head of each clause
means that it is an ``anonymous'' restart.
Anonymous restarts are typically invoked only from within the
debugger. As we shall see later, it is possible to have ``named restarts''
that may be invoked from code without the need for user intervention.

If the arguments to anonymous restarts are not optional, then special
information must be provided about what the debugger should use as arguments.
Here the \cd{:interactive} keyword is used to specify that information.

The \cd{:report} keyword introduces information to be used when presenting the
restart option to the user (by the debugger, for example).

Here is a sample interaction that takes advantage of the restarts provided
by the revised definition of \cdf{divide}:
\begin{lisp}
Lisp> (+ (divide 3 0) 7) \\
Error: Attempt to divide 3 by 0. \\
To continue, type :CONTINUE followed by an option number: \\
~1: Provide new arguments for use by the DIVIDE function. \\
~2: Provide a value to return from the DIVIDE function. \\
~3: Return to Lisp Toplevel. \\
Debug> :continue 1 \\
1 \\
Numerator: 4 \\
Denominator: 2 \\
~\EV\ 9
\end{lisp}

\subsection{Named Restarts}

In addition to anonymous restarts, one can have named restarts, which can be invoked
by name from within code.  As a trivial example, one could write
\begin{lisp}
(restart-case (invoke-restart 'foo 3) \\
~~(foo (x) (+ x 1)))
\end{lisp}
to add \cd{3} to \cd{1}, returning \cd{4}. This trivial example is conceptually analogous to 
writing:
\begin{lisp}
(+ (catch 'something (throw 'something 3)) 1)
\end{lisp}

For a more realistic example, the code for the function \cdf{symbol-value} might signal an
unbound variable error as follows:
\begin{lisp}
(restart-case (error "The variable {\Xtilde}S is unbound." variable) \\*
~~(continue () \\*
~~~~~~:report \\*
~~~~~~~~(lambda (s)~~~~~;\textrm{Argument \cdf{s} is a stream} \\*
~~~~~~~~~~(format s "Retry getting the value of {\Xtilde}S." variable)) \\*
~~~~(symbol-value variable)) \\
~~(use-value (value) \\*
~~~~~~:report \\*
~~~~~~~~(lambda (s)~~~~~;\textrm{Argument \cdf{s} is a stream} \\*
~~~~~~~~~~(format s "Specify a value of {\Xtilde}S to use this time." \\*
~~~~~~~~~~~~~~~~~~variable)) \\*
~~~~value) \\
~~(store-value (value) \\*
~~~~~~:report \\*
~~~~~~~~(lambda (s)~~~~~;\textrm{Argument \cdf{s} is a stream} \\*
~~~~~~~~~~(format s "Specify a value of {\Xtilde}S to store and use." \\*
~~~~~~~~~~~~~~~~~~variable)) \\*
~~~~(setf (symbol-value variable) value) \\*
~~~~value))
\end{lisp}
If this were part of the implementation of \cdf{symbol-value}, then it would be possible
for users to write a variety of automatic handlers for unbound variable
errors. For example, to make unbound variables evaluate to themselves, one
might write
\begin{lisp}
(handler-bind ((unbound-variable \\
~~~~~~~~~~~~~~~~~\#'(lambda (c)~~~~~;\textrm{Argument \cdf{c} is a condition} \\
~~~~~~~~~~~~~~~~~~~~~(when (find-restart 'use-value) \\
~~~~~~~~~~~~~~~~~~~~~~~(invoke-restart 'use-value \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(cell-error-name c)))))) \\
~~\emph{body})
\end{lisp}

\subsection{Restart Functions}

For commonly used restarts, it is conventional to define a program interface
that hides the use of \cdf{invoke-restart}. Such program interfaces to restarts
are called \emph{restart functions}.

The normal convention is for the function to share the name of the restart.
The pre-defined functions \cdf{abort}, \cdf{continue}, \cdf{muffle-warning}, \cdf{store-value}, and
\cdf{use-value} are restart functions. With \cdf{use-value} the above example of 
\cdf{handler-bind} could have been written more concisely as
\begin{lisp}
(handler-bind ((unbound-variable \\
~~~~~~~~~~~~~~~~~~~\#'(lambda (c)~~~~~;\textrm{Argument \cdf{c} is a condition} \\
~~~~~~~~~~~~~~~~~~~~~~~(use-value (cell-error-name c))))) \\
~~\emph{body})
\end{lisp}

\subsection{Comparison of Restarts and Catch/Throw}
  
One important feature that \cdf{restart-case} (or \cdf{restart-bind}) offers that
\cdf{catch} does not is the ability to reason about the available points to
which control might be transferred without actually attempting the
transfer. One could, for example, write
\begin{lisp}
(ignore-errors (throw ...))
\end{lisp}
which is a sort of poor man's variation of
\begin{lisp}
(when (find-restart 'something) \\*
~~(invoke-restart 'something))
\end{lisp}
but there is no way to use \cdf{ignore-errors} and \cdf{throw} to simulate something
like
\begin{lisp}
(when (and (find-restart 'something) \\*
~~~~~~~~~~~(find-restart 'something-else)) \\*
~~(invoke-restart 'something))
\end{lisp}
or even just
\begin{lisp}
(when (and (find-restart 'something) \\
~~~~~~~~~~~(yes-or-no-p "Do something? ")) \\
~~(invoke-restart 'something))
\end{lisp}
because the degree of inspectability that comes with simply writing
\begin{lisp}
(ignore-errors (throw ...))
\end{lisp}
is too primitive---getting the desired information also forces
transfer of control, perhaps at a time when it is not desirable.

Many programmers have previously evolved strategies like the following
on a case-by-case basis:
\begin{lisp}
(defvar *foo-tag-is-available* nil) \\
\\
(defun fn-1 () \\
~~(catch 'foo \\
~~~~(let ((*foo-tag-is-available* t)) \\
~~~~~~... (fn-2) ...))) \\
\\
(defun fn-2 () \\
~~... \\
~~(if *foo-tag-is-available* (throw 'foo t)) \\
~~...)
\end{lisp}
The facility provided by \cdf{restart-case} and \cdf{find-restart} is intended to
provide a standardized protocol for this sort of information to be
communicated between programs that were developed independently so that
individual variations from program to program
do not thwart the overall modularity and debuggability of programs.

Another difference between the restart facility and the \cdf{catch}/\cdf{throw}
facility is that a \cdf{catch} with any given tag completely shadows any
outer pending \cdf{catch} that uses the same tag. Because of the presence
of \cdf{compute-restarts}, however, it is possible to see shadowed restarts,
which may be very useful in some situations (particularly in an
interactive debugger).

\subsection{Generalized Restarts}
\label{LAST-RESTARTS-SECTION}

\cdf{restart-case} is a mechanism that allows only imperative transfer of control
for its associated restarts. \cdf{restart-case} is built on a lower-level mechanism
called \cdf{restart-bind}, which does not force transfer of control.

\cdf{restart-bind} is to \cdf{restart-case} as \cdf{handler-bind} is to
\cdf{handler-case}.
The syntax is
\begin{lisp}
(restart-bind ((\emph{name} \emph{function} . \emph{options})) . \emph{body})
\end{lisp}
The \emph{body} is executed in a dynamic context within which the \emph{function}
will be called whenever 
\cd{(invoke-restart '\emph{name})} is executed. The \emph{options} are keyword-style and are
used to pass information such as that provided with the
\cd{:report} keyword in \cdf{restart-case}.

A \cdf{restart-case} expands into a call to \cdf{restart-bind} where the function
simply does an unconditional transfer of control to a particular body
of code, passing along ``argument'' information in a structured way.

It is also possible to write restarts that do not transfer control. Such
restarts may be useful in implementing various special commands for the
debugger that are of interest only in certain situations. For example,
one might imagine a situation where file space was exhausted and the
following was done in an attempt to free space in directory \cdf{dir}:
\begin{lisp}
(restart-bind ((nil \#'(lambda () (expunge-directory dir)) \\
~~~~~~~~~~~~~~~~~~~~:report-function \\
~~~~~~~~~~~~~~~~~~~~~~\#'(lambda (stream) \\
~~~~~~~~~~~~~~~~~~~~~~~~~~(format stream "Expunge {\Xtilde}A." \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(directory-namestring dir))))) \\
~~(cerror "Try this file operation again." \\
~~~~~~~~~~'directory-full :directory dir))
\end{lisp}
In this case, the debugger might be entered and the user could first
perform the expunge (which would not transfer control from the debugger
context) and then retry the file operation:
\begin{lisp}
Lisp> (open "FOO" :direction :output) \\
Error: The directory PS:<JDOE> is full. \\
To continue, type :CONTINUE followed by an option number: \\
~1: Try this file operation again. \\
~2: Expunge PS:<JDOE>. \\
~3: Return to Lisp Toplevel. \\
Debug> :continue 2 \\
Expunging PS:<JDOE> ... 3 records freed. \\
Debug> :continue 1 \\
~\EV\ \#<OUTPUT-STREAM "PS:<JDOE>FOO.LSP" 2323473>
\end{lisp}

\subsection{Interactive Condition Handling}

When a program does not know how to continue, and no active handler is able to
advise it, the ``interactive condition handler,'' or ``debugger,'' can be
entered. This happens implicitly through the use of functions such as \cdf{error}
and \cdf{cerror}, or explicitly through the use of the function
\cdf{invoke-debugger}.

The interactive condition handler never returns directly; it returns only
through structured non-local transfer of control to specially defined restart
points that can be set up either by the system or by user code. The
mechanisms that support the establishment of such structured restart points
for portable code are outlined
in sections~\ref{RESTARTS} through~\ref{LAST-RESTARTS-SECTION}.

Actually, implementations may also provide extended debugging facilities that
allow return from arbitrary stack frames. Although such commands are frequently
useful in practice, their effects are implementation-dependent because they
violate the Common Lisp program abstraction. The effect of using such
commands is undefined with respect to Common Lisp.

\subsection{Serious Conditions}

The \cdf{ignore-errors} macro will trap conditions of type \cdf{error}. There are,
however, conditions that are not of type \cdf{error}.

Some conditions are not considered errors but are still very serious, so
we call them \emph{serious conditions} and we use the type \cdf{serious-condition} to
represent them. Conditions such as those that might be signaled for
``stack overflow'' or ``storage exhausted'' are in this category.

The type \cdf{error} is a subtype of \cdf{serious-condition}, and it would technically
be correct to use the term ``serious condition'' to refer to all serious
conditions whether errors or not. However, normally we use the term 
``serious condition'' to refer to things of type \cdf{serious-condition} but not
of type \cdf{error}.

The point of the distinction between errors and other serious conditions
is that some conditions are known to occur for reasons that are beyond the
scope of Common Lisp to specify clearly. For example, we know that a stack
will generally be used to implement function calling, and we know that stacks
tend to be of finite size and are prone to overflow. Since the available
stack size may vary from implementation to implementation, from session
to session, or from function call to function call, it would be confusing
to have expressions such as \cd{(ignore-errors (+~a~b))} return a number sometimes
and \cdf{nil} other times if \cdf{a} and \cdf{b} were always bound to numbers and the stack
just happened to overflow on a particular call. For this reason, only
conditions of type \cdf{error} and not all conditions of type \cdf{serious-condition}
are trapped by \cdf{ignore-errors}. To trap other conditions, a lower-level
facility must be used (such as \cdf{handler-bind} or \cdf{handler-case}).

By convention, the function \cdf{error} is preferred over \cdf{signal} to signal conditions
of type \cdf{serious-condition} (including those of type \cdf{error}). It is the use of
the function \cdf{error}, and not the type of the condition being signaled, that
actually causes the debugger to be entered.

\subsection{Non-Serious Conditions}

Some conditions are neither errors nor serious conditions. They are signaled
to give other programs a chance to intervene, but if no action is taken,
computation simply continues normally.

For example, an implementation might choose to signal a non-serious (and
implementation-dependent) condition
called \cdf{end-of-line} when output reaches the last character position on a line
of character output. In such an implementation, the signaling of this
condition might allow a convenient way for other programs to intervene,
producing output that is truncated at the end of a line.

By convention, the function \cdf{signal} is used to signal conditions that are not
serious. It would be possible to signal serious conditions using \cdf{signal}, and
the debugger would not be entered if the condition went unhandled.  However,
by convention,
handlers will generally tend to assume that serious conditions and errors
were signaled by calling the \cdf{error} function (and will therefore
force entry to the interactive condition handler) and that they should
work to avoid this.

\subsection{Condition Types}
 
Some types of conditions are predefined by the system. All types of conditions
are subtypes of \cdf{condition}. That is, \cd{(typep~\emph{x} 'condition)} is true if
and only if the value of \emph{x} is a condition. 

Implementations supporting multiple (or non-hierarchical) type inheritance
are expressly permitted to exploit multiple inheritance in the tree of
condition types as implementation-dependent extensions, as long as such
extensions are compatible with the specifications in this chapter.
[X3J13 voted in March 1989 \issue{ZLOS-CONDITIONS}
to integrate the Condition System and the Object System,
so multiple inheritance is always available for condition types.---GLS]

In order to avoid problems in portable code that runs both in systems with
multiple type inheritance and in systems without it, programmers are explicitly
warned that while all correct Common Lisp implementations will ensure that
\cd{(typep~\emph{c} 'condition)}
is true for all conditions \emph{c} (and all subtype relationships indicated in this
chapter will also be true), it should \emph{not} be assumed that two condition
types specified to be subtypes of the same third type are disjoint.
(In some cases,
disjoint subtypes are identified explicitly, but such disjointness is not to be assumed by
default.)  For example, it follows from the subtype descriptions contained in
this chapter that in all implementations
\cd{(typep~\emph{c}~'control-error)} implies \cd{(typep~\emph{c}~'error)},
but note that
\cd{(typep~\emph{c}~'control-error)} does \emph{not}
imply \cd{(not~(typep~\emph{c}~'cell-error))}.


\subsection{Signaling Conditions}

When a condition is signaled, the system tries to locate the most appropriate
handler for the condition and to invoke that handler.

Handlers are established dynamically using \cdf{handler-bind} or abstractions built
on \cdf{handler-bind}.

If an appropriate handler is found, it is called. In some circumstances, 
the handler may \emph{decline} simply by returning without performing a 
non-local transfer of control. In such cases, the search for an 
appropriate handler is picked up where it left off, as if the called 
handler had never been present.

If no handler is found, or if all handlers that were found decline,
\cdf{signal} returns \cdf{nil}.

Although it follows from the description above, it is perhaps worth noting
explicitly that the lookup procedure described here will prefer a general 
but more (dynamically) local handler over a specific but less (dynamically)
local handler. Experience with existing condition systems suggests that
this is a reasonable approach and works adequately in most situations. 
Some care should be taken when binding handlers for very general kinds of
conditions, such as is done in \cdf{ignore-errors}. Often, binding for a more
specific condition type than \cdf{error} is more appropriate.

\subsection{Resignaling Conditions}
 
[The contents of this section are still a subject of some debate within X3J13.
The reader may wish to take this section with a grain of salt.---GLS]

Note that signaling a condition has no side effect on that condition, and
that there is no dynamic state contained in a condition object. As such, it
may at times be reasonable and appropriate to consider caching condition
objects for repeated use, re-signaling conditions from within handlers,
or saving conditions away somewhere and re-signaling them later.

For example, it may be desirable for the system to pre-allocate objects of type
\cdf{storage-condition} so that they can be signaled when needed without
attempting to allocate more storage.

\subsection{Condition Handlers}
\label{CONDITION-HANDLERS}

A \emph{handler} is a function of one argument, the condition to be handled. The
handler may inspect the object
to be sure it is ``interested'' in handling the condition.

A handler is executed in the dynamic context of the signaler, except that the
set of available condition handlers will have been rebound to the value that
was active at the time the condition handler was made active. The intent of
this is to prevent infinite recursion because of errors in a condition handler.

After inspecting the condition, the handler should take one of the following
actions:
\begin{itemize}
  \item
    It might \emph{decline} to handle the condition (by simply returning). When
    this happens, the returned values are ignored and the effect is the same
    as if the handler had been invisible to the mechanism seeking to find a
    handler. The next handler in line will be tried, or if no such handler
    exists, the condition will go unhandled.

  \item
    It might \emph{handle} the condition (by performing some non-local transfer
    of control). This may be done either primitively using \cdf{go}, \cdf{return}, or \cdf{throw},
    or more abstractly using a function such as \cdf{abort} or \cdf{invoke-restart}.

  \item
    It might signal another condition.

  \item
    It might invoke the interactive debugger.
\end{itemize}
In fact, the latter two actions (signaling another condition or entering the
debugger) are really just ways of putting off the decision to either handle
or decline, or trying to get someone else to make such a decision. Ultimately,
all a handler can do is to handle or decline to handle.

\subsection{Printing Conditions}

When \cdf{*print-escape*} is \cdf{nil} (for example,
when the \cdf{princ} function or the \cd{{\Xtilde}A}
directive is used with \cdf{format}), the report method for the condition will be invoked. This will
be done automatically by functions such as \cdf{invoke-debugger}, \cdf{break}, and \cdf{warn},
but there may still be situations in which it is desirable to have a
condition report under explicit user control. For example,
\begin{lisp}
(let ((form '(open "nosuchfile"))) \\
~~(handler-case (eval form) \\
~~~~(serious-condition (c) \\
~~~~~~(format t "{\Xtilde}\&Evaluation of {\Xtilde}S failed:{\Xtilde}\%{\Xtilde}A" form c))))
\end{lisp}
might print something like
\begin{lisp}
Evaluation of (OPEN "nosuchfile") failed: \\
The file "nosuchfile" was not found.
\end{lisp}
Some suggestions about the form of text typed by report methods:
\begin{itemize}
 \item
    The message should generally be a complete sentence, beginning with a
   capital letter and ending with appropriate punctuation (usually a period).

 \item
    The message should \emph{not} include any introductory text such as ``\cd{Error:}''
   or ``\cd{Warning:}'' and should not be followed by a trailing newline. Such
   text will be added as may be appropriate to context by the routine invoking
   the report method.

 \item
    Except where unavoidable, the tab character (which is only semi-standard anyway)
    should not be used in
   error messages. Its effect may vary from one implementation to another and may
   cause problems even within an implementation because it may do different
   things depending on the column at which the error report begins.

 \item
    Single-line messages are preferred, but newlines in the middle of long
   messages are acceptable.

 \item
   If any program (for example, the debugger) displays messages indented from the
   prevailing left margin (for example, indented seven spaces because they
   are prefixed by the seven-character herald ``\cd{Error:~}''), then that program
   will take care of inserting the appropriate indentation into the extra
   lines of a multi-line error message. Similarly, a program that prefixes
   error messages with semicolons so that they appear to be comments should
   take care of inserting a semicolon at the beginning of each line in a
   multi-line error message. (These rules are important because, even within
   a single implementation, there may be more than one program that presents
   error messages to the user, and they may use different styles of
   presentation. The caller of \cdf{error} cannot anticipate all such possible
   styles, and so it is incumbent upon the presenter of the message to make
   any necessary adjustments.)
\end{itemize}
% [Note: These recommendations expand upon those in
% section~\ref{ERROR-SIGNALLING-FUNCTIONS}.---GLS]

When \cdf{*print-escape*} is not \cdf{nil}, the object should print in some useful (but
usually fairly abbreviated) fashion according to the style of the
implementation. It is not expected that a condition will be printed in a form
suitable for \cdf{read}. Something like \cd{\#<ARITHMETIC-ERROR~1734>}
is fine.

X3J13 voted in March 1989 \issue{ZLOS-CONDITIONS} to integrate the
Condition System and the Object System.
In the original Condition System proposal,
no function was provided for directly accessing or setting the printer for
a condition type, or for invoking it; the techniques described above were
the sole interface to reporting.  The vote specified that, in CLOS terms,
condition reporting is mediated through the \cdf{print-object}
method for the condition type (that is, class) in question, with \cdf{*print-escape*}
bound to \cdf{nil}.

Specifying \cd{(:report \emph{fn})} to
\cdf{define-condition} when defining
condition type \emph{C} is equivalent to a separate method definition:
\begin{lisp}
(defmethod print-object ((x \emph{C}) stream) \\*
~~(if *print-escape* \\*
~~~~~~(call-next-method) \\*
~~~~~~(funcall \#'\emph{fn} x stream)))
\end{lisp}
Note that the method uses \emph{fn} to print the condition
only when \cdf{*print-escape*} has the value \cdf{nil}.

\section{Program Interface to the Condition System}

This section describes functions, macros, variables, and condition
types associated with the Common Lisp Condition System.

\subsection{Signaling Conditions}
\label{SIGNALLING-CONDITIONS}

The functions in this section provide various mechanisms
for signaling warnings, breaks, continuable errors, and fatal errors.

\begin{defun}[Function]
error datum &rest arguments

Invokes the signal facility on a condition. If the condition is not handled,
\cd{(invoke-debugger \emph{condition})} is executed. As a consequence of calling 
\cdf{invoke-debugger}, \cdf{error} never directly returns to its caller; the only exit from this
function can come by non-local transfer of control in a handler or by use of
an interactive debugging command.
  
If \emph{datum} is a condition, then that condition is used directly. 
In this case, it is an error for the list of \emph{arguments} to be non-empty;
that is, \cdf{error} must have been called with exactly one argument, the condition.

If \emph{datum} is a condition type (a class or class name), then the condition used is effectively the result
of \cd{(apply \#'make-condition \emph{datum} \emph{arguments})}.

If \emph{datum} is a string, then the condition used is effectively the result of
\begin{lisp}
(make-condition 'simple-error \\*
~~~~~~~~~~~~~~~~:format-string \emph{datum} \\*
~~~~~~~~~~~~~~~~:format-arguments \emph{arguments})
\end{lisp}
\end{defun}

\begin{defun}[Function]
cerror continue-format-string datum &rest arguments

The function \cdf{cerror}
invokes the error facility on a condition. If the condition is not handled,
\cd{(invoke-debugger \emph{condition})} is executed. While signaling is going on,
and
while control is in the debugger (if it is reached), it is possible to continue
program execution (thereby returning from the call to \cdf{cerror})
using the \cdf{continue} restart.

If \emph{datum} is a condition, then that condition is used directly. 
In this case, the list of \emph{arguments} need not be empty,
but will be used only with the \emph{continue-format-string}
and will not be used to initialize \emph{datum}.

If \emph{datum} is a condition type (a class or class name), then the condition
used is effectively the result of \cd{(apply \#'make-condition \emph{datum}
  \emph{arguments})}.

If \emph{datum} is a string, then the condition used is effectively the result of
\begin{lisp}
(make-condition 'simple-error \\*
~~~~~~~~~~~~~~~~:format-string \emph{datum} \\*
~~~~~~~~~~~~~~~~:format-arguments \emph{arguments})
\end{lisp}

The \emph{continue-format-string} must be a string.
Note that if \emph{datum} is not a 
string, then the format arguments used by the \emph{continue-format-string} will
still be the list of \emph{arguments} (which is in keyword format if \emph{datum} is a condition
type). In this case, some care may be necessary to set up the
\emph{continue-format-string} correctly. The \cdf{format} directive \cd{{\Xtilde}*},
which ignores and skips over \cdf{format} arguments,
may be particularly 
useful in this situation.

The value returned by \cdf{cerror} is \cdf{nil}.
\end{defun}

\begin{defun}[Function]
signal datum &rest arguments

Invokes the signal facility on a condition. If the condition is not handled,
\cdf{signal} returns \cdf{nil}.

If \emph{datum} is a condition, then that condition is used directly. 
In this case, it is an error for the list of \emph{arguments} to be non-empty;
that is, \cdf{signal} must have been called with exactly one argument, the condition.

If \emph{datum} is a condition type (a class or class name), then the condition used is effectively the result
of \cd{(apply \#'make-condition \emph{datum} \emph{arguments})}.

If \emph{datum} is a string, then the condition used is effectively the result of
\begin{lisp}
  (make-condition 'simple-error \\*
  ~~~~~~~~~~~~~~~~:format-string \emph{datum} \\*
  ~~~~~~~~~~~~~~~~:format-arguments \emph{arguments})
\end{lisp}

Note that if \cd{(typep \emph{condition} *break-on-signals*)} is true, then the debugger
will be entered prior to beginning the process of signaling. The \cdf{continue}
restart function may be used to continue with the signaling process;
the restart is associated with the signaled condition as if by
use of \cdf{with-condition-restarts}.
This is true
also for all other functions and macros that signal conditions, such
as \cdf{warn}, \cdf{error}, \cdf{cerror}, \cdf{assert}, and \cdf{check-type}.

During the dynamic extent of a call to \cdf{signal} with a
particular condition, the effect of calling \cdf{signal} again on that
condition object for a distinct abstract event is not defined.
For example, although a handler \emph{may} resignal a condition in order to
allow outer handlers first shot at handling the condition, two
distinct asynchronous keyboard events must not signal an the same (\cdf{eq}) condition
object at the same time.

For further details about signaling and handling, see the discussion of
condition handlers in section~\ref{CONDITION-HANDLERS}.
\end{defun}


\begin{defun}[Variable]
*break-on-signals*

This variable is intended primarily for use when the user is debugging programs
that do signaling.  The value of \cd{*break-on-signals*} should be suitable as a
second argument to \cdf{typep}, that is, a type or type specifier.

When \cd{(typep \emph{condition} *break-on-signals*)} is true, then calls to
\cdf{signal} (and to other advertised functions such as \cdf{error} that
implicitly call \cdf{signal}) will enter the debugger prior to signaling that
\emph{condition}. The \cdf{continue} restart may be used to continue with the
normal signaling process; the restart is associated with the signaled condition
as if by use of \cdf{with-condition-restarts}.

Note that \cdf{nil} is a valid type specifier.  If the value of
\cdf{*break-on-signals*} is \cdf{nil}, then \cdf{signal} will never enter the
debugger in this implicit manner.

When setting this variable, the user is encouraged to choose the most
restrictive specification that suffices. Setting this flag effectively violates
the modular handling of condition signaling that this chapter seeks to
establish. Its complete effect may be unpredictable in some cases, since the
user may not be aware of the variety or number of calls to \cdf{signal} that are
used in programs called only incidentally.

By default---and certainly in any ``production'' use---the value of this
variable should be \cdf{nil}, both for reasons of performance and for reasons of
modularity and abstraction.
\end{defun}

\subsection{Assertions}
\label{CONDITION-ASSERTIONS}

These facilities are designed to make it convenient for the user
to insert error checks into code.

\begin{defmac}
check-type place typespec [string]

A \cdf{check-type} form signals an error of type \cdf{type-error} if the
contents of \emph{place} are not of the desired type.

If a condition is signaled, handlers of this condition can use the functions
\cdf{type-error-datum} and \cdf{type-error-expected-type} to access the contents
of \emph{place} and the \emph{typespec}, respectively.

This function can return only if the \cdf{store-value} restart is invoked,
either explicitly from a handler or implicitly as one of the options offered by
the debugger.  The restart is associated with the signaled condition as if by
use of \cdf{with-condition-restarts}.

If \cdf{store-value} is called, \cdf{check-type} will store the new value that
is the argument to \cdf{store-value} (or that is prompted for interactively by
the debugger) in \emph{place} and start over, checking the type of the new value
and signaling another error if it is still not the desired type. Subforms of
\emph{place} may be evaluated multiple times because of the implicit loop
generated. \cdf{check-type} returns \cdf{nil}.

The \emph{place} must be a generalized variable reference acceptable to
\cdf{setf}. The \emph{typespec} must be a type specifier; it is not evaluated.
The \cdf{string} should be an English description of the type, starting with an
indefinite article (``a'' or ``an''); it is evaluated. If the \emph{string} is
not supplied, it is computed automatically from the \emph{typespec}. (The
optional \emph{string} argument is allowed because some applications of
\cdf{check-type} may require a more specific description of what is wanted than
can be generated automatically from the type specifier.)

The error message will mention the \emph{place}, its contents, and the desired
type.

\beforenoterule
\begin{implementation}
  An implementation may choose to generate a somewhat differently worded error
  message if it recognizes that \emph{place} is of a particular form, such as
  one of the arguments to the function that called \cdf{check-type}.
\end{implementation}
\afternoterule

\begin{lisp}
Lisp> (setq aardvarks '(sam harry fred)) \\*
~\EV\ (SAM HARRY FRED) \\
Lisp> (check-type aardvarks (array * (3))) \\*
Error: The value of AARDVARKS, (SAM HARRY FRED), \\*
~~~~~~~is not a 3-long array. \\
To continue, type :CONTINUE followed by an option number: \\*
~1: Specify a value to use instead. \\*
~2: Return to Lisp Toplevel. \\
Debug> :continue 1 \\*
Use Value: \#(sam fred harry) \\*
~\EV\ NIL \\
Lisp> aardvarks \\*
~\EV\ \#<ARRAY-3 13571> \\
Lisp> (map 'list \#'identity aardvarks) \\*
~\EV\ (SAM FRED HARRY) \\
Lisp> (setq aacount 'foo) \\*
~\EV\ FOO \\
Lisp> (check-type aacount (integer 0 *) "a non-negative integer") \\*
Error: The value of AACOUNT, FOO, is not a non-negative integer. \\*
To continue, type :CONTINUE followed by an option number: \\*
~1: Specify a value to use instead. \\*
~2: Return to Lisp Toplevel. \\
Debug> :continue 2 \\*
Lisp> 
\end{lisp}
\end{defmac}

\begin{defmac}
assert test-form [({place}*) [datum {argument}*]]

An \cdf{assert} form signals an error if the value of the \emph{test-form} is
\cdf{nil}.  Continuing from this error using the \cdf{continue} restart will
allow the user to alter the values of some variables, and \cdf{assert} will then
start over, evaluating the \emph{test-form} again.  (The restart is associated
with the signaled condition as if by use of \cdf{with-condition-restarts}.)
\cdf{assert} returns \cdf{nil}.

The \emph{test-form} may be any form. Each \emph{place} (there may be any number
of them, or none) must be a generalized variable reference acceptable to
\cdf{setf}.  These should be variables on which \emph{test-form} depends, whose
values may sensibly be changed by the user in attempting to correct the error.
Subforms of each \emph{place} are evaluated only if an error is signaled, and
may be re-evaluated if the error is re-signaled (after continuing without
actually fixing the problem).

The \emph{datum} and \emph{argument\/}s are evaluated only if an error is to be
signaled, and re-evaluated if the error is to be signaled again.

If \emph{datum} is a condition, then that condition is used directly.  In this
case, it is an error to specify any \emph{argument\/}s.

If \emph{datum} is a condition type (a class or class name), then the condition
used is effectively the result of \cd{(apply \#'make-condition \emph{datum}
  (list \Mstar{argument}))}.

If \emph{datum} is a string, then the condition used is effectively the result
of
\begin{lisp}
(make-condition 'simple-error \\*
~~~~~~~~~~~~~~~~:format-string \emph{datum} \\*
~~~~~~~~~~~~~~~~:format-arguments (list \Mstar{argument}))
\end{lisp}

If \emph{datum} is omitted, then a condition of type \cdf{simple-error} is
constructed using the \emph{test-form} as data. For example, the following might
be used:
\begin{lisp}
(make-condition 'simple-error \\
~~:format-string "The assertion {\Xtilde}S failed." \\
~~:format-arguments '(\emph{test-form}))
\end{lisp}
Note that the \emph{test-form} itself, and not its value, is used as the format
argument.

\beforenoterule
\begin{implementation}
  The debugger need not include the \emph{test-form} in the error message, and
  any \emph{places} should not be included in the message, but they should be
  made available for the user's perusal. If the user gives the ``continue''
  command, an opportunity should be presented to alter the values of any or all
  of the references. The details of this depend on the implementation's style of
  user interface, of course.
\end{implementation}
\afternoterule

Here is an example of the use of \cdf{assert}:
\begin{lisp}
(setq x (make-array '(3 5) :initial-element 3)) \\
(setq y (make-array '(3 5) :initial-element 7)) \\
 \\
(defun matrix-multiply (a b) \\*
~~(let ((*print-array* nil)) \\*
~~~~(assert (and (= (array-rank a) (array-rank b) 2) \\*
~~~~~~~~~~~~~~~~~(= (array-dimension a 1) \\*
~~~~~~~~~~~~~~~~~~~~(array-dimension b 0))) \\*
~~~~~~~~~~~~(a b) \\*
~~~~~~~~~~~~"Cannot multiply {\Xtilde}S by {\Xtilde}S." a b) \\*
~~~~(really-matrix-multiply a b))) \\
 \\
(matrix-multiply x y) \\
Error: Cannot multiply \#<ARRAY-3-5 12345> by \#<ARRAY-3-5 12364>. \\*
To continue, type :CONTINUE followed by an option number: \\*
~1: Specify new values. \\*
~2: Return to Lisp Toplevel. \\
Debug> :continue 1 \\*
Value for A: x \\*
Value for B: (make-array '(5 3) :initial-element 6) \\
~\EV \#2A(\=(54 54 54 54 54) \\
\>(54 54 54 54 54) \\*
\>(54 54 54 54 54) \\*
\>(54 54 54 54 54) \\*
\>(54 54 54 54 54))
\end{lisp}
\end{defmac}

\subsection{Exhaustive Case Analysis}
\label{EXHAUSTIVE-CASE-ANALYSIS-CONDITIONS}


The syntax for \cdf{etypecase} and \cdf{ctypecase} is the same as for
\cdf{typecase}, except that no \cdf{otherwise} clause is permitted. Similarly,
the syntax for \cdf{ecase} and \cdf{ccase} is the same as for \cdf{case} except
for the \cdf{otherwise} clause.

\cdf{etypecase} and \cdf{ecase} are similar to \cdf{typecase} and \cdf{case},
respectively, but signal a non-continuable error rather than returning \cdf{nil}
if no clause is selected.

\cdf{ctypecase} and \cdf{ccase} are also similar to \cdf{typecase} and
\cdf{case}, respectively, but signal a continuable error if no clause is
selected.

\begin{defmac}
etypecase keyform {(type {form}*)}*

This control construct is similar to \cdf{typecase}, but no explicit
\cdf{otherwise} or \cdf{t} clause is permitted. If no clause is satisfied,
\cdf{etypecase} signals an error (of type \cdf{type-error}) with a message
constructed from the clauses.  It is not permissible to continue from this
error. To supply an error message, the user should use \cdf{typecase} with an
\cdf{otherwise} clause containing a call to \cdf{error}. The name of this
function stands for ``exhaustive type case'' or ``error-checking type case.''

Example:
\begin{lisp}
Lisp> (setq x 1/3) \\*
~\EV\ 1/3 \\
Lisp> (etypecase x \\*
~~~~~~~~(integer (* x 4)) \\*
~~~~~~~~(symbol~(symbol-value x))) \\
Error: The value of X, 1/3, is neither an integer nor a symbol. \\*
To continue, type :CONTINUE followed by an option number: \\*
~1: Return to Lisp Toplevel. \\*
Debug>
\end{lisp}
\end{defmac}

\begin{defmac}
ctypecase keyplace {(type {form}*)}*

This control construct is similar to \cdf{typecase}, but no explicit
\cdf{otherwise} or \cdf{t} clause is permitted.

The \emph{keyplace} must be a generalized variable reference acceptable to
\cdf{setf}.  If no clause is satisfied, \cdf{ctypecase} signals an error (of
type \cdf{type-error}) with a message constructed from the clauses. This error
may be continued using the \cdf{store-value} restart. The argument to
\cdf{store-value} is stored in \emph{keyplace} and then \cdf{ctypecase} starts
over, making the type tests again.  Subforms of \emph{keyplace} may be evaluated
multiple times. If the \cdf{store-value} restart is invoked interactively, the
user will be prompted for the value to be used.
  
The name of this function is mnemonic for ``continuable (exhaustive) type
case.''

Example:
\begin{lisp}
Lisp> (setq x 1/3) \\*
~\EV\ 1/3 \\
Lisp> (ctypecase x \\*
~~~~~~~~(integer (* x 4)) \\*
~~~~~~~~(symbol (symbol-value x))) \\
Error: The value of X, 1/3, is neither an integer nor a symbol. \\*
To continue, type :CONTINUE followed by an option number: \\
~1: Specify a value to use instead. \\*
~2: Return to Lisp Toplevel. \\
Debug> :continue 1 \\*
Use value: 3.7 \\
Error: The value of X, 3.7, is neither an integer nor a symbol. \\*
To continue, type :CONTINUE followed by an option number: \\*
~1: Specify a value to use instead. \\*
~2: Return to Lisp Toplevel. \\
Debug> :continue 1 \\*
Use value: 12 \\*
~\EV\ 48
\end{lisp}
\end{defmac}


\begin{defmac}
ecase keyform {({({key}*) | key} {form}*)}*

This control construct is similar to \cdf{case}, but no explicit \cdf{otherwise}
or \cdf{t} clause is permitted. If no clause is satisfied, \cdf{ecase} signals
an error (of type \cdf{type-error}) with a message constructed from the
clauses. It is not permissible to continue from this error. To supply an error
message, the user should use \cdf{case} with an \cdf{otherwise} clause
containing a call to \cdf{error}.  The name of this function stands for
``exhaustive case'' or ``error-checking case.''

Example:
\begin{lisp}
Lisp> (setq x 1/3) \\*
~\EV\ 1/3 \\
Lisp> (ecase x \\*
~~~~~~~~(alpha (foo)) \\*
~~~~~~~~(omega (bar)) \\*
~~~~~~~~((zeta phi) (baz))) \\
Error: The value of X, 1/3, is not ALPHA, OMEGA, ZETA, or PHI. \\*
To continue, type :CONTINUE followed by an option number: \\*
~1: Return to Lisp Toplevel. \\*
Debug>
\end{lisp}
\end{defmac}

\begin{defmac}
ccase keyplace {({({key}*) | key} {form}*)}*

This control construct is similar to \cdf{case}, but no explicit \cdf{otherwise}
or \cdf{t} clause is permitted.

The \emph{keyplace} must be a generalized variable reference acceptable to
\cdf{setf}.  If no clause is satisfied, \cdf{ccase} signals an error (of type
\cdf{type-error}) with a message constructed from the clauses. This error may be
continued using the \cdf{store-value} restart. The argument to \cdf{store-value}
is stored in \emph{keyplace} and then \cdf{ccase} starts over, making the type
tests again. Subforms of \emph{keyplace} may be evaluated multiple times. If the
\cdf{store-value} restart is invoked interactively, the user will be prompted
for the value to be used.

The name of this function is mnemonic for ``continuable (exhaustive) case.''

\beforenoterule
\begin{implementation}
  The \cdf{type-error} signaled by \cdf{ccase} and \cdf{ecase} is free to
  choose any representation of the acceptable argument type that it wishes
  for placement in the expected-type slot. It will always work to use type
  \cd{(member . \emph{keys})}, but in some cases it may be more efficient, for example,
  to use a type that represents an integer subrange or a type composed using the
  \cdf{or} type specifier.
\end{implementation}
\afternoterule
\end{defmac}

\subsection{Handling Conditions}

These macros allow a program to gain control when a condition is signaled.

\begin{defmac}
handler-case expression {(typespec ([var]) {form}*)}*

Executes the given \emph{expression} in a context where various specified
handlers are active.

Each \emph{typespec} may be any type specifier. If during the execution of the
\emph{expression} a condition is signaled for which there is an appropriate
clause---that is, one for which \cd{(typep \emph{condition} '\emph{typespec})}
is true---and if there is no intervening handler for conditions of that type,
then control is transferred to the body of the relevant clause (unwinding the
dynamic state appropriately in the process) and the given variable \cdf{var} is
bound to the condition that was signaled. If no such condition is signaled and
the computation runs to completion, then the values resulting from the
\emph{expression} are returned by the \cdf{handler-case} form.

If more than one case is provided, those cases are made accessible in
parallel. That is, in
\begin{lisp}
(handler-case \emph{expression} \\*
~~(\emph{type\SU{1}} (\emph{var\SU{1}}) \emph{form\SU{1}}) \\*
~~(\emph{type\SU{2}} (\emph{var\SU{2}}) \emph{form\SU{2}}))
\end{lisp}
if the first clause (containing \emph{form\SU{1}}) has been selected, the
handler for the second is no longer visible (and vice versa).

The cases are searched sequentially from top to bottom. If a signaled condition
matches more than one case (possible if there is type overlap) the earlier of
the two cases will be selected.

If the variable \emph{var} is not needed, it may be omitted. That is, a clause
such as
\begin{lisp}
(\emph{type} (\emph{var}) (declare (ignore \emph{var})) \emph{form})
\end{lisp}
may be written using the following shorthand notation:
\begin{lisp}
(\emph{type} () \emph{form})
\end{lisp}

If there are no forms in a selected case, the case returns \cdf{nil}.  Note that
\begin{lisp}
(handler-case \emph{expression} \\*
~~(\emph{type\SU{1}} (\emph{var\SU{1}}) . \emph{body\SU{1}}) \\*
~~(\emph{type\SU{2}} (\emph{var\SU{2}}) . \emph{body\SU{2}}) \\*
~~...)
\end{lisp}
is approximately equivalent to
\begin{lisp}
(block \#1=\#:block-1 \\*
~~(let (\#2=\#:var-2) \\*
~~~~(tagbody \\*
~~~~~~(handler-bind ((\emph{type\SU{1}} \=\#'(lambda (temp) \\*
\>~~~~(setq \#2\# temp) \\*
\>~~~~(go \#3=\#:tag-3))) \\
~~~~~~~~~~~~~~~~~~~~~(\emph{type\SU{2}} \=\#'(lambda (temp) \\*
\>~~~~(setq \#2\# temp) \\*
\>~~~~(go \#4=\#:tag-4))) \\*
~~~~~~~~~~~~~~~~~~~~~...) \\*
~~~~~~~~(return-from \#1\# \emph{expression})) \\
~~~~~~\#3\# (return-from \#1\# (let ((\emph{var\SU{1}} \#2\#)) . \emph{body\SU{1}})) \\*
~~~~~~\#4\# (return-from \#1\# (let ((\emph{var\SU{2}} \#2\#)) . \emph{body\SU{2}})) \\*
~~~~~~...)))
\end{lisp}
[Note the use of ``gensyms'' such as \cd{\#:block-1}
as block names, variables, and \cdf{tagbody} tags in this example,
and the use of \cd{\#\emph{n}=} and \cd{\#\emph{n}\#} read-macro syntax
to indicate that the very same gensym appears in multiple places.---GLS]

As a special case, the \emph{typespec} can also be the symbol \cd{:no-error} in
the last clause.  If it is, it designates a clause that will take control if the
\emph{expression} returns normally. In that case, a completely general
lambda-list may follow the symbol \cd{:no-error}, and the arguments to which the
lambda-list parameters are bound are like those for \cdf{multiple-value-call} on
the return value of the \emph{expression}.  For example,
\begin{lisp}
(handler-case \emph{expression} \\*
~~(\emph{type\SU{1}} (\emph{var\SU{1}}) . \emph{body\SU{1}}) \\*
~~(\emph{type\SU{2}} (\emph{var\SU{2}}) . \emph{body\SU{2}}) \\*
~~... \\*
~~(\emph{type\SU{n}} (\emph{var\SU{n}}) . \emph{body\SU{n}}) \\*
~~(:no-error (\emph{nvar\SU{1}} \emph{nvar\SU{2}} ... \emph{nvar\SU{m}}) . \emph{nbody}))
\end{lisp}
is approximately equivalent to
\begin{lisp}
(block \#1=\#:error-return \\*
~~(multiple-value-call \#'(lambda (\emph{nvar\SU{1}} \emph{nvar\SU{2}} ... \emph{nvar\SU{m}}) . \emph{nbody}) \\*
~~~~(block \#2=\#:normal-return \\*
~~~~~~(return-from \#1\# \\*
~~~~~~~~(handler-case (return-from \#2\# \emph{expression}) \\*
~~~~~~~~~~(\emph{type\SU{1}} (\emph{var\SU{1}}) . \emph{body\SU{1}}) \\*
~~~~~~~~~~(\emph{type\SU{2}} (\emph{var\SU{2}}) . \emph{body\SU{2}}) \\*
~~~~~~~~~~... \\*
~~~~~~~~~~(\emph{type\SU{n}} (\emph{var\SU{n}}) . \emph{body\SU{n}}))))))
\end{lisp}

Examples of the use of \cdf{handler-case}:
\begin{lisp}
(handler-case (/ x y) \\*
~~(division-by-zero () nil)) \\
 \\
(handler-case (open *the-file* :direction :input) \\*
~~(file-error (condition) (format t "{\Xtilde}\&Fooey: {\Xtilde}A{\Xtilde}\%" condition))) \\
 \\
(handler-case (some-user-function) \\*
~~(file-error (condition) condition) \\*
~~(division-by-zero () 0) \\*
~~((or unbound-variable undefined-function) () 'unbound)) \\
 \\
(handler-case (intern x y) \\*
~~(error (condition) condition) \\*
~~(:no-error (symbol status) \\*
~~~~(declare (ignore symbol)) \\*
~~~~status))
\end{lisp}
\end{defmac}

\begin{defmac}
ignore-errors {form}*

Executes its body in a context that handles conditions of type \cdf{error} by
returning control to this form. If no such condition is signaled, any values
returned by the last form are returned by \cdf{ignore-errors}. Otherwise, two
values are returned: \cdf{nil} and the \cdf{error} condition that was signaled.

\cdf{ignore-errors} could be defined by
\begin{lisp}
(defmacro ignore-errors (\&body forms) \\*
~~{\Xbq}(handler-case (progn ,{\Xatsign}forms) \\*
~~~~~(error (c) (values nil c))))
\end{lisp}
\end{defmac}

\begin{defmac}
handler-bind ({(typespec handler)}*) {form}*

Executes body in a dynamic context where the given handler bindings are in
effect.  Each \emph{typespec} may be any type specifier.  Each \emph{handler}
form should evaluate to a function to be used to handle conditions of the given
type(s) during execution of the \emph{form\/}s. This function should take a
single argument, the condition being signaled.

If more than one binding is specified, the bindings are searched sequentially
from top to bottom in search of a match (by visual analogy with
\cdf{typecase}). If an appropriate \emph{typespec} is found, the associated
handler is run in a context where none of the handler bindings are visible (to
avoid recursive errors). For example, in the case of
\begin{lisp}
(handler-bind ((unbound-variable \#'(lambda ...)) \\*
~~~~~~~~~~~~~~~(error \#'(lambda ...))) \\*
~~...)
\end{lisp}
if an unbound variable error is signaled in the body (and not handled by an
intervening handler), the first function will be called. If any other kind of
error is signaled, the second function will be called.  In either case, neither
handler will be active while executing the code in the associated function.
\end{defmac}

\subsection{Defining Conditions}

[The contents of this section are still a subject of some debate within X3J13.
The reader may wish to take this section with a grain of salt, two aspirin
tablets, and call a hacker in the morning.---GLS]

\begin{defmac}
define-condition name ({parent-type}*)
                 [({slot-specifier}*) {option}*]

Defines a new condition type called \emph{name}, which is a
subtype of each given \emph{parent-type}.  Except as otherwise
noted, the arguments are not evaluated.

Objects of this condition type will have all of the indicated \emph{slot\/}s,
plus any additional slots inherited from the parent types (its superclasses).
If the \emph{slot\/}s list is omitted, the empty list is assumed.

A \emph{slot} must have the form
\begin{tabbing}
\emph{slot-specifier\/} ::= \emph{slot-name\/} {\Mor} (\emph{slot-name\/}  $\lbrack\!\lbrack\downarrow\!\emph{slot-option}\,\rbrack\!\rbrack$)
\end{tabbing}
For the syntax of a \emph{slot-option}, see \cdf{defclass}.
The slots of a condition object are normal CLOS slots.
Note that \cdf{with-slots} may be used instead of accessor functions to access slots of a
condition object.

\cdf{make-condition} will accept keywords (in the keyword package) with the
print name of any of the designated slots, and will initialize the corresponding
slots in conditions it creates.

Accessors are created according to the same rules as used by \cdf{defclass}.

The valid \emph{options} are as follows:

\begin{flushdesc}
\item[\cd{(:documentation \emph{doc-string})}]

  The \emph{doc-string} should be either \cdf{nil} or a string that describes
  the purpose of the condition type. If this option is omitted, \cdf{nil} is
  assumed.  Calling \cd{(documentation '\emph{name} 'type)} will retrieve this
  information.

\item[\cd{(:report \emph{exp})}]

  If \emph{exp} is not a literal string, it must be a suitable argument to the
  \cdf{function} special operator. The expression \cd{(function~\emph{exp})}
  will be evaluated in the current lexical environment. It should produce a
  function of two arguments, a condition and a stream, that prints on the stream
  a description of the condition. This function is called whenever the condition
  is printed while \cdf{*print-escape*} is \cdf{nil}.

  If \emph{exp} is a literal string, it is shorthand for
  \begin{lisp}
    (lambda (c s) \\*
    ~~(declare (ignore c)) \\*
    ~~(write-string \emph{exp} s))
  \end{lisp}
  [That is, a function is provided that will simply write the given
  string literally to the stream, regardless of the particular condition object
  supplied.---GLS]

  The \cd{:report} option is processed \emph{after} the new condition type has
  been defined, so use of the slot accessors within the report function is
  permitted.  If this option is not specified, information about how to report
  this type of condition will be inherited from the \emph{parent-type}.
\end{flushdesc}

[X3J13 voted in March 1989 \issue{ZLOS-CONDITIONS} to integrate the
Condition System and the Object System.
In the original Condition System proposal, \cdf{define-condition}
allowed only one \emph{parent-type} (the inheritance structure was a simple
hierarchy).
Slot descriptions were much simpler, even simpler than those for \cdf{defstruct}:
\begin{tabbing}
\emph{slot} ::= \emph{slot-name} {\Mor} (\emph{slot-name}) {\Mor} (\emph{slot-name} \emph{default-value})
\end{tabbing}
Similarly, \cdf{define-condition} allowed
a \cd{:conc-name} option similar to that of \cdf{defstruct}:
\begin{flushdesc}
\item[\cd{(:conc-name \emph{symbol-or-string})}]

     \textbf{Not now part of Common Lisp.}
     As with \cdf{defstruct}, this sets up automatic prefixing of the names 
     of slot accessors. Also as in \cdf{defstruct}, the default behavior 
     is to use the name of the new type, \emph{name}, followed by a hyphen.
     (Generated names are interned in the package that is current at the time that the 
     \cdf{define-condition} is processed).
\end{flushdesc}
One consequence of the vote was to make \cdf{define-condition} slot descriptions
like those of \cdf{defclass}.---GLS]

Here are some examples of the use of \cdf{define-condition}.

The following form defines a condition of type \cd{peg/hole-mismatch} that
inherits from a condition type called \cdf{blocks-world-error}:
\begin{lisp}
(define-condition peg/hole-mismatch (blocks-world-error) \\*
~~~~~~~~~~~~~~~~~~(peg-shape hole-shape) \\*
~~(:report \\
~~~~(lambda (condition stream) \\*
~~~~~~(with-slots (peg-shape hole-shape) condition \\*
~~~~~~~~(format stream "A {\Xtilde}A peg cannot go in a {\Xtilde}A hole." \\*
~~~~~~~~~~~~~~~~peg-shape hole-shape))))
\end{lisp}
The new type has slots \cdf{peg-shape} and \cdf{hole-shape}, so
\cdf{make-condition} will accept \cd{:peg-shape} and \cd{:hole-shape}
keywords. The \cdf{with-slots} macro may be used to access the \cdf{peg-shape}
and \cdf{hole-shape} slots, as illustrated in the \cd{:report} information.

Here is another example. This defines a condition called \cdf{machine-error}
that inherits from \cdf{error}:
\begin{lisp}
(define-condition machine-error (error) \\*
~~~~~~~~~~~~~~~~~~((machine-name \\*
~~~~~~~~~~~~~~~~~~~~:reader machine-error-machine-name)) \\
~~(:report (lambda (condition stream) \\*
~~~~~~~~~~~~~(format stream "There is a problem with {\Xtilde}A." \\*
~~~~~~~~~~~~~~~~~~~~~(machine-error-machine-name condition)))))
\end{lisp}
Building on this definition, we can define a new error condition that is a
subtype of \cdf{machine-error} for use when machines are not available:
\begin{lisp}
(define-condition machine-not-available-error (machine-error) () \\*
~~(:report (lambda (condition stream) \\*
~~~~~~~~~~~~~(format stream "The machine {\Xtilde}A is not available." \\*
~~~~~~~~~~~~~~~~~~~~~(machine-error-machine-name condition)))))
\end{lisp}
We may now define a still more specific condition, built upon
\cd{machine-not-available-error}, that provides a default for \cdf{machine-name}
but does not provide any new slots or report information. It just gives the
\cdf{machine-name} slot a default initialization:
\begin{lisp}
(define-condition my-favorite-machine-not-available-error \\*
~~~~~~~~~~~~~~~~~~(machine-not-available-error) \\*
~~~~~~~~~~~~~~~~~~((machine-name :initform "MC.LCS.MIT.EDU")))
\end{lisp}
Note that since no \cd{:report} clause was given, the information inherited from
\cdf{machine-not-available-error} will be used to report this type of condition.
\end{defmac}

\subsection{Creating Conditions}

The function \cdf{make-condition} is the basic means for
creating condition objects.

\begin{defun}[Function]
make-condition type &rest slot-initializations

Constructs a condition object of the given \emph{type} using
\emph{slot-initializations} as a specification of the initial value of the
slots. The newly created condition is returned.

The \emph{slot-initializations} are alternating keyword/value pairs.  For
example:
\begin{lisp}
(make-condition 'peg/hole-mismatch \\*
~~~~~~~~~~~~~~~~:peg-shape 'square :hole-shape 'round)
\end{lisp}
\end{defun}

\subsection{Establishing Restarts}

The lowest-level form that creates restart points is called \cdf{restart-bind}.
The \cdf{restart-case} macro is an abstraction that addresses many common needs
for \cdf{restart-bind} while offering a more palatable syntax. See also
\cdf{with-simple-restart}.  The function that transfers control to a restart
point established by one of these macros is called \cdf{invoke-restart}.

All restarts have dynamic extent; a restart does not survive execution of the
form that establishes it.

\begin{defmac}
with-simple-restart (name format-string {format-argument}*)
                    {form}*

This is shorthand for one of the most common uses of \cdf{restart-case}.

If the restart designated by \emph{name} is not invoked while executing the
\emph{form\/}s, all values returned by the last \emph{form} are returned. If
that restart is invoked, control is transferred to the \cdf{with-simple-restart}
form, which immediately returns the two values \cdf{nil} and \cdf{t}.

The \emph{name} may be \cdf{nil}, in which case an anonymous restart is
established.

\cdf{with-simple-restart} could be defined by
\begin{lisp}
(defmacro with-simple-restart ((restart-name format-string \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\&rest format-arguments) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\&body forms) \\
~~{\Xbq}(restart-case (progn ,{\Xatsign}forms) \\*
~~~~~(,restart-name () \\*
~~~~~~~:report \\*
~~~~~~~~~(lambda (stream) \\*
~~~~~~~~~~~(format stream format-string ,{\Xatsign}format-arguments)) \\*
~~~~~~~(values nil t))))
\end{lisp}

Here is an example of the use of \cdf{with-simple-restart}.
\begin{lisp}
Lisp> (defun read-eval-print-loop (level) \\*
~~~~~~~~(with-simple-restart \\*
~~~~~~~~~~~~(abort "Exit command level {\Xtilde}D." level) \\*
~~~~~~~~~~(loop \\*
~~~~~~~~~~~~(with-simple-restart \\*
~~~~~~~~~~~~~~~~(abort "Return to command level {\Xtilde}D." level) \\*
~~~~~~~~~~~~~~(let ((form (prog2 (fresh-line) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(read) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(fresh-line)))) \\*
~~~~~~~~~~~~~~~~(prin1 (eval form))))))) \\*
~\EV\ READ-EVAL-PRINT-LOOP \\
Lisp> (read-eval-print-loop 1) \\*
(+ 'a 3) \\
Error: The argument, A, to the function + was of the wrong type. \\*
~~~~~~~The function expected a number. \\*
To continue, type :CONTINUE followed by an option number: \\*
~1: Specify a value to use this time. \\*
~2: Return to command level 1. \\*
~3: Exit command level 1. \\*
~4: Return to Lisp Toplevel. \\*
Debug> 
\end{lisp}

\beforenoterule
\begin{sideremark}
Some readers may wonder what ought to be done by the ``abort'' key (or whatever
the implementation's interrupt key is---Control-C or Control-G, for
example). Such interrupts, whether synchronous or asynchronous in nature, are
beyond the scope of this chapter and indeed are not currently addressed by
Common Lisp at all. This may be a topic worth standardizing under separate
cover. Here is some speculation about some possible things that might happen.

An implementation might simply call \cdf{abort} or \cdf{break} directly without
signaling any condition.

Another implementation might signal some condition related to the fact that a
key had been pressed rather than to the action that should be taken. This is one
way to allow user customization.  Perhaps there would be an
implementation-dependent \cdf{keyboard-interrupt} condition type with a slot
containing the key that was pressed---or perhaps there would be such a condition
type, but rather than its having slots, different subtypes of that type with
names like \cdf{keyboard-abort}, \cdf{keyboard-break}, and so on might be
signaled. That implementation would then document the action it would take if
user programs failed to handle the condition, and perhaps ways for user programs
to usefully dismiss the interrupt.
\end{sideremark}
\betweennoterule
\begin{implementation}
Implementors are encouraged to make sure that there is always a restart named
\cdf{abort} around any user code so that user code  can call \cdf{abort} at any
time and expect something reasonable to happen; exactly what the reasonable
thing is may vary somewhat. Typically, in an interactive program, invoking
\cdf{abort} should return the user to top level, though in some batch or
multi-processing situations killing the running process might be more
appropriate.
\end{implementation}
\afternoterule
\end{defmac}

\begin{defmac}
restart-case expression {(case-name arglist
                         {keyword value}*
                         {form}*)}*

The \emph{expression} is evaluated in a dynamic context where the clauses have
special meanings as points to which control may be transferred. If the
\emph{expression} finishes executing and returns any values, all such values are
simply returned by the \cdf{restart-case} form. While the \emph{expression} is
running, any code may transfer control to one of the clauses (see
\cdf{invoke-restart}). If a transfer occurs, the \emph{form\/}s in the body of
that clause will be evaluated and any values returned by the last such
\emph{form} will be returned by the \cdf{restart-case} form.

As a special case, if the \emph{expression} is a list whose \emph{car} is
\cdf{signal}, \cdf{error}, \cdf{cerror}, or \cdf{warn}, then
\cdf{with-condition-restarts} is implicitly used to associate the restarts with
the condition to be signaled.  For example,
\begin{lisp}
(restart-case (signal weird-error) \\*
~~(become-confused ...) \\*
~~(rewind-line-printer ...) \\*
~~(halt-and-catch-fire ...))
\end{lisp}
is equivalent to
\begin{lisp}
(restart-case (with-condition-restarts \\*
~~~~~~~~~~~~~~~~weird-error  \\*
~~~~~~~~~~~~~~~~(list (find-restart 'become-confused)  \\*
~~~~~~~~~~~~~~~~~~~~~~(find-restart 'rewind-line-printer) \\*
~~~~~~~~~~~~~~~~~~~~~~(find-restart 'halt-and-catch-fire)) \\*
~~~~~~~~~~~~~~~~(signal weird-error)) \\
~~(become-confused ...) \\*
~~(rewind-line-printer ...) \\*
~~(halt-and-catch-fire ...))
\end{lisp}

If there are no \emph{form\/}s in a selected clause, \cdf{restart-case} returns
\cdf{nil}.

The \emph{case-name} may be \cdf{nil} or a symbol naming this restart.

It is possible to have more than one clause use the same \emph{case-name}.  In
this case, the first clause with that name will be found by
\cdf{find-restart}. The other clauses are accessible using
\cdf{compute-restarts}.  [In this respect, \cdf{restart-case} is rather
different from \cdf{case}!---GLS]

Each \emph{arglist} is a normal lambda-list containing parameters to be bound
during the execution of its corresponding \emph{form\/}s. These parameters are
used to pass any necessary data from a call to \cdf{invoke-restart} to the
\cdf{restart-case} clause.

By default, \cdf{invoke-restart-interactively} will pass no arguments and all
parameters must be optional in order to accommodate interactive
restarting. However, the parameters need not be optional if the
\cd{:interactive} keyword has been used to inform
\cdf{invoke-restart-interactively} about how to compute a proper argument list.

The valid \emph{keyword value} pairs are the following:
\begin{flushdesc}
\item[\cd{:test \emph{fn}}]

  The \emph{fn} must be a suitable argument for the \cdf{function} special
  operator. The expression \cd{(function~\emph{fn})} will be evaluated in the
  current lexical environment. It should produce a function of one argument, a
  condition.  If this function returns \cdf{nil} when given some condition,
  functions such as \cdf{find-restart}, \cdf{compute-restart}, and
  \cdf{invoke-restart} will not consider this restart when searching for
  restarts associated with that condition.  If this pair is not supplied, it is
  as if
\begin{lisp}
  (lambda (c) (declare (ignore c)) t)
\end{lisp}
 were used for the \emph{fn}.

\item[\cd{:interactive \emph{fn}}]

  The \emph{fn} must be a suitable argument for the \cdf{function} special
  operator. The expression \cd{(function~\emph{fn})} will be evaluated in the
  current lexical environment. It should produce a function of no arguments that
  returns arguments to be used by \cdf{invoke-restart-interactively} when
  invoking this function. This function will be called in the dynamic
  environment available prior to any restart attempt. It may interact with the
  user on the stream in \cdf{*query-io*}.

  If a restart is invoked interactively but no \cd{:interactive} option was
  supplied, the argument list used in the invocation is the empty list.

\item[\cd{:report \emph{exp}}]

  If \emph{exp} is not a literal string, it must be a suitable argument to the
  \cdf{function} special operator. The expression \cd{(function~\emph{exp})}
  will be evaluated in the current lexical environment. It should produce a
  function of one argument, a stream, that prints on the stream a description of
  the restart. This function is called whenever the restart is printed while
  \cdf{*print-escape*} is \cdf{nil}.

  If \emph{exp} is a literal string, it is shorthand for
  \begin{lisp}
    (lambda (s) (write-string \emph{exp} s))
  \end{lisp}
  [That is, a function is provided that will simply write the given
  string literally to the stream.---GLS]

  If a named restart is asked to report but no report information has been
  supplied, the name of the restart is used in generating default report text.

  When \cdf{*print-escape*} is \cdf{nil}, the printer will use the report
  information for a restart. For example, a debugger might announce the action
  of typing ``\cd{:continue}'' by executing the equivalent of
  \begin{lisp}
    (format *debug-io* "{\Xtilde}\&{\Xtilde}S -- {\Xtilde}A{\Xtilde}\%" ':continue some-restart)
  \end{lisp}
  which might then display as something like
  \begin{lisp}
    :CONTINUE -- Return to command level.
  \end{lisp}

  It is an error if an unnamed restart is used and no report information
  is provided.

\beforenoterule
\begin{rationale}
Unnamed restarts are required to have report information on
the grounds that they are generally only useful interactively, and an
interactive option that has no description is of little value.
\end{rationale}
\betweennoterule
\begin{implementation}
Implementations are encouraged to warn about this error
at compilation time.

At run time, this error might be noticed when entering the debugger. Since
signaling an error would probably cause recursive entry into the debugger
(causing yet another recursive error, and so on), it is suggested that the
debugger print some indication of such problems when they occur, but not
actually signal errors.
\end{implementation}
\afternoterule

\end{flushdesc}

Note that 
\begin{lisp}
(restart-case \emph{expression} \\*
~~(\emph{name\SU{1}} \emph{arglist\SU{1}} \emph{options\SU{1}} . \emph{body\SU{1}}) \\*
~~(\emph{name\SU{2}} \emph{arglist\SU{2}} \emph{options\SU{2}} . \emph{body\SU{2}}) \\*
~~...)
\end{lisp}
is essentially equivalent to
\begin{lisp}
(block \#1=\#:block-1 \\*
~~(let ((\#2=\#:var-2 nil)) \\*
~~~~(tagbody \\*
~~~~~~(restart-bind ((\emph{name\SU{1}} \=\#'(lambda (\&rest temp) \\*
\>~~~~(setq \#2\# temp) \\*
\>~~~~(go \#3=\#:tag-3)) \\*
\>\textrm{$\langle$slightly transformed \emph{options\SU{1}}$\rangle$}) \\
~~~~~~~~~~~~~~~~~~~~~(\emph{name\SU{2}} \=\#'(lambda (\&rest temp) \\*
\>~~~~(setq \#2\# temp) \\*
\>~~~~(go \#4=\#:tag-4)) \\*
\>\textrm{$\langle$slightly transformed \emph{options\SU{2}}$\rangle$}) \\*
~~~~~~~~~~~~~~~~~~~~~...) \\*
~~~~~~~~(return-from \#1\# expression)) \\
~~~~~~\#3\# (return-from \#1\# \\*
~~~~~~~~~~~~~~~~(apply \#'(lambda \emph{arglist\SU{1}} . \emph{body\SU{1}}) \#2\#)) \\
~~~~~~\#4\# (return-from \#1\# \\*
~~~~~~~~~~~~~~~~(apply \#'(lambda \emph{arglist\SU{2}} . \emph{body\SU{2}}) \#2\#)) \\*
~~~~~~...)))
\end{lisp}
[Note the use of ``gensyms'' such as \cd{\#:block-1} as block names,
variables, and \cdf{tagbody} tags in this example,
and the use of \cd{\#\emph{n}=} and \cd{\#\emph{n}\#} read-macro syntax
to indicate that the very same gensym appears in multiple places.---GLS]


Here are some examples of the use of \cdf{restart-case}.
\begin{lisp}
(loop \\*
~~(restart-case (return (apply function some-args)) \\*
~~~~(new-function (new-function) \\*
~~~~~~~~:report "Use a different function." \\*
~~~~~~~~:interactive \\*
~~~~~~~~~~(lambda () \\*
~~~~~~~~~~~~(list (prompt-for 'function "Function: "))) \\*
~~~~~~(setq function new-function)))) \\
 \\
(loop \\*
~~(restart-case (return (apply function some-args)) \\*
~~~~(nil (new-function) \\*
~~~~~~~~:report "Use a different function." \\*
~~~~~~~~:interactive \\*
~~~~~~~~~~(lambda () \\*
~~~~~~~~~~~~(list (prompt-for 'function "Function: "))) \\*
~~~~~~(setq function new-function)))) \\
 \\
(restart-case (a-command-loop) \\*
~~(return-from-command-level () \\*
~~~~~~:report \\*
~~~~~~~~(lambda (s)~~~~~;\textrm{Argument \cdf{s} is a stream} \\*
~~~~~~~~~~(format s "Return from command level {\Xtilde}D." level)) \\*
~~~~nil)) \\
 \\
(loop  \\*
~~(restart-case (another-random-computation) \\*
~~~~(continue () nil)))
\end{lisp}
The first and second examples are equivalent from the point of view of someone
using the interactive debugger, but they differ in one important aspect for
non-interactive handling. If a handler ``knows about'' named restarts, as in,
for example,
\begin{lisp}
(when (find-restart 'new-function) \\*
~~(invoke-restart 'new-function the-replacement))
\end{lisp}
then only the first example, and not the second, will have control transferred
to its correction clause, since only the first example uses a restart named
\cdf{new-function}.

Here is a more complete example:
\begin{lisp}
(let ((my-food 'milk) \\*
~~~~~~(my-color 'greenish-blue)) \\*
~~(do () \\*
~~~~~~((not (bad-food-color-p my-food my-color))) \\*
~~~~(restart-case (error 'bad-food-color \\*
~~~~~~~~~~~~~~~~~~~~~~~~~:food my-food :color my-color) \\*
~~~~~~(use-food (new-food) \\*
~~~~~~~~~~:report "Use another food." \\*
~~~~~~~~(setq my-food new-food)) \\
~~~~~~(use-color (new-color) \\*
~~~~~~~~~~:report "Use another color." \\*
~~~~~~~~(setq my-color new-color)))) \\*
~~;; We won't get to here until MY-FOOD \\*
~~;; and MY-COLOR are compatible. \\*
~~(list my-food my-color))
\end{lisp}
Assuming that \cdf{use-food} and \cdf{use-color} have been defined as
\begin{lisp}
(defun use-food (new-food) \\*
~~(invoke-restart 'use-food new-food)) \\
\\
(defun use-color (new-color) \\*
~~(invoke-restart 'use-color new-color))
\end{lisp}
a handler can then restart from the error in either of two ways.
It may correct the color or correct the food. For example:
\begin{lisp}
\#'(lambda (c) ... (use-color 'white) ...)~~~;\textrm{Corrects \cdf{color}} \\
\\
\#'(lambda (c) ... (use-food 'cheese) ...)~~~;\textrm{Corrects \cdf{food}}
\end{lisp}

Here is an example using \cdf{handler-bind} and \cdf{restart-case} that refers to a
condition type \cdf{foo-error}, presumably defined elsewhere:
\begin{lisp}
(handler-bind ((foo-error \#'(lambda (ignore) (use-value 7)))) \\*
~~(restart-case (error 'foo-error) \\*
~~~~(use-value (x) (* x x)))) \\*
~\EV\ 49
\end{lisp}
\end{defmac}


\begin{defmac}
restart-bind ({(name function {keyword value}*)}*) {form}*

Executes a body of forms in a dynamic context where the given restart bindings
are in effect.

Each \emph{name} may be \cdf{nil} to indicate an anonymous restart, or some
other symbol to indicate a named restart.

Each \emph{function} is a form that should evaluate to a function to be used to
perform the restart.  If invoked, this function may either perform a non-local
transfer of control or it may return normally. The function may take whatever
arguments the programmer feels are appropriate; it will be invoked only if
\cdf{invoke-restart} is used from a program, or if a user interactively asks the
debugger to invoke it. In the case of interactive invocation, the
\cd{:interactive-function} option is used.

The valid \emph{keyword value} pairs are as follows:
\begin{flushdesc}
\item[\cd{:test-function \emph{form}}]

  The \emph{form} will be evaluated in the current lexical environment and
  should return a function of one argument, a condition.  If this function
  returns \cdf{nil} when given some condition, functions such as
  \cdf{find-restart}, \cdf{compute-restart}, and \cdf{invoke-restart} will not
  consider this restart when searching for restarts associated with that
  condition.  If this pair is not supplied, it is as if
  \begin{lisp}
    \#'(lambda (c) (declare (ignore c)) t)
  \end{lisp}
  were used for the \emph{form}.
  
\item[\cd{:interactive-function \emph{form}}]

  The \emph{form} will be evaluated in the current lexical environment and
  should return a function of no arguments that constructs a list of arguments
  to be used by \cdf{invoke-restart-interactively} when invoking this
  restart. The function may prompt interactively using \cdf{*query-io*} if
  necessary.

\item[\cd{:report-function \emph{form}}]

  The \emph{form} will be evaluated in the current lexical environment and
  should return a function of one argument, a stream, that prints on the stream
  a summary of the action this restart will take. This function is called
  whenever the restart is printed while \cdf{*print-escape*} is \cdf{nil}.
\end{flushdesc}
\end{defmac}

\begin{defmac}
with-condition-restarts condition-form restarts-form
  {declaration}* {form}*

The value of \emph{condition-form} should be a condition \emph{C} and the value
of \emph{restarts-form} should be a list of restarts \cd{(\emph{R1} \emph{R2}
...)}.  The \emph{form\/}s of the body are evaluated as an implicit \cdf{progn}.
While in the dynamic context of the body, an attempt to find a restart
associated with a particular condition $C'$ will consider the restarts
\emph{R1}, \emph{R2}, $\ldots$ if $C'$ is \cdf{eq} to \emph{C}.

 Usually this macro is not used explicitly in code, because \cdf{restart-case}
handles most of the common uses in a way that is syntactically more concise.

[The X3J13 vote \issue{CONDITION-RESTARTS} left it unclear whether \cdf{with-condition-restarts}
permits declarations to appear at the heads of its body.
I believe that was the intent, but this is only my interpretation.---GLS]
\end{defmac}

\subsection{Finding and Manipulating Restarts}

The following functions determine what restarts are
active and invoke restarts.

\begin{defun}[Function]
compute-restarts &optional condition

Uses the dynamic state of the program to compute a list of the restarts that are
currently active. See \cdf{restart-bind}.

If \emph{condition} is \cdf{nil} or not supplied, all outstanding restarts
are returned.
If \emph{condition} is not \cdf{nil}, only restarts associated
with that condition are returned.

Each restart represents a function that can be called to perform some form of
recovery action, usually a transfer of control to an outer point in the running
program. Implementations are free to implement these objects in whatever manner
is most convenient; the objects need have only dynamic extent (relative to the
scope of the binding form that instantiates them).

The list that results from a call to \cdf{compute-restarts} is ordered so that
the inner (that is, more recently established) restarts are nearer the head of
the list.

Note, too, that \cdf{compute-restarts} returns all valid restarts, including
anonymous ones, even if some of them have the same name as others and would
therefore not be found by \cdf{find-restart} when given a symbol argument.

Implementations are permitted, but not required, to return different (that is,
non-\cdf{eq}) lists from repeated calls to \cdf{compute-restarts} while in the
same dynamic environment. It is an error to modify the list that is returned by
\cdf{compute-restarts}.
\end{defun}


\begin{defun}[Function]
restart-name restart

Returns the name of the given \emph{restart}, or \cdf{nil} if it is not named.
\end{defun}

\begin{defun}[Function]
find-restart restart-identifier &optional condition

Searches for a particular restart in the current dynamic environment.

If \emph{condition} is \cdf{nil} or not supplied, all outstanding restarts
are considered.
If \emph{condition} is not \cdf{nil}, only restarts associated
with that condition are considered.

If the \emph{restart-identifier} is a non-\cdf{nil} symbol, then the innermost
(that is, most recently established) restart with that name is returned;
\cdf{nil} is returned if no such restart is found.

If \emph{restart-identifier} is a restart object, then it is simply returned,
unless it is not currently active, in which case \cdf{nil} is returned.

Although anonymous restarts have a name of \cdf{nil}, it is an error for the
symbol \cdf{nil} to be given as the \emph{restart-identifier}.  Applications
that would seem to require this should be rewritten to make appropriate use of
\cdf{compute-restarts} instead.
\end{defun}

\begin{defun}[Function]
invoke-restart restart-identifier &rest arguments

Calls the function associated with the given \emph{restart-identifier}, passing
any given \emph{arguments}. The \emph{restart-identifier} must be a restart or
the non-null name of a restart that is valid in the current dynamic context. If
the argument is not valid, an error of type \cdf{control-error} will be
signaled.

\beforenoterule
\begin{implementation} 
Restart functions call this function, not vice versa.
\end{implementation} 
\afternoterule
\end{defun}

\begin{defun}[Function]
invoke-restart-interactively restart-identifier

Calls the function associated with the given \emph{restart-identifier},
prompting for any necessary arguments. The \emph{restart-identifier} must be a
restart or the non-null name of a restart that is valid in the current dynamic
context. If the argument is not valid, an error of type \cdf{control-error} will
be signaled.

The function \cdf{invoke-restart-interactively} will prompt for arguments by
executing the code provided in the \cd{:interactive} keyword to
\cdf{restart-case} or  \cd{:interactive-function} keyword to \cdf{restart-bind}.

If no \cd{:interactive} or \cd{:interactive-function} option has been supplied
in the corresponding \cdf{restart-case} or \cdf{restart-bind}, then it is an
error if the restart takes required arguments. If the arguments are optional, an
empty argument list will be used in this case.

Once \cdf{invoke-restart-interactively} has calculated the arguments, it simply
performs \cd{(apply~\#'invoke-restart \emph{restart-identifier}
\emph{arguments})}.

\cdf{invoke-restart-interactively} is used internally by the debugger and may
also be useful in implementing other portable, interactive debugging tools.
\end{defun}


\subsection{Warnings}
\label{WARNING-CONDITIONS}

Warnings are a subclass of errors that are conventionally regarded as ``mild.''

\begin{defun}[Function]
warn datum &rest arguments

Warns about a situation, by signaling a condition of type \cdf{warning}.

If \emph{datum} is a condition, then that condition is used directly.  In this
case, if the condition is not of type \cdf{warning} or arguments is
non-\cdf{nil}, an error of type \cdf{type-error} is signaled.

If \emph{datum} is a condition type (a class or class name), then the condition
used is effectively the result of \cd{(apply \#'make-condition \emph{datum}
\emph{arguments})}. This result must be of type \cdf{warning} or an error of
type \cdf{type-error} is signaled.

If \emph{datum} is a string, then the condition used is effectively the result
of
\begin{lisp}
(make-condition 'simple-error \\*
~~~~~~~~~~~~~~~~:format-string \emph{datum} \\*
~~~~~~~~~~~~~~~~:format-arguments \emph{arguments})
\end{lisp}

The precise mechanism for warning is as follows.
\begin{enumerate}

\item The warning condition is signaled.

  While the \cdf{warning} condition is being signaled, the \cdf{muffle-warning}
  restart is established for use by a handler to bypass further action by
  \cdf{warn} (that is, to cause \cdf{warn} to immediately return \cdf{nil}).

  As part of the signaling process, if \cd{(typep \emph{condition}
    *break-on-signals*)} is true, then a \cdf{break} will occur prior to
  beginning the signaling process.

\item If no handlers for the warning condition are found, or if all such
  handlers decline, then the condition will be reported to \cdf{*error-output*}
  by the \cdf{warn} function (with possible implementation-specific extra output
  such as motion to a fresh line before or after the display of the warning, or
  supplying some introductory text mentioning the name of the function that
  called \cdf{warn} or the fact that this is a warning).

\item The value returned by \cdf{warn} (if it returns) is \cdf{nil}.
\end{enumerate}
\end{defun}

\subsection{Restart Functions}

Common Lisp has the following restart functions built in.

\begin{defun}[Function]
abort &optional condition

This function transfers control to the restart named \cdf{abort}. If no such
restart exists, \cdf{abort} signals an error of type \cdf{control-error}.

If \emph{condition} is \cdf{nil} or not supplied, all outstanding restarts are
considered.  If \emph{condition} is not \cdf{nil}, only restarts associated with
that condition are considered.

The purpose of the \cdf{abort} restart is generally to allow control to return
to the innermost ``command level.''
\end{defun}

\begin{defun}[Function]
continue &optional condition

This function transfers control to the restart named \cdf{continue}. If no such
restart exists, \cdf{continue} returns \cdf{nil}.

If \emph{condition} is \cdf{nil} or not supplied, all outstanding restarts are
considered.  If \emph{condition} is not \cdf{nil}, only restarts associated with
that condition are considered.

The \cdf{continue} restart is generally part of simple protocols where there is
a single ``obvious'' way to continue, as with \cdf{break} and \cdf{cerror}. Some
user-defined protocols may also wish to incorporate it for similar reasons.  In
general, however, it is more reliable to design a special-purpose restart with a
name that better suits the particular application.
\end{defun}

\begin{defun}[Function]
muffle-warning &optional condition

This function transfers control to the restart named \cdf{muffle-warning}.  If
no such restart exists, \cdf{muffle-warning} signals an error of type
\cdf{control-error}.

If \emph{condition} is \cdf{nil} or not supplied, all outstanding restarts are
considered.  If \emph{condition} is not \cdf{nil}, only restarts associated with
that condition are considered.

\cdf{warn} sets up this restart so that handlers of \cdf{warning} conditions
have a way to tell \cdf{warn} that a \cdf{warning} has already been dealt with
and that no further action is warranted.
\end{defun}

\begin{defun}[Function]
store-value value &optional condition

This function transfers control (and one value) to the restart named
\cdf{store-value}. If no such restart exists, \cdf{store-value} returns
\cdf{nil}.

If \emph{condition} is \cdf{nil} or not supplied, all outstanding restarts are
considered.  If \emph{condition} is not \cdf{nil}, only restarts associated with
that condition are considered.

The \cdf{store-value} restart is generally used by handlers trying to recover
from errors of types such as \cdf{cell-error} or \cdf{type-error}, where the
handler may wish to supply a replacement datum to be stored permanently.
\end{defun}

\begin{defun}[Function]
use-value value &optional condition

This function transfers control (and one value) to the restart named
\cdf{use-value}. If no such restart exists, \cdf{use-value} returns \cdf{nil}.

If \emph{condition} is \cdf{nil} or not supplied, all outstanding restarts are
considered.  If \emph{condition} is not \cdf{nil}, only restarts associated with
that condition are considered.

The \cdf{use-value} restart is generally used by handlers trying to recover from
errors of types such as \cdf{cell-error}, where the handler may wish to supply a
replacement datum for one-time use.
\end{defun}

\subsection{Debugging Utilities}
\label{DEBUGGING-UTILITIES}

Common Lisp does not specify exactly what a debugger is or does,
but it does provide certain means for indicating intent to transfer control
to a supervisory or debugging facility.

\begin{defun}[Function]
break &optional format-string &rest format-arguments

The function \cdf{break} prints the message described by the
\emph{format-string} and \emph{format-arguments} and then goes directly into the
debugger without allowing any possibility of interception by programmed
error-handling facilities.

If no \emph{format-string} is supplied, a suitable default will be generated.

If continued, \cdf{break} returns \cdf{nil}.

Note that \cdf{break} is presumed to be used as a way of inserting temporary
debugging ``breakpoints'' in a program, not as a way of signaling errors; it is
expected that continuing from a \cdf{break} will not trigger any unusual
recovery action. For this reason, \cdf{break} does not take the additional
format control string that \cdf{cerror} takes as its first argument. This and
the lack of any possibility of interception by programmed error handling are the
only program-visible differences between \cdf{break} and \cdf{cerror}. The user
interface aspects of these functions are permitted to vary more widely; for
example, it is permissible for a read-eval-print loop to be entered by
\cdf{break} rather than by the conventional debugger.

\cdf{break} could be defined by
\begin{lisp}
(defun break (\&optional (format-string "Break") \\*
~~~~~~~~~~~~~~\&rest format-arguments) \\*
~~(with-simple-restart (continue "Return from BREAK.") \\*
~~~~(invoke-debugger \\*
~~~~~~(make-condition 'simple-condition \\*
~~~~~~~~~~~~~~~~~~~~~~:format-string format-string \\*
~~~~~~~~~~~~~~~~~~~~~~:format-arguments format-arguments))) \\*
~~nil)
\end{lisp}
\end{defun}

\begin{defun}[Function]
invoke-debugger condition

Attempts interactive handling of its argument, which must be a condition.

If the variable \cdf{*debugger-hook*} is not \cdf{nil}, it will be called as a
function on two arguments: the \emph{condition} being handled and the value of
\cdf{*debugger-hook*}.  If a hook function returns normally, the standard
debugger will be tried.

The standard debugger will never directly return. Return can occur only by a
special transfer of control, such as the use of a restart.

\beforenoterule
\begin{sideremark} 
The exact way in which the debugger interacts with users is
expected to vary considerably from system to system. For example, some systems
may use a keyboard interface, while others may use a mouse interface. Of those
systems using keyboard commands, some may use single-character commands and
others may use parsed line-at-a-time commands. The exact set of commands will
vary as well. The important properties of a debugger are that it makes
information about the error accessible and that it makes the set of apparent
restarts easily accessible.

It is desirable to have a mode where the debugger allows other features, such as
the ability to inspect data, stacks, etc. However, it may sometimes be
appropriate to have this kind of information hidden from users. Experience on
the Lisp Machines has shown that some users who are not programmers develop a
terrible phobia of debuggers. The reason for this usually may be traced to the
fact that the debugger is very foreign to them and provides an overwhelming
amount of information of interest only to programmers. With the advent of
restarts, there is a clear mechanism for the construction of ``friendly''
debuggers. Programmers can be taught how to get to the information they need for
debugging, but it should be possible to construct user interfaces to the
debugger that are natural, convenient, intelligible, and friendly even to
non-programmers.
\end{sideremark}
\afternoterule
\end{defun}

\begin{defun}[Variable]
*debugger-hook*

This variable should hold either \cdf{nil} or a function of two arguments, a
condition and the value of \cdf{*debugger-hook*}. This function may either handle
the condition (transfer control) or return normally (allowing the standard
debugger to run).

Note that, to minimize recursive errors while debugging, \cdf{*debugger-hook*} is
bound to \cdf{nil} when calling this function. When evaluating code typed in by
the user interactively, the hook function may want to bind \cdf{*debugger-hook*}
to the function that was its second argument so that recursive errors can be
handled using the same interactive facility.
\end{defun}


\section{Predefined Condition Types}        
\label{PREDEFINED-CONDITIONS-SECTION}

[The proposal for the Common Lisp Condition System introduced
a new notation for documenting types, treating them in the
same syntactic manner as functions and variables.  This notation
is used in this section but is not reflected
throughout the entire book.---GLS]

X3J13 voted in March 1989 \issue{ZLOS-CONDITIONS} to integrate
the Condition System and the Object System. 

All condition types
are CLOS classes and all condition objects are ordinary CLOS objects.

\begin{defun}[Type]
restart

This is the data type used to represent a restart.
\end{defun}

\begin{table}[t]
\caption{Condition Type Hierarchy}
\label{CONDITION-HIERARCHY-TABLE}
\begin{lisp}
condition \\
~~~~simple-condition \\
~~~~serious-condition \\
~~~~~~~~error \\
~~~~~~~~~~~~simple-error \\
~~~~~~~~~~~~arithmetic-error \\
~~~~~~~~~~~~~~~~division-by-zero \\
~~~~~~~~~~~~~~~~floating-point-overflow \\
~~~~~~~~~~~~~~~~floating-point-underflow \\
~~~~~~~~~~~~~~~~... \\
~~~~~~~~~~~~cell-error \\
~~~~~~~~~~~~~~~~unbound-variable \\
~~~~~~~~~~~~~~~~undefined-function \\
~~~~~~~~~~~~~~~~... \\
~~~~~~~~~~~~control-error \\
~~~~~~~~~~~~file-error \\
~~~~~~~~~~~~package-error \\
~~~~~~~~~~~~program-error \\
~~~~~~~~~~~~stream-error \\
~~~~~~~~~~~~~~~~end-of-file \\
~~~~~~~~~~~~~~~~... \\
~~~~~~~~~~~~type-error \\
~~~~~~~~~~~~~~~~simple-type-error \\
~~~~~~~~~~~~~~~~... \\
~~~~~~~~~~~~... \\
~~~~~~~~storage-condition \\
~~~~~~~~... \\
~~~~warning \\
~~~~~~~~simple-warning \\
~~~~~~~~... \\
~~~~...
\end{lisp}
\vfill
\end{table}

The Common Lisp condition type hierarchy is illustrated in
table~\ref{CONDITION-HIERARCHY-TABLE}.

The types that are not leaves in the hierarchy (that is, \cdf{condition},
\cdf{warning}, \cdf{storage-condition}, \cdf{error}, \cdf{arithmetic-error},
\cdf{control-error}, and so on) are provided primarily for type inclusion
purposes. Normally they would not be directly instantiated.

Implementations are permitted to support non-portable synonyms for these types,
as well as to introduce other types that are above, below, or between the types
shown in this tree as long as the indicated subtype relationships are not
violated.

The types \cdf{simple-condition}, \cdf{serious-condition}, and \cdf{warning} are
pairwise disjoint. The type \cdf{error} is also disjoint from types
\cdf{simple-condition} and \cdf{warning}.

\begin{defun}[Type]
condition

All types of conditions, whether error or non-error, must inherit from this
type.
\end{defun}

\begin{defun}[Type]
warning

All types of warnings should inherit from this type.  This is a subtype of
\cdf{condition}.
\end{defun}

\begin{defun}[Type]
serious-condition

All serious conditions (conditions serious enough to require interactive
intervention if not handled) should inherit from this type. This is a subtype of
\cdf{condition}.

This condition type is provided primarily for terminological convenience.  In
fact, signaling a condition that inherits from \cdf{serious-condition} does not
force entry into the debugger. Rather, it is conventional to use \cdf{error} (or
something built on \cdf{error}) to signal conditions that are of this type, and
to use \cdf{signal} to signal conditions that are not of this type.
\end{defun}

\begin{defun}[Type]
error

All types of error conditions inherit from this condition.  This is a subtype of
\cdf{serious-condition}.
\end{defun}

The default condition type for \cdf{signal} and \cdf{warn} is \cdf{simple-condition}.
The default condition type for \cdf{error} and \cdf{cerror} is
\cdf{simple-error}.

\begin{defun}[Type]
simple-condition

Conditions signaled by \cdf{signal} when given a format string as a first
argument are of this type. This is a subtype of \cdf{condition}.  The
initialization keywords \cd{:format-string} and \cd{:format-arguments} are
supported to initialize the slots, which can be accessed using
\cdf{simple-condition-format-control} and
\cdf{simple-condition-format-arguments}.  If \cd{:format-arguments} is not
supplied to \cdf{make-condition}, the \emph{format-arguments} slot defaults to
\cdf{nil}.
\end{defun}

\begin{defun}[Type]
simple-warning

Conditions signaled by \cdf{warn} when given a format string as a first argument
are of this type. This is a subtype of \cdf{warning}.  The initialization
keywords \cd{:format-string} and \cd{:format-arguments} are supported to
initialize the slots, which can be accessed using
\cdf{simple-condition-format-control} and
\cdf{simple-condition-format-arguments}.  If \cd{:format-arguments} is not
supplied to \cdf{make-condition}, the \emph{format-arguments} slot defaults to
\cdf{nil}.

In implementations supporting multiple inheritance, this type will also be a
subtype of \cdf{simple-condition}.
\end{defun}

\begin{defun}[Type]
simple-error

Conditions signaled by \cdf{error} and \cdf{cerror} when given a format string
as a first argument are of this type. This is a subtype of \cdf{error}.  The
initialization keywords \cd{:format-string} and \cd{:format-arguments} are
supported to initialize the slots, which can be accessed using
\cdf{simple-condition-format-control} and
\cdf{simple-condition-format-arguments}.  If \cd{:format-arguments} is not
supplied to \cdf{make-condition}, the format-arguments slot defaults to
\cdf{nil}.

In implementations supporting multiple inheritance, this type will also be a
subtype of \cdf{simple-condition}.
\end{defun}

\begin{defun}[Function]
simple-condition-format-control condition

Accesses the format-string slot of a given \emph{condition}, which must be of
type \cdf{simple-condition}, \cdf{simple-warning}, \cdf{simple-error}, or
\cdf{simple-type-error}.
\end{defun}

\begin{defun}[Function]
simple-condition-format-arguments condition

Accesses the format-arguments slot of a given \emph{condition}, which must be of
type \cdf{simple-condition}, \cdf{simple-warning}, \cdf{simple-error}, or
\cdf{simple-type-error}.
\end{defun}

\begin{defun}[Type]
storage-condition

Conditions that relate to storage overflow should inherit from this type.  This
is a subtype of \cdf{serious-condition}.
\end{defun}

\begin{defun}[Type]
type-error

Errors in the transfer of data in a program should inherit from this type. This
is a subtype of \cdf{error}. For example, conditions to be signaled by
\cdf{check-type} should inherit from this type. The initialization keywords
\cd{:datum} and \cd{:expected-type} are supported to  initialize the slots,
which can be accessed using \cdf{type-error-datum} and
\cdf{type-error-expected-type}.
\end{defun}

\begin{defun}[Function]
type-error-datum condition

Accesses the datum slot of a given \emph{condition}, which must be of type
\cdf{type-error}.
\end{defun}

\begin{defun}[Function]
type-error-expected-type condition

Accesses the expected-type slot of a given \emph{condition}, which must be of
type \cdf{type-error}. Users of \cdf{type-error} conditions are expected to fill
this slot with an object that is a valid Common Lisp type specifier.
\end{defun}

\begin{defun}[Type]
simple-type-error

Conditions signaled by facilities similar to \cdf{check-type} may want to use
this type. The initialization keywords \cd{:format-string} and
\cd{:format-arguments} are supported to initialize the slots, which can be
accessed using  \cd{simple-condition-format-control} and
\cd{simple-condition-format-arguments}.  If \cd{:format-arguments} is not
supplied to \cdf{make-condition}, the  format-arguments slot defaults to
\cdf{nil}.

In implementations supporting multiple inheritance, this type will also be a
subtype of \cdf{simple-condition}.
\end{defun}

\begin{defun}[Type]
program-error

Errors relating to incorrect program syntax that are statically detectable
should inherit from this type (regardless of whether they are in fact statically
detected). This is a subtype of \cdf{error}. This is \emph{not} a subtype of
\cdf{control-error}.
\end{defun}

\begin{defun}[Type]
control-error

Errors in the dynamic transfer of control in a program should inherit from this
type. This is a subtype of \cdf{error}. This is \emph{not} a subtype of
\cdf{program-error}.

The errors that result from giving \cdf{throw} a tag that is not active or from
giving \cdf{go} or \cdf{return-from} a tag that is no longer dynamically
available are control errors.

On the other hand, the errors that result from naming a \cdf{go} tag or
\cdf{return-from} tag that is not lexically apparent are not control
errors. They are program errors. See \cdf{program-error}.
\end{defun}


\begin{defun}[Type]
package-error

Errors that occur during operations on packages should inherit from this
type. This is a subtype of \cdf{error}. The initialization keyword \cd{:package}
is supported to initialize the slot, which can be accessed using
\cdf{package-error-package}.
\end{defun}

\begin{defun}[Function]
package-error-package condition

Accesses the package (or package name) that was being modified or manipulated in
a \emph{condition} of type \cdf{package-error}.
\end{defun}

\begin{defun}[Type]
stream-error

Errors that occur during input from, output to, or closing a stream should
inherit from this type. This is a subtype of \cdf{error}. The initialization
keyword \cd{:stream} is supported to initialize the slot, which can be accessed
using \cdf{stream-error-stream}.
\end{defun}

\begin{defun}[Function]
stream-error-stream condition

Accesses the offending stream of a \emph{condition} of type \cdf{stream-error}.
\end{defun}

\begin{defun}[Type]
end-of-file

The error that results when a read operation is done on a stream that has no
more tokens or characters should inherit from this type. This is a subtype of
\cdf{stream-error}.
\end{defun}

\begin{defun}[Type]
file-error

Errors that occur during an attempt to open a file, or during some low-level
transaction with a file system, should inherit from this type. This is a subtype
of \cdf{error}. The initialization keyword \cd{:pathname} is supported to
initialize the slot, which can be accessed using \cdf{file-error-pathname}.
\end{defun}

\begin{defun}[Function]
file-error-pathname condition

Accesses the offending pathname of a \emph{condition} of type \cdf{file-error}.
\end{defun}

\begin{defun}[Type]
cell-error

Errors that occur while accessing a location should inherit from this type. This
is a subtype of \cdf{error}.  The initialization keyword \cd{:name} is supported
to initialize the slot, which can be accessed using \cdf{cell-error-name}.
\end{defun}

\begin{defun}[Function]
cell-error-name condition

Accesses the offending cell name of a \emph{condition} of type \cdf{cell-error}.
\end{defun}

\begin{defun}[Type]
unbound-variable

The error that results from trying to access the value of an unbound variable
should inherit from this type. This is a subtype of \cdf{cell-error}.
\end{defun}

\begin{defun}[Type]
undefined-function

The error that results from trying to access the value of an undefined function
should inherit from this type. This is a subtype of \cdf{cell-error}.
\end{defun}

\begin{defun}[Type]
arithmetic-error

Errors that occur while doing arithmetic type operations should inherit from
this type. This is a subtype of \cdf{error}. The initialization keywords
\cd{:operation} and \cd{:operands} are supported to initialize the slots, which
can be accessed using \cdf{arithmetic-error-operation} and
\cdf{arithmetic-error-operands}.
\end{defun}

\begin{defun}[Function]
arithmetic-error-operation condition

Accesses the offending operation of a condition of type \cdf{arithmetic-error}.
\end{defun}

\begin{defun}[Function]
arithmetic-error-operands condition

Accesses a list of the offending operands in a condition of type
\cdf{arithmetic-error}.
\end{defun}

\begin{defun}[Type]
division-by-zero

Errors that occur because of division by zero should inherit from this type.
This is a subtype of \cdf{arithmetic-error}.  
\end{defun}

\begin{defun}[Type]
floating-point-overflow

Errors that occur because of floating-point overflow should inherit from this
type. This is a subtype of \cdf{arithmetic-error}.
\end{defun}

\begin{defun}[Type]
floating-point-underflow

Errors that occur because of floating-point underflow should inherit from this
type. This is a subtype of \cdf{arithmetic-error}.
\end{defun}

\else % RUSSIAN

\chapter{}
\label{CONDITION}

: Kent M. Pitman


\section{}

   ,      <<
>>. ,   ,   \cdf{+}  
,   \cdf{read-char}     
.

,   << >>,    
 . , \cdf{+}   ,   
,  \cdf{read-char}    --- ,   
 .        
  ,      .

, ,  \cdf{f}     
,       
    . ,   ,
         
.          ,
,  \cdf{f}     (    
 ).   /
,    ,  \cdf{f}    
      .  , 
 ,        , 
      . ,   
  \cdf{f},   ,    
,    -  . FIXME

     . , , 
       - (end-of-line).  
,             
  ,     
        . ,  
   ,     
     -.     
            
. ,        ,
   -. ,    ,  
        
    .

        . 
  ,     
     ,  
,  -,  ,  
 ,      ,    
.

  , ,       -
      . , ,
         ,
      .

    , ,   
 ,   \emph{}  ,    
   \emph{},     .
,      ,
      , , ,  
     ,   . 
,     ---  ,   ---
       .

\section{  }

  ,      ,  
  ~\ref{INTRO-ERRORS}.

\emph{} ---      ,  
  .    ,    
  ,      .

\emph{} ---  ,      
   (   ,  
 )   .

,       , 
\emph{}.  \cdf{signal}   , 
     .  ,  
\cdf{error}  \cdf{cerror},    \cdf{signal}.

     

\begin{itemize}
\item          
   ,  ,   <<>>  <<
  >>    .

\item         
  (, )
   ,  ,   << >>
     .   ,  ,    
   ,        
    .

\item     ,    
   ,   << >>,
  <<>>  <<  >>.
   ,    ,   
   , . ,    
     ,  ,  
   .

\item   ,       ,
          , 
   << >>.      
     ,      
   .   ,     ,  ( 
   )  ,      
  () (). ,   \cdf{foo}  
      ,  \cd{(length (list
    (foo)))}      .    ,
   \cd{(print (list (foo)))}  .
\end{itemize}

\section{ }

         ,
   .    
  ,    .

\subsection{ }

,       , 
,        
.    ,   
   <<>>.

       \cdf{error} 
    \cdf{format},   
 .    \cdf{error}  
 (  ~\ref{TRAPPING-ERRORS}
~\ref{HANDLING-CONDITIONS})  ,     
    . :
\begin{lisp}
Lisp> (defun factorial (x) \\*
~~~~~~~~(cond ((or (not (typep x 'integer)) (minusp x)) \\*
~~~~~~~~~~~~~~~(error "{\Xtilde}S is not a valid argument to FACTORIAL." \\*
~~~~~~~~~~~~~~~~~~~~~~x)) \\
~~~~~~~~~~~~~~((zerop x) 1) \\
~~~~~~~~~~~~~~(t (* x (factorial (- x 1)))))) \\*
~\EV\ FACTORIAL \\
Lisp> (factorial 20) \\*
~\EV\ 2432902008176640000 \\
Lisp> (factorial -1) \\*
Error: -1 is not a valid argument to FACTORIAL. \\*
To continue, type :CONTINUE followed by an option number: \\*
~1: Return to Lisp Toplevel. \\*
Debug> 
\end{lisp}
 ,  \cdf{error}        .  
         , 
            .

     ,    
         
 . ,        
 ,  -      
    .  ,    
     :
\begin{lisp}
(defun wargames:no-win-scenario () \\*
~~(when (true) (error "Pushing the button would be stupid.")) \\*
~~(push-the-button))
\end{lisp}
  ,     ,   \cdf{error} 
,    .

\beforenoterule
\begin{sideremark}
It should be noted that the notion of
``no chance'' that the button will be pushed is relative only to the language
model; it assumes that the language is accurately implemented.  In practice,
compilers have bugs, computers have glitches, and users have been known
to interrupt at inopportune moments and use the debugger to return from
arbitrary stack frames.  Such violations of the language model are
beyond the scope of the condition system but not necessarily beyond the
scope of potential failures that the programmer should consider and defend against.
The possibility of such unusual failures may of course also influence the design of
code meant to handle less drastic situations,
such as maintaining a database uncorrupted.---KMP and GLS
\end{sideremark}
\afternoterule

  ,   ,     , 
   .   ,    
\cdf{cerror},     ,  , 
   <<>>     
  . :
\begin{lisp}
Lisp> (defun factorial (x) \\*
~~~~~~~~(cond ((not (typep x 'integer)) \\*
~~~~~~~~~~~~~~~(error "{\Xtilde}S is not a valid argument to FACTORIAL." \\*
~~~~~~~~~~~~~~~~~~~~~~x)) \\
~~~~~~~~~~~~~~((minusp x) \\*
~~~~~~~~~~~~~~~(let ((x-magnitude (- x))) \\*
~~~~~~~~~~~~~~~~~(cerror "Compute -({\Xtilde}D!) instead." \\*
~~~~~~~~~~~~~~~~~~~~~~~~~"(-{\Xtilde}D)! is not defined." x-magnitude) \\*
~~~~~~~~~~~~~~~~~(- (factorial x-magnitude)))) \\
~~~~~~~~~~~~~~((zerop x) 1) \\
~~~~~~~~~~~~~~(t (* x (factorial (- x 1)))))) \\*
~\EV\ FACTORIAL \\
Lisp> (factorial -3) \\*
Error: (-3)! is not defined. \\*
To continue, type :CONTINUE followed by an option number: \\*
~1: Compute -(3!) instead. \\*
~2: Return to Lisp Toplevel. \\*
Debug> :continue 1 \\
~\EV\ -6
\end{lisp}

\subsection{ }
\label{TRAPPING-ERRORS}

 ,  \cdf{error}    .   
    .   (
 )      ---
 \cdf{ignore-errors}.   ,   
\cdf{ignore-errors}      
 .    \cdf{error}, \cdf{ignore-errors} 
  , \cdf{nil}  ,  
.         
. :
\begin{lisp}
Lisp> (setq filename "nosuchfile") \\
~\EV\ "nosuchfile" \\
Lisp> (ignore-errors (open filename :direction :input)) \\
~\EV\ NIL \textrm{and} \#<FILE-ERROR 3437523>
\end{lisp}
    ,   . 
   ~\ref{OBJECT-0RIENTED-BASIS}.

,    \cdf{ignore-errors}  ,   
    .     
, ,        , 
.
  \cdf{ignore-errors}    
 ,       , 
      ,   
.  ,     , ,  
,   .  ,    
,     .

\cdf{ignore-errors}       
, \cdf{handler-case},   
    (   )  
,       . ,
 ,     \cdf{ignore-errors},  
 :
\begin{lisp}
Lisp> (setq filename "nosuchfile") \\
~\EV\ "nosuchfile" \\
Lisp> (handler-case (open filename :direction :input) \\
~~~~~~~~(error (condition) \\
~~~~~~~~~~(values nil condition))) \\
~\EV\ NIL \textrm{and} \#<FILE-ERROR 3437525>
\end{lisp}
,   \cdf{handler-case}     
,   <<error>>.      
 ,     :
\begin{lisp}
Lisp> (makunbound 'filename) \\
~\EV\ FILENAME \\
Lisp> (handler-case (open filename :direction :input) \\
~~~~~~~~(file-error (condition) \\
~~~~~~~~~~(values nil condition))) \\
Error: The variable FILENAME is unbound. \\
To continue, type :CONTINUE followed by an option number: \\
~1: Retry getting the value of FILENAME. \\
~2: Specify a value of FILENAME to use this time. \\
~3: Specify a value of FILENAME to store and use. \\
~4: Return to Lisp Toplevel. \\
Debug> 
\end{lisp}

\subsection{ }
\label{HANDLING-CONDITIONS}

    \cdf{handler-case}   
     . 
     ,   
   .

      ,   , 
\emph{},      
  \cdf{signal}      \cdf{signal} ( 
\cdf{error}).

       \emph{} - 
,       .

  ,    \emph{}   
   ,  \emph{} 
        .  
 ,     .

         
,      , 
\emph{}.       
\cdf{make-condition}    , , \cdf{signal},   
  \cdf{signal}    .

  ,      
(  ),   \cdf{go}    \cdf{tagbody},
\cdf{return}  \cdf{block},  \cdf{throw}  \cdf{catch}.  , 
        
.

          
 \cdf{handler-bind}. ,      
\cdf{arithmetic-error},  :
\begingroup
\makeatletter
\def\@listi{\leftmargin\leftmargini \labelsep\leftmargin
   \parsep 3pt\relax
   \topsep 4pt plus 9pt\relax
   \itemsep\topsep}
\makeatother
\begin{lisp}
(handler-bind ((arithmetic-error \emph{handler}))\emph{body})
\end{lisp}
    , , , .   
  \emph{body}     (  
   ),      
,     -. , 
 ,   ,   ()  
: \cdf{nil}   .
\begin{lisp}
(defmacro without-arithmetic-errors (\&body forms) \\
~~(let ((tag (gensym))) \\
~~~~`(block ,tag \\
~~~~~~ (handler-bind ((arithmetic-error \\
~~~~~~~~~~~~~~~~~~~~~~~~~\#'(lambda (c)~~~~~;\textrm{Argument \cdf{c} is a condition} \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~ (return-from ,tag (values nil c))))) \\
~~~~~~~~~,@body)))) \\
\end{lisp}
\endgroup
     ,  
,        
,         
.    ()   ( , 
 ),    .    
       \cdf{error}  \cdf{cerror}
(  ,   \cdf{assert},     
),          
 .

\subsection{-   }
\label{OBJECT-0RIENTED-BASIS}

,     
   ,     . ,
    :
\begin{lisp}
(error "\emph{some format string}")
\end{lisp}
     -   \cdf{simple-error},  
   .

    ,     
  \cdf{string-equal},      
     ,   - 
 .        
    Lisp'.     
   ( )  ,  
   ( ).    
        ,
     .

 -      
      :
\begin{itemize}
\item       ,  
     .

\item      ,     
  ,    ,   .

\item        ,
      .
\end{itemize}

      ,    
   \cdf{define-condition}.
Common Lisp'     CLOS ,  
   CLOS . \cdf{define-condition} 
  ,      
,  \cdf{defclass}.

  ,      \cdf{divide}, 
   \cdf{/},      
:
\begin{lisp}
(defun divide (numerator denominator) \\
~~(cond ((or (not (numberp numerator)) \\
~~~~~~~~~~~~~(not (numberp denominator))) \\
~~~~~~~~~(error "(DIVIDE '{\Xtilde}S '{\Xtilde}S) - Bad arguments." \\
~~~~~~~~~~~~~~~~numerator denominator)) \\
~~~~~~~~((zerop denominator) \\
~~~~~~~~~(error 'division-by-zero \\
~~~~~~~~~~~~~~~~:operator 'divide \\
~~~~~~~~~~~~~~~~:operands (list numerator denominator))) \\
~~~~~~~~(t ...)))
\end{lisp}
 ,       \cdf{error} 
          ,
\cdf{division-by-zero}.    ,  
  \cdf{simple-error}.

           
  . , \cdf{simple-error}   
\cdf{error},        \cdf{condition}. 
 , \cdf{division-by-zero}   \cdf{arithmetic-error},
   \cdf{error},    \cdf{condition}. 
,     \cdf{arithmetic-error}   
 \cdf{division-by-zero},    
.         \cdf{simple-error}, 
 \cdf{arithmetic-error}   .

\subsection{ ()}
\label{RESTARTS}
Common Lisp'      
       , 
   .    
 \cdf{divide}      
    -  . , 
   ,    
 <<   >>.
\begin{lisp}
Lisp> (+ (divide 3 0) 7) \\
Error: Attempt to divide 3 by 0. \\
To continue, type :CONTINUE followed by an option number: \\
~1: Return to Lisp Toplevel. \\
Debug> :continue 1 \\
Returned to Lisp Toplevel. \\
Lisp>
\end{lisp}
       \cdf{error},   
 ,   \cdf{error}   
 .        ,
,     <<>>.

\subsection{  ()}

        
      \cdf{restart-case}. 
\cdf{restart-case}      ,   
  ,  ,       <<>>,
       \cdf{restart-case}
. ,       \cdf{divide}
,  .
\begin{lisp}
(defun divide (numerator denominator) \\
~~(loop \\
~~~~(restart-case \\
~~~~~~~~(return \\
~~~~~~~~~~(cond ((or (not (numberp numerator)) \\
~~~~~~~~~~~~~~~~~~~~~(not (numberp denominator))) \\
~~~~~~~~~~~~~~~~~(error "(DIVIDE '{\Xtilde}S '{\Xtilde}S) - Bad arguments." \\
~~~~~~~~~~~~~~~~~~~~~~~~~numerator denominator)) \\
~~~~~~~~~~~~~~~~((zerop denominator) \\
~~~~~~~~~~~~~~~~~(error 'division-by-zero \\
~~~~~~~~~~~~~~~~~~~~~~~~:operator 'divide \\
~~~~~~~~~~~~~~~~~~~~~~~~:operands (list numerator denominator))) \\
~~~~~~~~~~~~~~~~(t ...))) \\
~~~~~~(nil (arg1 arg2) \\
~~~~~~~~~~:report "Provide new arguments for use by DIVIDE." \\
~~~~~~~~~~:interactive \\
~~~~~~~~~~~~(lambda () \\
~~~~~~~~~~~~~~~(list (prompt-for 'number "Numerator: ") \\
~~~~~~~~~~~~~~~~~~~~~(prompt-for 'number "Denominator: "))) \\
~~~~~~~~(setq numerator arg1 denominator arg2)) \\
~~~~~~(nil (result) \\
~~~~~~~~~~:report "Provide a value to return from DIVIDE." \\
~~~~~~~~~~:interactive \\
~~~~~~~~~~~~(lambda () (list (prompt-for 'number "Result: "))) \\
~~~~~~~~(return result)))))
\end{lisp}

\beforenoterule
\begin{sideremark}
    The function \cdf{prompt-for} used in this chapter in a number of places is
    not a part of Common Lisp.  It is used in the examples in this chapter only to keep
    the presentation simple.  It is assumed to accept a type specifier
     and optionally a format string and associated arguments.  It uses the
    format string and associated arguments as part of an interactive prompt,
    and uses \cdf{read} to read a Lisp object; however, only an object of the
    type indicated by the type specifier is accepted.

    The question of whether or not \cdf{prompt-for} (or something like it) would be a
    useful addition to Common Lisp is under consideration by X3J13, but as of
    January 1989 no action has been taken. In spite of its use in a number of examples,
    nothing in the Common Lisp Condition System depends on this function.
\end{sideremark}
\afternoterule

 , \cdf{nil},     , ,  
<<>> .      
.   ,    << >>,
     ,   
.

      ,  
     ,   
   .     
   \cd{:interactive}.

  \cd{:report}  ,   
    ( , ).

  ,    
  \cdf{divide}:
\begin{lisp}
Lisp> (+ (divide 3 0) 7) \\
Error: Attempt to divide 3 by 0. \\
To continue, type :CONTINUE followed by an option number: \\
~1: Provide new arguments for use by the DIVIDE function. \\
~2: Provide a value to return from the DIVIDE function. \\
~3: Return to Lisp Toplevel. \\
Debug> :continue 1 \\
1 \\
Numerator: 4 \\
Denominator: 2 \\
~\EV\ 9
\end{lisp}

\subsection{  ()}

    ,     ,
     ,   .   
,   \cd{3}  \cd{1}   \cd{4},  :
\begin{lisp}
(restart-case (invoke-restart 'foo 3) \\
~~(foo (x) (+ x 1)))
\end{lisp}
    :
\begin{lisp}
(+ (catch 'something (throw 'something 3)) 1)
\end{lisp}

   ,   \cdf{symbol-value} 
    :
\begin{lisp}
(restart-case (error "The variable {\Xtilde}S is unbound." variable) \\*
~~(continue () \\*
~~~~~~:report \\*
~~~~~~~~(lambda (s)~~~~~;\textrm{ \cdf{s} --- } \\*
~~~~~~~~~~(format s "Retry getting the value of {\Xtilde}S." variable)) \\*
~~~~(symbol-value variable)) \\
~~(use-value (value) \\*
~~~~~~:report \\*
~~~~~~~~(lambda (s)~~~~~;\textrm{ \cdf{s} --- } \\*
~~~~~~~~~~(format s "Specify a value of {\Xtilde}S to use this time." \\*
~~~~~~~~~~~~~~~~~~variable)) \\*
~~~~value) \\
~~(store-value (value) \\*
~~~~~~:report \\*
~~~~~~~~(lambda (s)~~~~~;\textrm{ \cdf{s} --- } \\*
~~~~~~~~~~(format s "Specify a value of {\Xtilde}S to store and use." \\*
~~~~~~~~~~~~~~~~~~variable)) \\*
~~~~(setf (symbol-value variable) value) \\*
~~~~value))
\end{lisp}
     \cdf{symbol-value},   
      
. ,       , 
:
\begin{lisp}
(handler-bind ((unbound-variable \\
~~~~~~~~~~~~~~~~~\#'(lambda (c)~~~~~;\textrm{ \cdf{c} --- } \\
~~~~~~~~~~~~~~~~~~~~~(when (find-restart 'use-value) \\
~~~~~~~~~~~~~~~~~~~~~~~(invoke-restart 'use-value \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(cell-error-name c)))))) \\
~~\emph{body})
\end{lisp}

\subsection{  ()}

   ,    ,
    \cdf{invoke-restart}.  
    \emph{restart functions}.

     ,   .  
\cdf{abort}, \cdf{continue}, \cdf{muffle-warning}, \cdf{store-value} 
\cdf{use-value}   .    
   \cdf{use-value}:
\begin{lisp}
(handler-bind ((unbound-variable \\
~~~~~~~~~~~~~~~~~~~\#'(lambda (c)~~~~~;\textrm{Argument \cdf{c} is a condition} \\
~~~~~~~~~~~~~~~~~~~~~~~(use-value (cell-error-name c))))) \\
~~\emph{body})
\end{lisp}

\subsection{   catch/throw}

    ,   \cdf{restart-case} (
\cdf{restart-bind}),    \cdf{catch},    
        . 
  :
\begin{lisp}
(ignore-errors (throw ...))
\end{lisp}
    
\begin{lisp}
(when (find-restart 'something) \\*
~~(invoke-restart 'something))
\end{lisp}
   \cdf{ignore-errors}  \cdf{throw}  
 :
\begin{lisp}
(when (and (find-restart 'something) \\*
~~~~~~~~~~~(find-restart 'something-else)) \\*
~~(invoke-restart 'something))
\end{lisp}
  :
\begin{lisp}
(when (and (find-restart 'something) \\
~~~~~~~~~~~(yes-or-no-p "Do something? ")) \\
~~(invoke-restart 'something))
\end{lisp}
       
\begin{lisp}
(ignore-errors (throw ...))
\end{lisp}
  ---     , 
   .

     ,  :
\begin{lisp}
(defvar *foo-tag-is-available* nil) \\
\\
(defun fn-1 () \\
~~(catch 'foo \\
~~~~(let ((*foo-tag-is-available* t)) \\
~~~~~~... (fn-2) ...))) \\
\\
(defun fn-2 () \\
~~... \\
~~(if *foo-tag-is-available* (throw 'foo t)) \\
~~...)
\end{lisp}
  \cdf{restart-case}  \cdf{find-restart} 
      ,  
      .   
      .

      \cdf{catch}/\cdf{throw}
  ,  \cdf{catch}      
  \cdf{catch}   . - 
\cdf{compute-restarts},      ,
       (   
).

\subsection{ }
\label{LAST-RESTARTS-SECTION}

\cdf{restart-case}  ,    
    . \cdf{restart-case}  
    \cdf{restart-bind},    
 .

\cdf{restart-bind}  \cdf{restart-case},  \cdf{handler-bind} 
\cdf{handler-case}.
  :
\begin{lisp}
(restart-bind ((\emph{name} \emph{function} . \emph{options})) . \emph{body})
\end{lisp}
 \emph{body}    ,   
  \emph{function},      
\cd{(invoke-restart '\emph{name})}.
 \emph{options}      
   , , ,  
  \cd{:report}  \cdf{restart-case}.

\cdf{restart-case}    \cdf{restart-bind},   
      ,    
  <<>> .

   ,    . 
         
,       . ,
  ,        
       \cdf{dir}:
\begin{lisp}
(restart-bind ((nil \#'(lambda () (expunge-directory dir)) \\
~~~~~~~~~~~~~~~~~~~~:report-function \\
~~~~~~~~~~~~~~~~~~~~~~\#'(lambda (stream) \\
~~~~~~~~~~~~~~~~~~~~~~~~~~(format stream "Expunge {\Xtilde}A." \\
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(directory-namestring dir))))) \\
~~(cerror "Try this file operation again." \\
~~~~~~~~~~'directory-full :directory dir))
\end{lisp}
  ,        
(        -)    :
\begin{lisp}
Lisp> (open "FOO" :direction :output) \\
Error: The directory PS:<JDOE> is full. \\
To continue, type :CONTINUE followed by an option number: \\
~1: Try this file operation again. \\
~2: Expunge PS:<JDOE>. \\
~3: Return to Lisp Toplevel. \\
Debug> :continue 2 \\
Expunging PS:<JDOE> ... 3 records freed. \\
Debug> :continue 1 \\
~\EV\ \#<OUTPUT-STREAM "PS:<JDOE>FOO.LSP" 2323473>
\end{lisp}

\subsection{  }

      ,    ,
       ,    <<
 >> ,  , <<>>.   
   ,  \cdf{error}  \cdf{cerror},   
  \cdf{invoke-debugger}.

       . 
      
     ,   
  ,    . , 
       
    ~\ref{RESTARTS} ~\ref{LAST-RESTARTS-SECTION}.

,       
,       .   
,      ,    
,      Common Lisp'
.       
.

\subsection{ }

 \cdf{ignore-errors}     \cdf{error}. 
    .

    ,     . 
  \emph{ },     
 \cdf{serious-condition}. , , ,  
 << >>  << >>,   
.

 \cdf{error}   \cdf{serious-condition},    
   << >>     
,     . ,     <<
>>      \cdf{serious-condition},   
\cdf{error}.

          , 
    ,     Common
Lisp'. ,  ,       
,   ,        . 
        ,    ,
     ,   \cd{(ignore-errors (+~a~b))},
    ,   , , -
 . , \cdf{ignore-errors}    
\cdf{error},    \cdf{serious-condition}.    
     ( 
\cdf{handler-bind}  \cdf{handler-case}).

 ,     \cdf{serious-condition}
( \cdf{error})  \cdf{error}   \cdf{signal}.  It
is the use of the function \cdf{error}, and not the type of the condition being
signaled, that actually causes the debugger to be entered.


\subsection{ }

     ,  .   
,      ,   
  ,     .

,      (  
) ,  \cdf{end-of-line},   
   .   ,   
   ,     .

 ,      \cdf{signal}. 
     \cdf{signal},   
  ,    . ,  ,
    ,     
    \cdf{error} (    
  ) ,      
. FIXME

\subsection{ }

      .    
 \cdf{condition}.  , \cd{(typep~\emph{x} 'condition)} 
    ,   \emph{x}  .

    . FIXME

\subsection{ }

       
   .

     \cdf{handler-bind} 
  \cdf{handler-bind}.

    ,   .  
,   \emph{ }   ,  
  .   ,   
    .

    ,    ,   
 , \cdf{signal}  \cdf{nil}.


  ,     ,    , 
 ,  ,   ,  
()  ,  ,   ()
 .      ,  
        .  
         ,
,     \cdf{ignore-errors}.   
     ,   \cdf{error}.

\subsection{ }

         
 ,         
.        
,   ,   -
    .

,       
\cdf{storage-condition}, ,       
    .

\subsection{ }
\label{CONDITION-HANDLERS}

\emph{}    ,  ,  
.      ,  
  <<>> .

     ,   ,
       
.      -  
.

  ,       :
\begin{itemize}
\item  \emph{}   (  ). 
   ,   ,   
    ,       . 
   ,      ,  
  .
\item  \emph{}  ( -  
  ).        \cdf{go},
  \cdf{return}  \cdf{throw},     ,  \cdf{abort}
   \cdf{invoke-restart}.
\item    .
\item    .
\end{itemize}
    (    
)     - .   ,
        .

\subsection{ }

 \cdf{*print-escape*}  \cdf{nil} (,  
 \cdf{princ}   \cd{{\Xtilde}A}  \cdf{format}), , 
    .       ,
  \cdf{invoke-debugger}, \cdf{break}  \cdf{warn},   
      . ,
\begin{lisp}
(let ((form '(open "nosuchfile"))) \\
~~(handler-case (eval form) \\
~~~~(serious-condition (c) \\
~~~~~~(format t "{\Xtilde}\& {\Xtilde}S :{\Xtilde}\%{\Xtilde}A" form c))))
\end{lisp}
  - 
\begin{lisp}
 (OPEN "nosuchfile") : \\
 "nosuchfile"   .
\end{lisp}

    ,    :
\begin{itemize}
\item   ,    ,    
      ( ).

 \item  \emph{  }  ,  
   <<\cd{:}>>  <<\cd{}>>     
    .        
   .

 \item  ,   ,    
       .     
              
   ,          ,
        .

  \item    ,   
          .

  \item    (, )   
         (,    ,
    -  <<\cd{:}>>),      
           
    .  ,        
    ,           
       . ( \cdf{error}  
          ..,    
     ,     .)
\end{itemize}

 \cdf{*print-escape*}   \cdf{nil},     
       .   
      \cdf{read}. - 
\cd{\#<ARITHMETIC-ERROR~1734>} .

 \cd{(:report \emph{fn})}  \cdf{define-condition}  
  \emph{C} 
  :
\begin{lisp}
(defmethod print-object ((x \emph{C}) stream) \\*
~~(if *print-escape* \\*
~~~~~~(call-next-method) \\*
~~~~~~(funcall \#'\emph{fn} x stream)))
\end{lisp}
 ,    \emph{fn}    
,  \cdf{*print-escape*}   \cdf{nil}.

\section{   }

   , ,      
 Common Lisp'.

\subsection{ }
\label{SIGNALLING-CONDITIONS}

        
, ,    .

\begin{defun}[]
error datum &rest arguments

  .     , 
\cd{(invoke-debugger \emph{condition})}.     \cdf{error}
      .    
        
   .

 \emph{datum}  ,     .
      \emph{arguments}  , 
 \cdf{error}        --- .

 \emph{datum}    (   ),
     \cd{(apply \#'make-condition
  \emph{datum} \emph{arguments})}.

 \emph{datum}  ,      
\begin{lisp}
(make-condition 'simple-error \\*
~~~~~~~~~~~~~~~~:format-string \emph{datum} \\*
~~~~~~~~~~~~~~~~:format-arguments \emph{arguments})
\end{lisp}
\end{defun}

\begin{defun}[]
cerror continue-format-string datum &rest arguments

 \cdf{cerror}  .     ,
 \cd{(invoke-debugger \emph{condition})}.    
 , ,   (   )
     (  
  \cdf{cerror}    \cdf{continue}.

  \emph{datum}  ,    . 
  ,   \emph{arguments}    , 
    \emph{continue-format-string}.

 \emph{datum}    (   ), 
      \cd{(apply \#'make-condition
  \emph{datum} \emph{arguments})}.

 \emph{datum}  ,      :
\begin{lisp}
(make-condition 'simple-error \\*
~~~~~~~~~~~~~~~~:format-string \emph{datum} \\*
~~~~~~~~~~~~~~~~:format-arguments \emph{arguments})
\end{lisp}

 \emph{continue-format-string}   .  ,
  \emph{datum}   ,   
    \emph{continue-format-string}  
( \emph{datum}   ,     
:  , ).      
  \emph{continue-format-string}    
 \cd{{\Xtilde}*},     .

 \cdf{cerror}   \cdf{nil}.
\end{defun}

\begin{defun}[]
signal datum &rest arguments

   .     ,
\cdf{signal}  \cdf{nil}.

 \emph{datum}  ,     .
    \emph{arguments}   ,   \cdf{signal}
      , .

 \emph{datum}    (   ), 
     \cd{(apply \#'make-condition \emph{datum}
  \emph{arguments})}.

 \emph{datum}  ,     :
\begin{lisp}
  (make-condition 'simple-error \\*
  ~~~~~~~~~~~~~~~~:format-string \emph{datum} \\*
  ~~~~~~~~~~~~~~~~:format-arguments \emph{arguments})
\end{lisp}

 ,   \cd{(typep \emph{condition} *break-on-signals*)}
 ,       
.      
   \cdf{continue}.   
 ,     \cdf{with-condition-restarts}.
        ,  
: \cdf{warn}, \cdf{error}, \cdf{cerror}, \cdf{assert} 
\cdf{check-type}.

     \cdf{signal}   ,
  \cdf{signal}        .
,    ,   \emph{}  
    ,     
     (\cdf{eq})   
 .

    ~\ref{CONDITION-HANDLERS}.
\end{defun}


\begin{defun}[]
*break-on-signals*

  ,    , 
 .  \cd{*break-on-signals*}   
     \cdf{typep},      .

  \cd{(typep \emph{condition} *break-on-signals*)} , 
  \cdf{signal} (  -  )  
    \emph{}.  
      
\cdf{continue}.     ,    
\cdf{with-condition-restarts}.

 ,  \cdf{nil}    . 
 \cdf{*break-on-signals*}  \cdf{nil},  \cdf{signal}  
     .

   ,     
  .      
,        , 
         \cdf{signal}.

----, ,   <<>> ---
    \cdf{nil},    ,
    . 
\end{defun}


\subsection{ }
\label{CONDITION-ASSERTIONS}

        .

\begin{defmac}
check-type place typespec [string]

 \cdf{check-type}    \cdf{type-error}, 
 \emph{place}    .

   ,    
  \cdf{type-error-datum}  \cdf{type-error-expected-type}
    \emph{place}  \emph{typespec}, .

   ,     
\cdf{store-value}    ,      
.     ,     
 \cdf{with-condition-restarts}.

  \cdf{store-value}, \cdf{check-type}    
 \cdf{store-value} (     )  
\emph{place}         
,       .  \emph{place} 
  ,     
. \cdf{check-type}  \cdf{nil}.

\emph{place}    ,    
\cdf{setf}. \emph{typespec}    ,   
.  \cdf{string}      ,
   (<<a>>  <<an>>),   .  
 \emph{string}   ,      
 \emph{typespec}.  \emph{string}   
,      .

      \emph{place},     .

\beforenoterule
\begin{implementation}
  An implementation may choose to generate a somewhat differently worded error
  message if it recognizes that \emph{place} is of a particular form, such as
  one of the arguments to the function that called \cdf{check-type}.
\end{implementation}
\afternoterule

\begin{lisp}
Lisp> (setq aardvarks '(sam harry fred)) \\*
~\EV\ (SAM HARRY FRED) \\
Lisp> (check-type aardvarks (array * (3))) \\*
Error: The value of AARDVARKS, (SAM HARRY FRED), \\*
~~~~~~~is not a 3-long array. \\
To continue, type :CONTINUE followed by an option number: \\*
~1: Specify a value to use instead. \\*
~2: Return to Lisp Toplevel. \\
Debug> :continue 1 \\*
Use Value: \#(sam fred harry) \\*
~\EV\ NIL \\
Lisp> aardvarks \\*
~\EV\ \#<ARRAY-3 13571> \\
Lisp> (map 'list \#'identity aardvarks) \\*
~\EV\ (SAM FRED HARRY) \\
Lisp> (setq aacount 'foo) \\*
~\EV\ FOO \\
Lisp> (check-type aacount (integer 0 *) "a non-negative integer") \\*
Error: The value of AACOUNT, FOO, is not a non-negative integer. \\*
To continue, type :CONTINUE followed by an option number: \\*
~1: Specify a value to use instead. \\*
~2: Return to Lisp Toplevel. \\
Debug> :continue 2 \\*
Lisp> 
\end{lisp}
\end{defmac}

\begin{defmac}
assert test-form [({place}*) [datum {argument}*]]

 \cdf{assert}  ,    \emph{test-form}
 \cdf{nil}.       \cdf{continue}
     ,  \cdf{assert}
   \emph{test-form}.    
,       \cdf{with-condition-restarts}.
\cdf{assert}  \cdf{nil}.

 \emph{test-form}   .  \emph{place} (  
,    )    ,  
  \cdf{setf}.      
\emph{test-form},        
 .    \emph{place} , 
  .   ,   
  ( ,     
).

 \emph{datum}  \emph{argument} ,  
 ,  ,    .

  \emph{datum}  ,     . 
     \emph{argument}  .

 \emph{datum}    (   ), 
     \cd{(apply \#'make-condition \emph{datum}
  (list \Mstar{argument}))}.

 \emph{datum}  ,    :
\begin{lisp}
(make-condition 'simple-error \\*
~~~~~~~~~~~~~~~~:format-string \emph{datum} \\*
~~~~~~~~~~~~~~~~:format-arguments (list \Mstar{argument}))
\end{lisp}

 \emph{datum}  ,     \cdf{simple-error} 
 \emph{test-form}   . :
\begin{lisp}
(make-condition 'simple-error \\
~~:format-string "The assertion {\Xtilde}S failed." \\
~~:format-arguments '(\emph{test-form}))
\end{lisp}
 ,  \emph{test-form}      
,    .

\beforenoterule
\begin{implementation}
  The debugger need not include the \emph{test-form} in the error message, and
  any \emph{places} should not be included in the message, but they should be
  made available for the user's perusal. If the user gives the ``continue''
  command, an opportunity should be presented to alter the values of any or all
  of the references. The details of this depend on the implementation's style of
  user interface, of course.
\end{implementation}
\afternoterule

   \cdf{assert}:
\begin{lisp}
(setq x (make-array '(3 5) :initial-element 3)) \\
(setq y (make-array '(3 5) :initial-element 7)) \\
 \\
(defun matrix-multiply (a b) \\*
~~(let ((*print-array* nil)) \\*
~~~~(assert (and (= (array-rank a) (array-rank b) 2) \\*
~~~~~~~~~~~~~~~~~(= (array-dimension a 1) \\*
~~~~~~~~~~~~~~~~~~~~(array-dimension b 0))) \\*
~~~~~~~~~~~~(a b) \\*
~~~~~~~~~~~~"Cannot multiply {\Xtilde}S by {\Xtilde}S." a b) \\*
~~~~(really-matrix-multiply a b))) \\
 \\
(matrix-multiply x y) \\
Error: Cannot multiply \#<ARRAY-3-5 12345> by \#<ARRAY-3-5 12364>. \\*
To continue, type :CONTINUE followed by an option number: \\*
~1: Specify new values. \\*
~2: Return to Lisp Toplevel. \\
Debug> :continue 1 \\*
Value for A: x \\*
Value for B: (make-array '(5 3) :initial-element 6) \\
~\EV \#2A(\=(54 54 54 54 54) \\
\>(54 54 54 54 54) \\*
\>(54 54 54 54 54) \\*
\>(54 54 54 54 54) \\*
\>(54 54 54 54 54))
\end{lisp}
\end{defmac}

\subsection{   }
\label{EXHAUSTIVE-CASE-ANALYSIS-CONDITIONS}

  \cdf{etypecase}  \cdf{ctypecase}     
\cdf{typecase},     \cdf{otherwise}. ,
  \cdf{ecase}  \cdf{ccase}      \cdf{ccase}, 
  \cdf{otherwise}.

\cdf{etypecase}  \cdf{ecase}   \cdf{typecase}  \cdf{case},
, ,    , 
   ,   \cdf{nil}.

\cdf{ctypecase}  \cdf{ccase}    \cdf{typecase}  \cdf{case},
,     , 
   ,   \cdf{nil}.

\begin{defmac}
etypecase keyform {(type {form}*)}*

     \cdf{typecase},   
\cdf{otherwise}  \cdf{t} .       
, \cdf{ecase}   ( \cdf{type-error})  ,
      .   
.   ,   
\cdf{typecase}   \cdf{otherwise},   \cdf{error}. 
    <<exhaustive type case>>  <<error-checking type
case>>.

:
\begin{lisp}
Lisp> (setq x 1/3) \\*
~\EV\ 1/3 \\
Lisp> (etypecase x \\*
~~~~~~~~(integer (* x 4)) \\*
~~~~~~~~(symbol~(symbol-value x))) \\
Error: The value of X, 1/3, is neither an integer nor a symbol. \\*
To continue, type :CONTINUE followed by an option number: \\*
~1: Return to Lisp Toplevel. \\*
Debug>
\end{lisp}
\end{defmac}

\begin{defmac}
ctypecase keyplace {(type {form}*)}*

     \cdf{typecase},   
\cdf{otherwise}  \cdf{t} .

 \emph{keyplace}    ,  
  \cdf{setf}.       
\emph{keyplace}, \cdf{ctypecase}   ( \cdf{type-error}) 
,     .   
     \cdf{store-value}. 
 \cdf{store-value}   \emph{keyplace}   \cdf{ctypecase}
   .    \emph{keyplace}  
  .   \cdf{store-value}  
,      .

    <<continuable (exhaustive) type
case>>.

:
\begin{lisp}
Lisp> (setq x 1/3) \\*
~\EV\ 1/3 \\
Lisp> (ctypecase x \\*
~~~~~~~~(integer (* x 4)) \\*
~~~~~~~~(symbol (symbol-value x))) \\
Error: The value of X, 1/3, is neither an integer nor a symbol. \\*
To continue, type :CONTINUE followed by an option number: \\
~1: Specify a value to use instead. \\*
~2: Return to Lisp Toplevel. \\
Debug> :continue 1 \\*
Use value: 3.7 \\
Error: The value of X, 3.7, is neither an integer nor a symbol. \\*
To continue, type :CONTINUE followed by an option number: \\*
~1: Specify a value to use instead. \\*
~2: Return to Lisp Toplevel. \\
Debug> :continue 1 \\*
Use value: 12 \\*
~\EV\ 48
\end{lisp}
\end{defmac}


\begin{defmac}
ecase keyform {({({key}*) | key} {form}*)}*

     \cdf{case},   
\cdf{otherwise}  \cdf{t} .       
, \cdf{ecase}   ( \cdf{type-error})  ,
      .   
.   ,    \cdf{case}
  \cdf{otherwise},   \cdf{error}.   
  <<exhaustive case>>  <<error-checking case>>.

:
\begin{lisp}
Lisp> (setq x 1/3) \\*
~\EV\ 1/3 \\
Lisp> (ecase x \\*
~~~~~~~~(alpha (foo)) \\*
~~~~~~~~(omega (bar)) \\*
~~~~~~~~((zeta phi) (baz))) \\
Error: The value of X, 1/3, is not ALPHA, OMEGA, ZETA, or PHI. \\*
To continue, type :CONTINUE followed by an option number: \\*
~1: Return to Lisp Toplevel. \\*
Debug>
\end{lisp}
\end{defmac}

\begin{defmac}
ccase keyplace {({({key}*) | key} {form}*)}*

     \cdf{case},   
\cdf{otherwise}  \cdf{t} .

 \emph{keyplace}    ,  
  \cdf{setf}.       
\emph{keyplace}, \cdf{ccase}   ( \cdf{type-error}) 
,     .   
     \cdf{store-value}. 
 \cdf{store-value}   \emph{keyplace}   \cdf{ctypecase}
   .    \emph{keyplace}  
  .   \cdf{store-value}  
,      .

    <<continuable (exhaustive) case>>.

\beforenoterule
\begin{implementation}
  The \cdf{type-error} signaled by \cdf{ccase} and \cdf{ecase} is free to
  choose any representation of the acceptable argument type that it wishes
  for placement in the expected-type slot. It will always work to use type
  \cd{(member . \emph{keys})}, but in some cases it may be more efficient, for example,
  to use a type that represents an integer subrange or a type composed using the
  \cdf{or} type specifier.
\end{implementation}
\afternoterule
\end{defmac}

\subsection{ }

       
 .

\begin{defmac}
handler-case expression {(typespec ([var]) {form}*)}*

    \emph{expression}   
 .

 \emph{typespec}     .   
 \emph{expression}   ,   
 --- ,    \cd{(typep
  \emph{condition} '\emph{typespec})} ---     
     ,     
  (  
 )    \emph{var}  
  .     , 
\cdf{handler-case}  ()  \emph{expression}.

    ,    
.    
\begin{lisp}
(handler-case \emph{expression} \\*
~~(\emph{type\SU{1}} (\emph{var\SU{1}}) \emph{form\SU{1}}) \\*
~~(\emph{type\SU{2}} (\emph{var\SU{2}}) \emph{form\SU{2}}))
\end{lisp}
     ( \emph{form\SU{1}},  
     .

    .   
     (   ), 
    (   ).

   \emph{var}  ,    .  ,
  
\begin{lisp}
(\emph{type} (\emph{var}) (declare (ignore \emph{var})) \emph{form})
\end{lisp}
   
\begin{lisp}
(\emph{type} () \emph{form})
\end{lisp}

       ,
\cdf{handler-case}  \cdf{nil}.  ,  
\begin{lisp}
(handler-case \emph{expression} \\*
~~(\emph{type\SU{1}} (\emph{var\SU{1}}) . \emph{body\SU{1}}) \\*
~~(\emph{type\SU{2}} (\emph{var\SU{2}}) . \emph{body\SU{2}}) \\*
~~...)
\end{lisp}
 
\begin{lisp}
(block \#1=\#:block-1 \\*
~~(let (\#2=\#:var-2) \\*
~~~~(tagbody \\*
~~~~~~(handler-bind ((\emph{type\SU{1}} \=\#'(lambda (temp) \\*
\>~~~~(setq \#2\# temp) \\*
\>~~~~(go \#3=\#:tag-3))) \\
~~~~~~~~~~~~~~~~~~~~~(\emph{type\SU{2}} \=\#'(lambda (temp) \\*
\>~~~~(setq \#2\# temp) \\*
\>~~~~(go \#4=\#:tag-4))) \\*
~~~~~~~~~~~~~~~~~~~~~...) \\*
~~~~~~~~(return-from \#1\# \emph{expression})) \\
~~~~~~\#3\# (return-from \#1\# (let ((\emph{var\SU{1}} \#2\#)) . \emph{body\SU{1}})) \\*
~~~~~~\#4\# (return-from \#1\# (let ((\emph{var\SU{2}} \#2\#)) . \emph{body\SU{2}})) \\*
~~~~~~...)))
\end{lisp}
[Note the use of ``gensyms'' such as \cd{\#:block-1}
as block names, variables, and \cdf{tagbody} tags in this example,
and the use of \cd{\#\emph{n}=} and \cd{\#\emph{n}\#} read-macro syntax
to indicate that the very same gensym appears in multiple places.---GLS]

       \emph{typespec}   
\cd{:no-error}. ,    , 
 \emph{expression}  .   ,  
\cd{:no-error}    -,   -
     \emph{expression},     
\cdf{multiple-value-call}. ,
\begin{lisp}
(handler-case \emph{expression} \\*
~~(\emph{type\SU{1}} (\emph{var\SU{1}}) . \emph{body\SU{1}}) \\*
~~(\emph{type\SU{2}} (\emph{var\SU{2}}) . \emph{body\SU{2}}) \\*
~~... \\*
~~(\emph{type\SU{n}} (\emph{var\SU{n}}) . \emph{body\SU{n}}) \\*
~~(:no-error (\emph{nvar\SU{1}} \emph{nvar\SU{2}} ... \emph{nvar\SU{m}}) . \emph{nbody}))
\end{lisp}
 
\begin{lisp}
(block \#1=\#:error-return \\*
~~(multiple-value-call \#'(lambda (\emph{nvar\SU{1}} \emph{nvar\SU{2}} ... \emph{nvar\SU{m}}) . \emph{nbody}) \\*
~~~~(block \#2=\#:normal-return \\*
~~~~~~(return-from \#1\# \\*
~~~~~~~~(handler-case (return-from \#2\# \emph{expression}) \\*
~~~~~~~~~~(\emph{type\SU{1}} (\emph{var\SU{1}}) . \emph{body\SU{1}}) \\*
~~~~~~~~~~(\emph{type\SU{2}} (\emph{var\SU{2}}) . \emph{body\SU{2}}) \\*
~~~~~~~~~~... \\*
~~~~~~~~~~(\emph{type\SU{n}} (\emph{var\SU{n}}) . \emph{body\SU{n}}))))))
\end{lisp}

  \cdf{handler-case}:
\begin{lisp}
(handler-case (/ x y) \\*
~~(division-by-zero () nil)) \\
 \\
(handler-case (open *the-file* :direction :input) \\*
~~(file-error (condition) (format t "{\Xtilde}\&Fooey: {\Xtilde}A{\Xtilde}\%" condition))) \\
 \\
(handler-case (some-user-function) \\*
~~(file-error (condition) condition) \\*
~~(division-by-zero () 0) \\*
~~((or unbound-variable undefined-function) () 'unbound)) \\
 \\
(handler-case (intern x y) \\*
~~(error (condition) condition) \\*
~~(:no-error (symbol status) \\*
~~~~(declare (ignore symbol)) \\*
~~~~status))
\end{lisp}
\end{defmac}

\begin{defmac}
ignore-errors {form}*

  \emph{forms}      \cdf{error} ,
      .    
,     ()  . 
  : \cdf{nil}  \cdf{error} ,  
.

\cdf{ignore-error}     :
\begin{lisp}
(defmacro ignore-errors (\&body forms) \\*
~~{\Xbq}(handler-case (progn ,{\Xatsign}forms) \\*
~~~~~(error (c) (values nil c))))
\end{lisp}
\end{defmac}

\begin{defmac}
handler-bind ({(typespec handler)}*) {form}*

    ,    
.  \emph{typespec}     . 
 \emph{handler}   ,   
    ,      
 \emph{form}.       ---
 .

    ,    
   (    \cdf{typecase}). 
   \emph{typespec} ,  
   ,     , 
  .   :
\begin{lisp}
(handler-bind ((unbound-variable \#'(lambda ...)) \\*
~~~~~~~~~~~~~~~(error \#'(lambda ...))) \\*
~~...)
\end{lisp}
     << >> (    
  ),   .  
-   ,   .     
       .
\end{defmac}

\subsection{  }

[The contents of this section are still a subject of some debate within X3J13.
The reader may wish to take this section with a grain of salt, two aspirin
tablets, and call a hacker in the morning.---GLS]

\begin{defmac}
define-condition name ({parent-type}*)
                 [({slot-specifier}*) {option}*]

      \emph{name}   
\emph{parent-type}.    ,    .

         \emph{slot}, 
  ,    .  
  ,     .

 \emph{slot}   
\begin{tabbing}
\emph{slot-specifier\/} ::= \emph{slot-name\/} {\Mor} (\emph{slot-name\/}  $\lbrack\!\lbrack\downarrow\!\emph{slot-option}\,\rbrack\!\rbrack$)
\end{tabbing}
   \emph{slot-option},  \cdf{defclass}.
     CLOS .
 ,        
\cdf{with-slots}.

\cdf{make-condition}     (  
)     ,  
   .

    ()      
,    \cdf{defclass}.

  \emph{options}  :

\begin{flushdesc}

\item[\cd{(:documentation \emph{doc-string})}]

  \emph{doc-string}    \cdf{nil}  ,  
     .     ,  
   \cdf{nil}.       
  \cd{(documentation '\emph{name} 'type)}

\item[\cd{(:report \emph{exp})}]

   \emph{exp}    ,    
      \cdf{function}.   
      \cd{(function~\emph{exp})}.  
      :   ,  
       .    
  ,   ,  \cdf{*print-escape*}  \cdf{nil}.

   \emph{exp}   ,  
  \begin{lisp}
    (lambda (c s) \\*
    ~~(declare (ignore c)) \\*
    ~~(write-string \emph{exp} s))
  \end{lisp}
  [That is, a function is provided that will simply write the given
  string literally to the stream, regardless of the particular condition object
  supplied.---GLS]
  
   \cd{:report}  \emph{} ,    
   ,  ,      
  .     ,   ,   
        .
  
\end{flushdesc}

    \cdf{define-condition}.

     \cd{peg/hole-mismatch},  
 \cdf{blocks-world-error}:
\begin{lisp}
(define-condition peg/hole-mismatch (blocks-world-error) \\*
~~~~~~~~~~~~~~~~~~(peg-shape hole-shape) \\*
~~(:report \\
~~~~(lambda (condition stream) \\*
~~~~~~(with-slots (peg-shape hole-shape) condition \\*
~~~~~~~~(format stream "A {\Xtilde}A peg cannot go in a {\Xtilde}A hole." \\*
~~~~~~~~~~~~~~~~peg-shape hole-shape))))
\end{lisp}
    \cdf{peg-shape}  \cdf{hole-shape}, 
\cdf{make-condition}     \cd{:peg-shape} 
\cd{:hole-shape}.    \cd{:report},    
\cdf{peg-shape} \cdf{hole-shape}    \cdf{with-slots}.

  .     \cdf{machine-error} 
 \cdf{error}:
\begin{lisp}
(define-condition machine-error (error) \\*
~~~~~~~~~~~~~~~~~~((machine-name \\*
~~~~~~~~~~~~~~~~~~~~:reader machine-error-machine-name)) \\
~~(:report (lambda (condition stream) \\*
~~~~~~~~~~~~~(format stream "There is a problem with {\Xtilde}A." \\*
~~~~~~~~~~~~~~~~~~~~~(machine-error-machine-name condition)))))
\end{lisp}
   ,      ,  
  \cdf{machine-error}      :
\begin{lisp}
(define-condition machine-not-available-error (machine-error) () \\*
~~(:report (lambda (condition stream) \\*
~~~~~~~~~~~~~(format stream "The machine {\Xtilde}A is not available." \\*
~~~~~~~~~~~~~~~~~~~~~(machine-error-machine-name condition)))))
\end{lisp}
       ,   
 \cd{machine-name}  -.
\begin{lisp}
(define-condition my-favorite-machine-not-available-error \\*
~~~~~~~~~~~~~~~~~~(machine-not-available-error) \\*
~~~~~~~~~~~~~~~~~~((machine-name :initform "MC.LCS.MIT.EDU")))
\end{lisp}
 ,   \cd{:report}   ,   
     \cdf{machine-not-available-error}.
\end{defmac}

\subsection{ }

      \cdf{make-condition}.

\begin{defun}[]
make-condition type &rest slot-initializations

     \emph{type}    
  \emph{slot-initializations}.    .

 \emph{slot-initializations}    :  ,
. :
\begin{lisp}
(make-condition 'peg/hole-mismatch \\*
~~~~~~~~~~~~~~~~:peg-shape 'square :hole-shape 'round)
\end{lisp}
\end{defun}

\subsection{ }

 ,    , 
\cdf{restart-bind}.   \cdf{restart-case}  , 
   \cdf{restart-bind},    
.   \cdf{with-simple-restart}.  , 
    ,     ,
 \cdf{invoke-restart}.

     .  
   ,   .

\begin{defmac}
with-simple-restart (name format-string {format-argument}*)
                    {form}*

       
\cdf{restart-case}.

    \emph{name}     \emph{form} 
,  \emph{with-simple-restart}   , 
   \emph{form}.   , 
   \cdf{with-simple-restart},   
  \cdf{nil}  \cdf{t}.

 \emph{name}   \cdf{nil}.    
 .

\cdf{with-simple-restart}    
\begin{lisp}
(defmacro with-simple-restart ((restart-name format-string \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\&rest format-arguments) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\&body forms) \\
~~{\Xbq}(restart-case (progn ,{\Xatsign}forms) \\*
~~~~~(,restart-name () \\*
~~~~~~~:report \\*
~~~~~~~~~(lambda (stream) \\*
~~~~~~~~~~~(format stream format-string ,{\Xatsign}format-arguments)) \\*
~~~~~~~(values nil t))))
\end{lisp}

  \cdf{with-simple-restart}.
\begin{lisp}
Lisp> (defun read-eval-print-loop (level) \\*
~~~~~~~~(with-simple-restart \\*
~~~~~~~~~~~~(abort "Exit command level {\Xtilde}D." level) \\*
~~~~~~~~~~(loop \\*
~~~~~~~~~~~~(with-simple-restart \\*
~~~~~~~~~~~~~~~~(abort "Return to command level {\Xtilde}D." level) \\*
~~~~~~~~~~~~~~(let ((form (prog2 (fresh-line) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(read) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~(fresh-line)))) \\*
~~~~~~~~~~~~~~~~(prin1 (eval form))))))) \\*
~\EV\ READ-EVAL-PRINT-LOOP \\
Lisp> (read-eval-print-loop 1) \\*
(+ 'a 3) \\
Error: The argument, A, to the function + was of the wrong type. \\*
~~~~~~~The function expected a number. \\*
To continue, type :CONTINUE followed by an option number: \\*
~1: Specify a value to use this time. \\*
~2: Return to command level 1. \\*
~3: Exit command level 1. \\*
~4: Return to Lisp Toplevel. \\*
Debug> 
\end{lisp}

\beforenoterule
\begin{sideremark}
Some readers may wonder what ought to be done by the ``abort'' key (or whatever
the implementation's interrupt key is---Control-C or Control-G, for
example). Such interrupts, whether synchronous or asynchronous in nature, are
beyond the scope of this chapter and indeed are not currently addressed by
Common Lisp at all. This may be a topic worth standardizing under separate
cover. Here is some speculation about some possible things that might happen.

An implementation might simply call \cdf{abort} or \cdf{break} directly without
signaling any condition.

Another implementation might signal some condition related to the fact that a
key had been pressed rather than to the action that should be taken. This is one
way to allow user customization.  Perhaps there would be an
implementation-dependent \cdf{keyboard-interrupt} condition type with a slot
containing the key that was pressed---or perhaps there would be such a condition
type, but rather than its having slots, different subtypes of that type with
names like \cdf{keyboard-abort}, \cdf{keyboard-break}, and so on might be
signaled. That implementation would then document the action it would take if
user programs failed to handle the condition, and perhaps ways for user programs
to usefully dismiss the interrupt.
\end{sideremark}
\betweennoterule
\begin{implementation}
Implementors are encouraged to make sure that there is always a restart named
\cdf{abort} around any user code so that user code  can call \cdf{abort} at any
time and expect something reasonable to happen; exactly what the reasonable
thing is may vary somewhat. Typically, in an interactive program, invoking
\cdf{abort} should return the user to top level, though in some batch or
multi-processing situations killing the running process might be more
appropriate.
\end{implementation}
\afternoterule
\end{defmac}

\begin{defmac}
restart-case expression {(case-name arglist
                         {keyword value}*
                         {form}*)}*

 \emph{expression}    ,  
   ,     
.  \emph{expression}     
,        \cdf{restart-case}. 
 \emph{expression},        
 ( \cdf{invoke-restart}).   ,  
          
  \cdf{restart-case}.

  ,  \emph{expression}  ,  
\emph{car}  \cdf{signal}, \cdf{error}, \cdf{cerror}  \cdf{warn}, 
\cdf{with-condition-restarts}      
 . ,
\begin{lisp}
(restart-case (signal weird-error) \\*
~~(become-confused ...) \\*
~~(rewind-line-printer ...) \\*
~~(halt-and-catch-fire ...))
\end{lisp}

\begin{lisp}
(restart-case (with-condition-restarts \\*
~~~~~~~~~~~~~~~~weird-error  \\*
~~~~~~~~~~~~~~~~(list (find-restart 'become-confused)  \\*
~~~~~~~~~~~~~~~~~~~~~~(find-restart 'rewind-line-printer) \\*
~~~~~~~~~~~~~~~~~~~~~~(find-restart 'halt-and-catch-fire)) \\*
~~~~~~~~~~~~~~~~(signal weird-error)) \\
~~(become-confused ...) \\*
~~(rewind-line-printer ...) \\*
~~(halt-and-catch-fire ...))
\end{lisp}

  \emph{form}    , \cdf{restart-case} 
 \cdf{nil}.

\emph{case-name}   \cdf{nil}  ,   .

       
\emph{case-name}.   , \cdf{find-restart}    
 .      \cdf{compute-restarts}.

  \emph{arglist}   - 
        \emph{form}. 
        
\cdf{invoke-restart}   \cdf{restart-case}.

-, \cdf{invoke-restart-interactively}    
          
. ,     , 
  \cd{:interactive}    
\cdf{invoke-restart-interactively}  ,    
.

  \emph{keyword value}  :
\begin{flushdesc}

\item[\cd{:test \emph{fn}}]

   \emph{fn}      
   \cdf{function}.
   \cd{(function~\emph{fn})}     
  .      : . 
     \cdf{nil}   , 
  \cdf{find-restart}, \cdf{compute-restart}  \cdf{invoke-restart}  
      .     , 
    -
  \begin{lisp}
    (lambda (c) (declare (ignore c)) t)
  \end{lisp}

\item[\cd{:interactive \emph{fn}}]

   \emph{fn}      
   \cdf{function}.
   \cd{(function~\emph{fn})}     
  .      ,  
  ,   \cdf{invoke-restart-interactively}  
   .       
      .
         
   \cdf{*query-io*}.

      ,   \cd{:interactive}  
  ,    .

\item[\cd{:report \emph{exp}}]

    \emph{exp}    ,   
       \cdf{function}. 
  \cd{(function~\emph{exp})}     
  .      : , 
        .  
         \cdf{*print-escape*} 
  \cdf{nil}.

   \emph{exp}   ,   
  :
  \begin{lisp}
    (lambda (s) (write-string \emph{exp} s))
  \end{lisp}

       ,     
  ,        .

  When \cdf{*print-escape*} is \cdf{nil}, the printer will use the report
  information for a restart. For example, a debugger might announce the action
  of typing ``\cd{:continue}'' by executing the equivalent of
  \begin{lisp}
    (format *debug-io* "{\Xtilde}\&{\Xtilde}S -- {\Xtilde}A{\Xtilde}\%" ':continue some-restart)
  \end{lisp}
  which might then display as something like
  \begin{lisp}
    :CONTINUE -- Return to command level.
  \end{lisp}
 
           .
\beforenoterule
\begin{rationale}
Unnamed restarts are required to have report information on
the grounds that they are generally only useful interactively, and an
interactive option that has no description is of little value.
\end{rationale}
\betweennoterule
\begin{implementation}
Implementations are encouraged to warn about this error
at compilation time.

At run time, this error might be noticed when entering the debugger. Since
signaling an error would probably cause recursive entry into the debugger
(causing yet another recursive error, and so on), it is suggested that the
debugger print some indication of such problems when they occur, but not
actually signal errors.
\end{implementation}
\afternoterule

\end{flushdesc}
 ,  
\begin{lisp}
(restart-case \emph{expression} \\*
~~(\emph{name\SU{1}} \emph{arglist\SU{1}} \emph{options\SU{1}} . \emph{body\SU{1}}) \\*
~~(\emph{name\SU{2}} \emph{arglist\SU{2}} \emph{options\SU{2}} . \emph{body\SU{2}}) \\*
~~...)
\end{lisp}
  
\begin{lisp}
(block \#1=\#:block-1 \\*
~~(let ((\#2=\#:var-2 nil)) \\*
~~~~(tagbody \\*
~~~~~~(restart-bind ((\emph{name\SU{1}} \=\#'(lambda (\&rest temp) \\*
\>~~~~(setq \#2\# temp) \\*
\>~~~~(go \#3=\#:tag-3)) \\*
\>\textrm{$\langle$slightly transformed \emph{options\SU{1}}$\rangle$}) \\
~~~~~~~~~~~~~~~~~~~~~(\emph{name\SU{2}} \=\#'(lambda (\&rest temp) \\*
\>~~~~(setq \#2\# temp) \\*
\>~~~~(go \#4=\#:tag-4)) \\*
\>\textrm{$\langle$slightly transformed \emph{options\SU{2}}$\rangle$}) \\*
~~~~~~~~~~~~~~~~~~~~~...) \\*
~~~~~~~~(return-from \#1\# expression)) \\
~~~~~~\#3\# (return-from \#1\# \\*
~~~~~~~~~~~~~~~~(apply \#'(lambda \emph{arglist\SU{1}} . \emph{body\SU{1}}) \#2\#)) \\
~~~~~~\#4\# (return-from \#1\# \\*
~~~~~~~~~~~~~~~~(apply \#'(lambda \emph{arglist\SU{2}} . \emph{body\SU{2}}) \#2\#)) \\*
~~~~~~...)))
\end{lisp}
[Note the use of ``gensyms'' such as \cd{\#:block-1} as block names,
variables, and \cdf{tagbody} tags in this example,
and the use of \cd{\#\emph{n}=} and \cd{\#\emph{n}\#} read-macro syntax
to indicate that the very same gensym appears in multiple places.---GLS]

   \cdf{restart-case}.
\begin{lisp}
(loop \\*
~~(restart-case (return (apply function some-args)) \\*
~~~~(new-function (new-function) \\*
~~~~~~~~:report "Use a different function." \\*
~~~~~~~~:interactive \\*
~~~~~~~~~~(lambda () \\*
~~~~~~~~~~~~(list (prompt-for 'function "Function: "))) \\*
~~~~~~(setq function new-function)))) \\
 \\
(loop \\*
~~(restart-case (return (apply function some-args)) \\*
~~~~(nil (new-function) \\*
~~~~~~~~:report "Use a different function." \\*
~~~~~~~~:interactive \\*
~~~~~~~~~~(lambda () \\*
~~~~~~~~~~~~(list (prompt-for 'function "Function: "))) \\*
~~~~~~(setq function new-function)))) \\
 \\
(restart-case (a-command-loop) \\*
~~(return-from-command-level () \\*
~~~~~~:report \\*
~~~~~~~~(lambda (s)~~~~~;\textrm{Argument \cdf{s} is a stream} \\*
~~~~~~~~~~(format s "Return from command level {\Xtilde}D." level)) \\*
~~~~nil)) \\
 \\
(loop  \\*
~~(restart-case (another-random-computation) \\*
~~~~(continue () nil)))
\end{lisp}
          
 ,        
 .   << >>  ,
  :
\begin{lisp}
(when (find-restart 'new-function) \\*
~~(invoke-restart 'new-function the-replacement))
\end{lisp}
         
,         
\cdf{new-function}.

  :
\begin{lisp}
(let ((my-food 'milk) \\*
~~~~~~(my-color 'greenish-blue)) \\*
~~(do () \\*
~~~~~~((not (bad-food-color-p my-food my-color))) \\*
~~~~(restart-case (error 'bad-food-color \\*
~~~~~~~~~~~~~~~~~~~~~~~~~:food my-food :color my-color) \\*
~~~~~~(use-food (new-food) \\*
~~~~~~~~~~:report "Use another food." \\*
~~~~~~~~(setq my-food new-food)) \\
~~~~~~(use-color (new-color) \\*
~~~~~~~~~~:report "Use another color." \\*
~~~~~~~~(setq my-color new-color)))) \\*
~~;; We won't get to here until MY-FOOD \\*
~~;; and MY-COLOR are compatible. \\*
~~(list my-food my-color))
\end{lisp}
,  \cdf{use-food}  \cdf{use-color}   :
\begin{lisp}
(defun use-food (new-food) \\*
~~(invoke-restart 'use-food new-food)) \\
\\
(defun use-color (new-color) \\*
~~(invoke-restart 'use-color new-color))
\end{lisp}
       .   color
  food. :
\begin{lisp}
\#'(lambda (c) ... (use-color 'white) ...)~~~;\textrm{Corrects \cdf{color}} \\
\\
\#'(lambda (c) ... (use-food 'cheese) ...)~~~;\textrm{Corrects \cdf{food}}
\end{lisp}

  \cdf{handler-bind}  \cdf{restart-case},  
   \cdf{foo-error},    .
\begin{lisp}
(handler-bind ((foo-error \#'(lambda (ignore) (use-value 7)))) \\*
~~(restart-case (error 'foo-error) \\*
~~~~(use-value (x) (* x x)))) \\*
~\EV\ 49
\end{lisp}
\end{defmac}


\begin{defmac}
restart-bind ({(name function {keyword value}*)}*) {form}*

     ,    
.

   \emph{name}    \cdf{nil},  
 ,    ,   
.

  \emph{function}  ,    ,
     .  , 
      ,  
.     ,  
  .   ,     
\cdf{invoke-restart},      
 .    ,  
\cd{:interactive-function}.

  \emph{keyword value}  :
\begin{flushdesc}

\item[\cd{:test-function \emph{form}}]
   \emph{form}         
    : .      
   \cdf{nil},    \cdf{find-restart},
  \cdf{compute-restart}  \cdf{invoke-restart}   
  ,     .     , 
    -
  \begin{lisp}
    \#'(lambda (c) (declare (ignore c)) t)
  \end{lisp}

\item[\cd{:interactive-function \emph{form}}]

   \emph{form}        
     ,     
    \cdf{invoke-restart-interactively},   
  .        
   \cdf{*query-io*}.

\item[\cd{:report-function \emph{form}}]

   \emph{form}        
     : ,     
       .   
      ,  \cdf{*print-escape*}  \cdf{nil}.
\end{flushdesc}
\end{defmac}

\begin{defmac}
with-condition-restarts condition-form restarts-form
  {declaration}* {form}*

 \emph{condition-form}    \emph{C}  
\emph{restarts-form}     \cd{(\emph{R1} \emph{R2}
...)}.   \emph{form}    \cdf{progn}. 
       ,  
  $C'$,    \emph{R1}, \emph{R2},
$\ldots$,  $C'$  \cdf{eq} \emph{}.

       ,   \cdf{restart-case}
     ,     
.
\end{defmac}

\subsection{   }

      .

\begin{defun}[]
compute-restarts &optional condition

       ,
    .

  \emph{condition}     \cdf{nil}, 
  .   \emph{condition}   \cdf{nil},
      .

   ,     
  ,  ,    
    .      
  .      
  (   ,  
).

  \cdf{compute-restarts}   ,   (
,  )      .

 ,  \cdf{compute-restarts}   
,  ,       
         \cdf{find-restarts}.

 ,   ,     
(    \cdf{eq})    
\cdf{compute-restarts}.  ,  , 
.
\end{defun}


\begin{defun}[]
restart-name restart

    \emph{restart}  \cdf{nil},  
  .
\end{defun}

\begin{defun}[]
find-restart restart-identifier &optional condition

      .

  \emph{condition}     \cdf{nil}, 
  .   \emph{condition}   \cdf{nil},
      .

  \emph{restart-identifier}  -\cdf{nil} , 
   (    ) 
  .       \cdf{nil}.

 \emph{restart-identifier}   , ,  
,    .   \cdf{nil}.

  ,      \cdf{nil}, 
    \emph{restart-identifier} 
. ,   ,     
\cdf{compute-restarts}.
\end{defun}

\begin{defun}[]
invoke-restart restart-identifier &rest arguments

      \emph{restart-identifier}, 
     \emph{arguments}. 
\emph{restart-identifier}     -null 
,      .

\beforenoterule
\begin{implementation} 
    ,   .
\end{implementation} 
\afternoterule
\end{defun}

\begin{defun}[]
invoke-restart-interactively restart-identifier

 ,     
\emph{restart-identifier},    
. \emph{restart-identifier}     -null 
,     .   
,    \cdf{control-error}.

 \cdf{invoke-restart-interactively}     
  \cd{:interactive}  \cdf{restart-case} 
\cd{:interactive-function}  \cdf{restart-bind}.

    \cdf{restart-case}  \cdf{restart-bind}  
  \cd{:interactive}  \cd{:interactive-function},  
   ,   .   
  ,     .

   \cdf{invoke-restart-interactively}  , 
  \cd{(apply~\#'invoke-restart \emph{restart-identifier}
\emph{arguments})}.

\cdf{invoke-restart-interactively}      
      .
\end{defun}

\subsection{}
\label{WARNING-CONDITIONS}

   ,    <<>>.

\begin{defun}[]
warn datum &rest arguments

        \cdf{warning}.

 \emph{datum}  ,     .  
,      \cdf{warning}  
  \cdf{nil},    \cdf{type-error}.

 \emph{datum}    (   ), 
     \cd{(apply \#'make-condition \emph{datum}
\emph{arguments})}.     \cdf{warning}, 
    \cdf{type-error}.

 \emph{datum}  ,       
\begin{lisp}
(make-condition 'simple-error \\*
~~~~~~~~~~~~~~~~:format-string \emph{datum} \\*
~~~~~~~~~~~~~~~~:format-arguments \emph{arguments})
\end{lisp}
      .
\begin{enumerate}
\item  .
  
        \cdf{warning}, 
  \cdf{muffle-warning}      
  \cdf{warn} ( ,  \cdf{warn}   \cdf{nil}) 

     ,  \cd{(typep \emph{condition}
    *break-on-signals*)}  ,  \cdf{break}  
     .

\item      ,    
  ,     \cdf{*error-output*}   
  \cdf{warn}.

\item  \cdf{warn} -  ,   
   \cdf{nil}.

\end{enumerate}
\end{defun}

\subsection{ }

Common Lisp     .

\begin{defun}[]
abort &optional condition

        \cdf{abort}. 
  , \cdf{continue}  \cdf{nil}.

  \emph{condition}     \cdf{nil}, 
  .   \emph{condition}   \cdf{nil},
      .
\end{defun}

\begin{defun}[]
continue &optional condition

        \cdf{continue}. 
  , \cdf{continue}  \cdf{nil}.

  \emph{condition}     \cdf{nil}, 
  .   \emph{condition}   \cdf{nil},
      .

 \cdf{continue}    ,  
  <<>>    ,
  \cdf{break}  \cdf{cerror}.    
       .  , , 
       ,  
   .
\end{defun}

\begin{defun}[]
muffle-warning &optional condition

    (   )   
 \cdf{muffle-warning}.    , \cdf{muffle-warning}
  \cdf{control-error}.

  \emph{condition}     \cdf{nil}, 
  .   \emph{condition}   \cdf{nil},
      .

\cdf{warn}   ,  ,  
 \cdf{warning}    \cdf{warn},  \cdf{warning} 
 ,       .
\end{defun}

\begin{defun}[]
store-value value &optional condition

    (   )   
 \cdf{store-value}.    , \cdf{store-value}
 \cdf{nil}.

  \emph{condition}     \cdf{nil}, 
  .   \emph{condition}   \cdf{nil},
      .

 \cdf{use-value}   ,  
     ,  \cdf{cell-error} 
\cdf{type-error},        
\emph{datum}   .
\end{defun}

\begin{defun}[]
use-value value &optional condition

    (   )   
 \cdf{use-value}.    , \cdf{use-value} 
\cdf{nil}.

  \emph{condition}     \cdf{nil}, 
  .   \emph{condition}   \cdf{nil},
      .

 \cdf{use-value}   ,  
     ,  \cdf{cell-error},  
      \emph{datum}  
.
\end{defun}

\subsection{ }
\label{DEBUGGING-UTILITIES}

Common Lisp   ,         
,    ,      
()  ().

\begin{defun}[]
break &optional format-string &rest format-arguments

 \cdf{break}       
: \emph{format-string}  \emph{format-arguments},   
    .

 \emph{format-string}  ,    -.

  , \cdf{break}  \cdf{nil}.

 ,  \cdf{break}      
   << >>,    
 . ,     
 \cdf{break}, -    
. , \cdf{break}     ,
   \cdf{cerror}   .

       
       \cdf{break} 
\cdf{cerror}.      
  , ,    \cdf{break},   
  ,    --
(read-eval-print loop, REPL).

\cdf{break}    
\begin{lisp}
(defun break (\&optional (format-string "Break") \\*
~~~~~~~~~~~~~~\&rest format-arguments) \\*
~~(with-simple-restart (continue "Return from BREAK.") \\*
~~~~(invoke-debugger \\*
~~~~~~(make-condition 'simple-condition \\*
~~~~~~~~~~~~~~~~~~~~~~:format-string format-string \\*
~~~~~~~~~~~~~~~~~~~~~~:format-arguments format-arguments))) \\*
~~nil)
\end{lisp}
\end{defun}

\begin{defun}[]
invoke-debugger condition

    ,      .

  \cdf{*debugger-hook*}   \cdf{nil},     
 :    \emph{condition}  
\cdf{*debugger-hook*}.  - -  ,
   .

      -. 
      ,  ,
.

\beforenoterule
\begin{sideremark} 
The exact way in which the debugger interacts with users is
expected to vary considerably from system to system. For example, some systems
may use a keyboard interface, while others may use a mouse interface. Of those
systems using keyboard commands, some may use single-character commands and
others may use parsed line-at-a-time commands. The exact set of commands will
vary as well. The important properties of a debugger are that it makes
information about the error accessible and that it makes the set of apparent
restarts easily accessible.

It is desirable to have a mode where the debugger allows other features, such as
the ability to inspect data, stacks, etc. However, it may sometimes be
appropriate to have this kind of information hidden from users. Experience on
the Lisp Machines has shown that some users who are not programmers develop a
terrible phobia of debuggers. The reason for this usually may be traced to the
fact that the debugger is very foreign to them and provides an overwhelming
amount of information of interest only to programmers. With the advent of
restarts, there is a clear mechanism for the construction of ``friendly''
debuggers. Programmers can be taught how to get to the information they need for
debugging, but it should be possible to construct user interfaces to the
debugger that are natural, convenient, intelligible, and friendly even to
non-programmers.
\end{sideremark}
\afternoterule
\end{defun}

\begin{defun}[]
*debugger-hook*

     \cdf{nil},    , 
  :    \cdf{*debugger-hook*}. 
     (   ) 
-  ( ,    
 ).

 ,       ,   
\cdf{*debugger-hook*}    \cdf{nil}.   
  , -   
\cdf{*debugger-hook*}  ,     ,  
          .
\end{defun}

\section{  }        
\label{PREDEFINED-CONDITIONS-SECTION}

     CLOS      
CLOS .

\begin{defun}[]
restart 

    .
\end{defun}

\begin{table}[t]
\caption{  }
\label{CONDITION-HIERARCHY-TABLE}
\begin{lisp}
condition \\
~~~~simple-condition \\
~~~~serious-condition \\
~~~~~~~~error \\
~~~~~~~~~~~~simple-error \\
~~~~~~~~~~~~arithmetic-error \\
~~~~~~~~~~~~~~~~division-by-zero \\
~~~~~~~~~~~~~~~~floating-point-overflow \\
~~~~~~~~~~~~~~~~floating-point-underflow \\
~~~~~~~~~~~~~~~~... \\
~~~~~~~~~~~~cell-error \\
~~~~~~~~~~~~~~~~unbound-variable \\
~~~~~~~~~~~~~~~~undefined-function \\
~~~~~~~~~~~~~~~~... \\
~~~~~~~~~~~~control-error \\
~~~~~~~~~~~~file-error \\
~~~~~~~~~~~~package-error \\
~~~~~~~~~~~~program-error \\
~~~~~~~~~~~~stream-error \\
~~~~~~~~~~~~~~~~end-of-file \\
~~~~~~~~~~~~~~~~... \\
~~~~~~~~~~~~type-error \\
~~~~~~~~~~~~~~~~simple-type-error \\
~~~~~~~~~~~~~~~~... \\
~~~~~~~~~~~~... \\
~~~~~~~~storage-condition \\
~~~~~~~~... \\
~~~~warning \\
~~~~~~~~simple-warning \\
~~~~~~~~... \\
~~~~...
\end{lisp}
\vfill
\end{table}

  Common Lisp'   
~\ref{CONDITION-HIERARCHY-TABLE}.

,        ( 
\cdf{condition}, \cdf{warning}, \cdf{storage-condition}, \cdf{error},
\cdf{arithmetic-error}, \cdf{control-error},   ), 
     .     
.

        ,  
   ,       ,  
 .

 \cdf{simple-condition}, \cdf{serious-condition}  \cdf{warning}  
.  \cdf{error}      
\cdf{simple-condition}  \cdf{warning}.

\begin{defun}[]
condition

  ,     ,     .
\end{defun}

\begin{defun}[]
warning

  ,     .   
 \cdf{condition}.
\end{defun}

\begin{defun}[]
serious-condition

   (  ,   
,     )     . 

       
. ,  ,   
\cdf{serious-condition}    .  
 \cdf{error} (   )   
 ,   \cdf{signal}     .
\end{defun}

\begin{defun}[]
error

  ,     .   
 \cdf{serious-condition}.
\end{defun}

  -  \cdf{signal}  \cdf{warn} ---
\cdf{simple-condition}.
  -  \cdf{error}  \cdf{cerror} --- \cdf{simple-error}.

\begin{defun}[]
simple-condition

     \cdf{signal},      
   .    
\cdf{condition}.     
 \cd{:format-string}  \cd{:format-arguments}.    
 \cdf{simple-condition-format-control} 
\cdf{simple-condition-format-arguments}.   \cdf{make-condition}
\cd{:format-arguments}  ,   \emph{format-arguments} -
  \cdf{nil}.
\end{defun}

\begin{defun}[]
simple-warning

     \cdf{warn},      
   .    
\cdf{condition}.     
 \cd{:format-string}  \cd{:format-arguments}.    
 \cdf{simple-condition-format-control} 
\cdf{simple-condition-format-arguments}.   \cdf{make-condition}
\cd{:format-arguments}  ,   \emph{format-arguments} -
  \cdf{nil}.

    ,    
 \cdf{simple-condition}.
\end{defun}

\begin{defun}[]
simple-error

     \cdf{error}  \cdf{cerror},    
     .   
 \cdf{condition}.     
\cd{:format-string}  \cd{:format-arguments}.     
\cdf{simple-condition-format-control} 
\cdf{simple-condition-format-arguments}.   \cdf{make-condition}
\cd{:format-arguments}  ,   \emph{format-arguments} -
  \cdf{nil}.

    ,    
 \cdf{simple-condition}.
\end{defun}

\begin{defun}[]
simple-condition-format-control condition

     \cd{format-string}   
\emph{condition},      
\cdf{simple-condition}, \cdf{simple-warning}, \cdf{simple-error} 
\cdf{simple-type-error}
\end{defun}

\begin{defun}[]
simple-condition-format-arguments condition

     \cd{format-arguments}   
\emph{condition},      
\cdf{simple-condition}, \cdf{simple-warning}, \cdf{simple-error} 
\cdf{simple-type-error}
\end{defun}

\begin{defun}[]
storage-condition

,      , 
   .      \cdf{serious-condition}.
\end{defun}

\begin{defun}[]
type-error

         
.     \cdf{error}. , , 
   \cdf{check-type},     
.      
 \cd{:datum}  \cd{:expected-type}.    
 \cdf{type-error-datum} 
\cdf{type-error-expected-type}.
\end{defun}

\begin{defun}[]
type-error-datum condition

     \cd{datum}  
\emph{condition},     \cdf{type-error}.
\end{defun}

\begin{defun}[]
type-error-expected-type condition

     \cd{expected-type}  
\emph{condition},    
\cdf{type-error}. ,   \cdf{type-error} 
   ,    Common Lisp'
 .
\end{defun}

\begin{defun}[]
simple-type-error

,   ,  \cdf{check-type}, 
  .     
 \cd{:format-string}  \cd{:format-arguments}.    
   \cd{simple-condition-format-control} 
\cdf{simple-condition-format-arguments}.   \cdf{make-condition}
\cd{:format-arguments}   ,     \cdf{nil}.
\end{defun}

\begin{defun}[]
program-error

,     ,    
 ,      (  
,     ).    
\cdf{error}.      \cdf{control-error}.
\end{defun}

\begin{defun}[]
control-error

         
 .     \cdf{error}.    
 \cdf{program-error}.

  ,    \cdf{throw}     
  \cdf{go}  \cdf{return-from}     
.

  ,         
 \cdf{go}  \cdf{return-from}    (program
errors).  \cdf{program-error}.
\end{defun}


\begin{defun}[]
package-error

,      ,   
 .     \cdf{error}.  
    \cd{:package}.    
   \cdf{package-error-package}.
\end{defun}

\begin{defun}[]
package-error-package condition

    (  ),    
\emph{condition}  \cdf{package-error}
\end{defun}

\begin{defun}[]
stream-error

,      ,  ,  , 
   .     \cdf{error}. 
     \cd{:stream}.  
    \cdf{stream-error-stream}.
\end{defun}

\begin{defun}[]
stream-error-stream condition

   ,     \emph{condition} 
\cdf{stream-error}.
\end{defun}

\begin{defun}[]
end-of-file

        ,    
 .     \cdf{stream-error}.
\end{defun}

\begin{defun}[]
file-error

,      ,   
    ,    
.     \cdf{error}.   
   \cd{:pathname}.     
 \cdf{file-error-pathname}.
\end{defun}

\begin{defun}[]
file-error-pathname condition

     ---    \emph{condition} 
\cdf{file-error}.
\end{defun}

\begin{defun}[]
cell-error

,       , 
   .     \cdf{error}. 
     
\cd{:name}.         \cdf{cell-error-name}.
\end{defun}

\begin{defun}[]
cell-error-name condition

     \cd{error-name}  
\emph{condition}  \cdf{cell-error}.
\end{defun}

\begin{defun}[]
unbound-variable

,       .  
 \cdf{cell-error}.
\end{defun}

\begin{defun}[]
undefined-function

,       . 
  \cdf{cell-error}.
\end{defun}

\beforenoterule
\begin{sideremark} [Note: This remark was written well before the vote by X3J13
in June 1988 \issue{CLOS} to add the Common Lisp Object System to the
forthcoming draft standard (see chapter~\ref{CLOS}) and the vote to integrate
the Condition System and the Object System.  I have retained the remark here for
reasons of historical interest.---GLS]

Some readers may wonder why \cdf{undefined-function} is not defined to inherit
from some condition such as \cdf{control-error}. The answer is that any such
arrangement would require the presence of multiple inheritance---a  luxury we do
not currently have (without resorting to \cdf{deftype}, which  we are currently
avoiding). When the Common Lisp Object System comes into being, we might want to
consider issues like this.  Multiple inheritance makes a lot of things in a
condition system much more flexible to deal with.
\end{sideremark}
\afternoterule

\begin{defun}[]
arithmetic-error

         
 .     \cdf{error}. 
     
\cd{:operation}  \cd{:operands}.    
 \cdf{arithmetic-error-operation}  \cdf{arithmetic-error-operands}.
\end{defun}

\begin{defun}[]
arithmetic-error-operation condition

        \cdf{arithmetic-error}.
\end{defun}

\begin{defun}[]
arithmetic-error-operands condition

        \cdf{arithmetic-error}.
\end{defun}

\begin{defun}[]
division-by-zero

,   -   ,    
.     \cdf{arithmetic-error}.
\end{defun}

\begin{defun}[]
floating-point-overflow

,   -  (overflow)   
 ,     .    
\cdf{arithmetic-error}.
\end{defun}

\begin{defun}[]
floating-point-underflow

,   -  (underflow)   
 ,     .    
\cdf{arithmetic-error}.
\end{defun}
\fi
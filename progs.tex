%Part{Progs, Root = "CLM.MSS"}
%Chapter of Spice Lisp Manual.  Copyright 1984, 1988, 1989 Guy L. Steele Jr.

\clearpage\def\pagestatus{FINAL PROOF}

\ifx \rulang\Undef
\chapter{Program Structure}
\label{PROGS}

In chapter~\ref{DTYPES} the syntax was sketched for notating data objects
in Common Lisp.  The same syntax is used for notating programs because all
Common Lisp programs have a representation as Common Lisp data objects.

Lisp programs are organized as forms and functions.  Forms are
\emph{evaluated} (relative to some context) to produce values and side
effects.  Functions are invoked by \emph{applying} them to arguments.
The most important kind of form performs a function call;
conversely, a function performs computation by evaluating forms.

In this chapter, forms are discussed first and then functions.
Finally, certain ``top level'' special operators are discussed; the most
important of these is \cdf{defun}, whose purpose is to define a
named function.

\section{Forms}

The standard unit of interaction with a Common Lisp implementation is the \emph{form},
which is simply a data object meant to be \emph{evaluated} as a program
to produce one or more \emph{values} (which are also data objects).
One may request evaluation of \emph{any} data object, but only certain ones
are meaningful.  For instance,
symbols and lists are meaningful forms, while arrays
normally are not.  Examples of meaningful forms are \cd{3},
whose value is \cd{3}, and \cd{(+ 3 4)}, whose value is \cd{7}.
We write \cd{3} \EV\ \cd{3} and \cd{(+ 3 4)} \EV\ \cd{7}
to indicate these facts.  (\EV\ means ``evaluates to.'')

Meaningful forms may be divided into three categories:
self-evaluating forms, such as numbers; symbols, which stand
for variables; and lists.  The lists in turn may be divided
into three categories: special operators, macro calls, and function calls.

\emph{All} standard Common Lisp data objects other than symbols
and lists (including \cdf{defstruct} structures defined
without the \cd{:type} option) are self-evaluating.

\subsection{Self-Evaluating Forms}

All numbers, characters, strings, and bit-vectors
are \emph{self-evaluating} forms.
When such an object is evaluated, that object
(or possibly a copy in the case of numbers or characters)
is returned as the value
of the form.  The empty list {\emptylist}, which is also the false value {\false},
is also a self-evaluating form: the value of {\false} is {\false}.
Keywords (symbols written with a leading colon) also evaluate
to themselves: the value of \cd{:start} is \cd{:start}.

It is an error to destructively modify any object that appears as a constant
in executable code, whether as
a self-evaluating form or within a \cdf{quote} special operator.

\subsection{Variables}

Symbols are used as names of variables in Common Lisp programs.
When a symbol is evaluated as a form, the value of the variable it names
is produced.  For example, after doing \cd{(setq items 3)}, which assigns
the value \cd{3} to the variable named \cdf{items}, then \cdf{items} \EV\ \cd{3}.
Variables can be \emph{assigned} to, as by \cdf{setq}, or \emph{bound},
as by \cdf{let}.
Any program construct that binds a variable effectively saves the old
value of the variable and causes it to have a new value, and on exit from
the construct the old value is reinstated.

There are actually two kinds of variables in Common Lisp, called \emph{lexical} (or
\emph{static}) variables and \emph{special} (or \emph{dynamic}) variables.
At any given time either or both kinds of variable with the same name may
have a current value.  Which of the two kinds of variable is referred to
when a symbol is evaluated depends on the context of the evaluation.
The general rule is that if the symbol occurs textually within a program
construct that creates a \emph{binding} for a variable of the same name,
then the reference is to the variable specified by the binding;
if no such program construct textually contains the reference, then
it is taken to refer to the special variable of that name.

The distinction between the two kinds of variable is one of scope
and extent.  A lexically bound variable can be referred to \emph{only}
by forms occurring at any \emph{place} textually within the program construct that
binds the variable.  A dynamically bound (special) variable can
be referred to at any \emph{time} from the time the binding is made
until the time evaluation of the construct that binds the variable
terminates.  Therefore lexical binding of variables
imposes a spatial limitation
on occurrences of references (but no temporal limitation, for the
binding continues to exist as long as the possibility of reference
remains).  Conversely, dynamic binding of variables imposes a temporal
limitation on occurrences of references (but no spatial limitation).
For more information on scope and extent, see chapter~\ref{SCOPE}.

The value a special variable has when there are currently
no bindings of that variable is called the \emph{global} value of the
(special) variable.
A global value can be given to a variable only by assignment,
because a value given by binding is by definition not global.

It is possible for a special variable to have no value at all,
in which case it is said to be \emph{unbound}.
By default, every global variable is unbound unless and until
explicitly assigned a value, except for those global variables
defined in this book or by the implementation already to have values
when the Lisp system is first started.
It is also possible to establish a binding of a special variable
and then cause that binding to be valueless by using the
function \cdf{makunbound}.  In this situation the variable
is also said to be ``unbound,'' although this is a misnomer;
precisely speaking, it is bound but valueless.
It is an error to refer to a variable that is unbound.

Reading an unbound variable or an undefined function
must be detected in the highest safety setting (see the
\cdf{safety} quality of the \cdf{optimize} declaration specifier)
but the effect is undefined in any other safety setting. That is,
reading an unbound variable should signal an error and
reading an undefined function should signal an error.
(``Reading a function'' includes
both references to the function using the \cdf{function}
special operator, such as \cdf{f} in \cd{(function~f)}, and references to the
function in a call, such as \cdf{f} in \cd{(f~x~y)}.)

For the case of \cdf{inline} functions (in implementations where they are
supported), a permitted point of view is that performing the inlining
constitutes the read of the function, so that an \cdf{fboundp}
check need not be done at
execution time. Put another way, the effect of the application of
\cdf{fmakunbound} to a function name
on potentially inlined references to that function is undefined.

When an unbound variable 
is detected an error of type \cdf{unbound-variable} is signaled,
and the \cdf{name} slot of the
\cdf{unbound-variable} condition is initialized to the name of the
offending variable.

When an undefined function
is detected an error of type \cdf{undefined-function} is signaled,
and the \cdf{name} slot of the
\cdf{undefined-function} condition is initialized to the name of the
offending function.

The condition type \cdf{unbound-slot}, which inherits from
\cdf{cell-error}, has an additional slot \cdf{instance}, which
can be initialized using the \cd{:instance} keyword to \cdf{make-condition}.
The function \cdf{unbound-slot-instance} accesses this slot.

The type of error signaled by the default primary
method for the CLOS \cdf{slot-unbound} generic function is \cdf{unbound-slot}.
The \cdf{instance} slot
of the \cdf{unbound-slot} condition is initialized to the offending instance
and the \cdf{name} slot is initialized
to the name of the offending variable.

Certain global variables are reserved as ``named constants.''
They have a global value and may not be bound or assigned to.
For example,
the symbols {\true} and {\false} are reserved.
One may not assign a value to {\true} or {\false},
and one may not bind {\true} or {\false}.  The global value of
{\true} is always {\true}, and the global value of
{\false} is always {\false}.  Constant symbols defined by
\cdf{defconstant} also become reserved and may not be further
assigned to or bound (although they may be redefined, if necessary, by
using \cdf{defconstant} again).  Keyword symbols,
which are notated with a leading colon, are reserved and
may never be assigned to or bound; a keyword always evaluates
to itself.

\subsection{Special Forms}

If a list is to be evaluated as a form, the first step is to examine
the first element of the list.  If the first element is one of
the symbols appearing in table~\ref{SPECIAL-FORM-TABLE},
then the list is called a \emph{special operator}.  (This use of the word
``special'' is unrelated to its use in the phrase ``special variable.'')

Special forms are generally environment and control constructs.
Every special operator has its own idiosyncratic syntax.  An example
is the \cdf{if} special operator:
\cd{(if p (+ x 4) 5)} in Common Lisp means what
``\textbf{if} \emph{p} \textbf{then} \emph{x}+4 \textbf{else} 5'' means in
Algol.

The evaluation of a special operator normally produces a value or values,
but the evaluation may instead call for a non-local exit; see \cdf{return-from},
\cdf{go}, and \cdf{throw}.

The set of special operators is fixed in Common Lisp; no way is provided
for the user to define more.  The user can create new syntactic
constructs, however, by defining macros.

The set of special operators in Common Lisp is purposely kept very small
because any program-analyzing program must have special knowledge
about every type of special operator.  Such a program needs no special
knowledge about macros because it is simple to expand the macro
and operate on the resulting expansion.  (This is not to say that
many such programs, particularly compilers, will not have such
special knowledge.  A compiler may be able
to produce much better code if it recognizes such constructs
as \cdf{typecase} and \cdf{multiple-value-bind} and gives them customized
treatment.)

\begin{table}[t]
\caption{Names of All Common Lisp Special Forms}
\label{SPECIAL-FORM-TABLE}
\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}lll@{}}
\cdf{block}&\cdf{if}&\cdf{progv} \\
\cdf{catch}&\cdf{labels}&\cdf{quote} \\
&\cdf{let}&\cdf{return-from} \\
\cdf{declare}&\cdf{let*}&\cdf{setq} \\
\cdf{eval-when}&\cdf{macrolet}&\cdf{tagbody} \\
\cdf{flet}&\cdf{multiple-value-call}&\cdf{the} \\
\cdf{function}&\cdf{multiple-value-prog1}&\cdf{throw} \\
\cdf{go}&\cdf{progn}&\cdf{unwind-protect} \\
& &\cdf{symbol-macrolet} \\
&\cdf{locally}&\cdf{load-time-value}
\end{tabular*}
\vskip 4pt
\end{table}

An implementation is free to implement as a macro any construct described
herein as a special operator.  Conversely, an implementation is free
to implement as a special operator any construct described herein as a macro
if an equivalent macro definition is also provided.
The practical consequence is that the predicates \cdf{macro-function} and
\cdf{special-operator-p} may both be true of the same symbol.
It is recommended that a program-analyzing program process
a form that is a list whose \emph{car} is a symbol as follows:

\begin{enumerate}
\item
If the program has particular knowledge about the symbol,
process the form using special-purpose code.
All of the symbols listed in table~\ref{SPECIAL-FORM-TABLE}
should fall into this category. 

\item
Otherwise, if \cdf{macro-function} is true of the symbol, apply either
\cdf{macroexpand} or \cdf{macroexpand-1}, as appropriate,
to the entire form and then start over.

\item
Otherwise, assume it is a function call.
\end{enumerate}

\subsection{Macros}

If a form is a list and the first element is not the name of a special
form, it may be the name of a \emph{macro}; if so, the form is said
to be a \emph{macro call}.  A macro is essentially a function from
forms to forms that will, given a call to that macro, compute
a new form to be evaluated in place of the macro call.
(This computation is sometimes referred to as \emph{macro expansion}.)
For example, the macro named \cdf{return} will take a form such as
\cd{(return x)} and from that form compute a new form
\cd{(return-from {\nil} x)}.  We say that the old
form \emph{expands} into the new form.  The new form is then evaluated in
place of the original form; the value of the new form is returned as the
value of the original form.

Macro calls, and subforms
of macro calls, need not be proper lists, but that use of dotted forms
requires the macro definition to use ``\cd{.~\emph{var}}'' or
``\cd{\&rest~\emph{var}}'' in order to match them properly.
It is then the responsibility of the macro definition to recognize
and appropriately handle such dotted forms or subforms.

There are a number of standard macros in Common Lisp, and the user can define more
by using \cdf{defmacro}.

Macros provided by a Common Lisp implementation as described herein may expand
into code that is not portable among differing implementations.
That is, a macro call may be implementation-independent because
the macro is defined in this book, but the expansion need not be.

\beforenoterule
\begin{implementation}
Implementors are encouraged to implement the macros
defined in this book, as far as is possible, in such a way that
the expansion will not contain any implementation-dependent
special operators, nor contain as forms data objects that
are not considered to be forms in Common Lisp.
The purpose of this restriction is to ensure that the expansion
can be processed by a program-analyzing program in an
implementation-independent manner.
There is no problem with a macro expansion containing
calls to implementation-dependent functions.
This restriction is not a requirement of Common Lisp; it is recognized
that certain complex macros may be able to expand into significantly
more efficient code in certain implementations
by using implementation-dependent special operators in the macro expansion.
\end{implementation}
\afternoterule

\subsection{Function Calls}

If a list is to be evaluated as a form and the first element is
not a symbol that names a special operator or macro, then the list
is assumed to be a \emph{function call}.  The first element of the
list is taken to name a function.  Any and all remaining elements
of the list are forms to be evaluated; one value is obtained
from each form,
and these values become the \emph{arguments} to the function.
The function is then \emph{applied} to the arguments.
The functional computation normally produces a value,
but it may instead call for a non-local exit; see \cdf{throw}.
A function that does return may produce no value or several values;
see \cdf{values}.
If and when the function returns, whatever values it returns
become the values of the function-call form.

For example, consider the evaluation of the form \cd{(+ 3 (* 4 5))}.
The symbol \cdf{+} names the addition function, not a special operator or macro.
Therefore the two forms \cd{3} and \cd{(* 4 5)} are evaluated to produce
arguments.  The form \cd{3} evaluates to \cd{3}, and the form
\cd{(* 4 5)} is a function call (to the multiplication function).
Therefore the forms \cd{4} and \cd{5} are evaluated, producing arguments
\cd{4} and \cd{5} for the multiplication.  The multiplication function
calculates the number \cd{20} and returns it.  The values \cd{3} and \cd{20}
are then given as arguments to the addition function, which calculates
and returns the number \cd{23}.  Therefore we say \cd{(+ 3 (* 4 5)) \EV\ 23}.

While the arguments in a function call are always
evaluated in strict left-to-right order, whether the function to
be called is determined before or after argument evaluation
is unspecified.  Programs are in error
that rely on a particular order of evaluation
of the first element of a function call relative to the
argument forms.

\section{Functions}

There are two ways to indicate a function to be used in a function-call
form.  One is to use a symbol that names the function.  This use of
symbols to name functions is completely independent of their use in
naming special and lexical variables.  The other way is to use a
\emph{lambda-expression}, which is a list whose first element is the symbol
\cdf{lambda}.  A lambda-expression is \emph{not} a form; it cannot be
meaningfully evaluated.  Lambda-expressions and symbols, when used in
programs as names of functions, can appear only as the first element of a
function-call form, or as the second element of the \cdf{function}
special operator.  Note that symbols and lambda-expressions are treated as
\emph{names} of functions in these two contexts.  This should be
distinguished from the treatment of symbols and lambda-expressions as
\emph{function objects}, that is,
objects that satisfy the predicate \cdf{functionp},
as when giving such an object to \cdf{apply} or \cdf{funcall} to be
invoked.

\subsection{Named Functions}

A name can be given to a function in one of two ways.
A \emph{global name} can be given to a function by using the
\cdf{defun} construct.
A \emph{local name} can be given to a function by using the
\cdf{flet} or
\cdf{labels} special operator.
When a function is named, a lambda-expression is effectively
associated with that name
along with information about the entities that are lexically apparent
at that point.
If a symbol appears as the first element of a function-call form, then it
refers to the definition established by the innermost \cdf{flet} or \cdf{labels}
construct that textually contains the reference, or to the global
definition (if any) if there is no such containing construct.

\subsection{Lambda-Expressions}
\label{LAMBDA-EXPRESSIONS-SECTION}
\indexterm{lambda-expression}
\indexterm{lambda-list}
% \indexterm{{\&optional!Symbol}}
% \indexterm{{\&rest!Symbol}}
% \indexterm{{\&key!Symbol}}
% \indexterm{{\&allow-other-keys!Symbol}}
% \indexterm{{\&aux!Symbol}}

\label{lambda-expression}
\label{lambda-list}
\label{optional}
\label{rest}
\label{key}
\label{allow-other-keys}
\label{aux}

A \emph{lambda-expression} is a list with the following syntax:
\begin{lisp}
(lambda \emph{lambda-list} . \emph{body})
\end{lisp}
The first element must be the symbol \cdf{lambda}.  The second element
must be a list.  It is called the \emph{lambda-list}, and specifies
names for the \emph{parameters} of the function.  When the function
denoted by the lambda-expression is applied to arguments,
the arguments are matched with the parameters specified by the
lambda-list.  The \emph{body} may then refer to the arguments by using
the parameter names.  The \emph{body} consists of any number of
forms (possibly zero).  These forms are evaluated in sequence,
and the results of the \emph{last} form only are returned as the results
of the application (the value {\false} is returned if there are zero
forms in the body).
The complete syntax of a lambda-expression is:

\begingroup
\def\GrossOptVars{\Mstar{\emph{var} {\Mor} \cd{(}\emph{var} \Mopt{\emph{initform} \Mopt{\emph{svar}}}\cd{)}}}
\def\GrossKeyOptVars{\Mstar{\emph{var} {\Mor} \cd{(}\Mgroup{\emph{var} {\Mor} \cd{(}\emph{keyword} \emph{var}\cd{)}} \Mopt{\emph{initform} \Mopt{\emph{svar}}}\cd{)}}}
\def\GrossAuxVars{\Mstar{\emph{var} {\Mor} \cd{(}\emph{var} \Mopt{\emph{initform}}\cd{)}}}
\begin{lisp}
(lambda (\Mstar{\emph{var}} \\
~~~~~~~~~\Mopt{\cd{\&optional} \GrossOptVars} \\
~~~~~~~~~\Mopt{\cd{\&rest} \emph{var}} \\
~~~~~~~~~\Mopt{\cd{\&key} \GrossKeyOptVars 
~~~~~~~~~~~~~~\Mopt{\cd{\&allow-other-keys}}} \\
~~~~~~~~~\Mopt{\cd{\&aux} \GrossAuxVars}) \\
~~~\Mchoice{\Mstar{\emph{declaration}} {\Mor} \emph{documentation-string}} \\
~~~\Mstar{\emph{form}})
\end{lisp}
\endgroup

Each element of a lambda-list is either a \emph{parameter specifier}
or a \emph{lambda-list keyword}; lambda-list keywords begin with \cd{\&}.
(Note that lambda-list keywords are not keywords in the usual sense;
they do not belong to the keyword package.  They are ordinary symbols
each of whose names begins with an ampersand.  This terminology
is unfortunately confusing but is retained for historical reasons.)

\emph{Keyword} in the preceding specification of a lambda-list
may be any symbol whatsoever, not just a keyword symbol
in the \cdf{keyword} package.  See below.

A lambda-list has five parts, any or all of which may be empty:

\begin{itemize}
\item
Specifiers for the \emph{required} parameters.  These are all the parameter
specifiers up to the first lambda-list keyword; if there is no such
lambda-list keyword, then all the specifiers are for required parameters.

\item
Specifiers for \emph{optional} parameters.
If the lambda-list keyword \cd{\&optional} is present,
the \emph{optional} parameter specifiers are those following the
lambda-list keyword \cd{\&optional} up to the next lambda-list keyword or the
end of the list.

\item
A specifier for a \emph{rest} parameter.  The lambda-list keyword \cd{\&rest}, if present, must
be followed by a single \emph{rest} parameter specifier,
which in turn must be followed by another lambda-list keyword or the end
of the lambda-list.

\item
Specifiers for \emph{keyword} parameters.
If the lambda-list keyword \cd{\&key} is present, all specifiers up to the next lambda-list keyword
or the end of the list are \emph{keyword} parameter specifiers.
The keyword parameter specifiers may optionally be followed by the
lambda-list keyword \cd{\&allow-other-keys}.

\item
Specifiers for \emph{aux} variables.  These are not really parameters.
If the lambda-list keyword \cd{\&aux} is present, all specifiers after it are
\emph{auxiliary variable} specifiers.
\end{itemize}

When the function represented by the lambda-expression is applied
to arguments, the arguments and parameters are processed in order
from left to right.
In the simplest case, only required parameters are present
in the lambda-list; each is specified simply by a name \emph{var} for
the parameter variable.
When the function is applied,
there must be exactly as many arguments as there are parameters,
and each parameter is bound to one argument.  Here, and in general,
the parameter is bound as a lexical variable unless a
declaration has been made that it should be a special binding;
see \cdf{defvar}, \cdf{proclaim}, and \cdf{declare}.

In the more general case, if there are \emph{n} required parameters
(\emph{n} may be zero), there must be at least \emph{n} arguments,
and the required parameters are bound to the first \emph{n} arguments.
The other parameters are then processed using any remaining arguments.

If \emph{optional} parameters are specified, then each one is processed as
follows.  If any unprocessed arguments remain, then the parameter variable
\emph{var} is bound to the next remaining argument, just as for a required
parameter.  If no arguments remain, however, then the \emph{initform} part
of the parameter specifier is evaluated, and the parameter variable
is bound to the resulting value (or to {\false} if no \emph{initform} appears
in the parameter specifier).
If another variable name \emph{svar} appears in the specifier, it is bound
to \emph{true} if an argument was available, and to \emph{false} if no
argument remained (and therefore \emph{initform} had to be evaluated).
The variable \emph{svar} is called a \emph{supplied-p} parameter;
it is bound not to an argument but to a value indicating whether or not
an argument had been supplied for another parameter.

After all \emph{optional} parameter specifiers have been processed,
then there may or may not be a \emph{rest} parameter.
If there is a \emph{rest} parameter, it is bound to a list of all
as-yet-unprocessed arguments.  (If no unprocessed arguments remain,
the \emph{rest} parameter is bound to the empty list.)
If there is no \emph{rest} parameter and there are no \emph{keyword}
parameters,
then there should be no unprocessed arguments (it is an error if there are).

If a function has a \emph{rest} parameter
and is called using \cdf{apply}, then the list to which the
\emph{rest} parameter is bound is permitted, but not required,
to share top-level list structure with the list that was the last
argument to \cdf{apply}.  Programmers should be careful about performing
side effects on the top-level list structure of a \emph{rest} parameter.

This was the result of a rather long discussion within X3J13 and the
wider Lisp community.  To set it in its historical context, I must remark
that in Lisp Machine Lisp the list to which a \emph{rest} parameter was
bound had only dynamic extent; this in conjunction with the
technique of ``cdr-coding'' permitted a clever stack-allocation technique
with very low overhead.  However, the early designers of
Common Lisp, after a great deal of debate, concluded that it was dangerous
for cons cells to have dynamic extent; as an example, the ``obvious''
definition of the function \cdf{list}
\begin{lisp}
(defun list (\&rest x) x)
\end{lisp}
could fail catastrophically.  Therefore the first edition simply implied
that the list for a \emph{rest} parameter, like all other lists, would
have indefinite extent.  This still left open the flip side of the
question, namely, Is the list for a \emph{rest} parameter guaranteed fresh?
This is the question addressed by the X3J13 vote.
If it is always freshly consed, then it is permissible to destroy it,
for example by giving it to \cdf{nconc}.  However, the requirement always
to cons fresh lists could impose an unacceptable overhead in many implementations.
The clarification approved by X3J13 specifies that the programmer may
not rely on the list being fresh; if the function was called using \cdf{apply},
there is no way to know where the list came from.

Next, any \emph{keyword} parameters are processed.
For this purpose the same arguments are processed that
would be made into a list for a \emph{rest} parameter.
(Indeed, it is permitted to specify both \cd{\&rest} and \cd{\&key}.
In this case the remaining arguments are used for both purposes;
that is, all remaining arguments are made into a list for the
\cd{\&rest} parameter and are also processed for the \cd{\&key} parameters.
This is the only situation in which an argument is used
in the processing of more than one parameter specifier.)
If \cd{\&key} is specified, there must remain
an even number of arguments; these are considered as pairs,
the first argument in each pair being interpreted as a keyword name
and the second as the corresponding value.

A \emph{keyword} in a lambda-list
may be any symbol whatsoever, not just a keyword symbol
in the \cdf{keyword} package.  If, after \cd{\&key},
a variable appears alone or within only one set of parentheses
(possibly with an \emph{initform} and a \emph{svar}), then
the behavior is as before: a keyword symbol with the same name as
the variable is used as the keyword-name when matching arguments
to parameter specifiers.  Only a parameter specifier of the form
\cd{((\emph{keyword} \emph{var})~...)} can cause the keyword-name
not to be a keyword symbol, by specifying a symbol not in the \cdf{keyword}
package as the \emph{keyword}.
For example:
\begin{lisp}
(defun wager (\&key ((secret password) nil) amount) \\*
~~(format nil "You {\Xtilde}A \${\Xtilde}D" \\*
~~~~~~~~~~(if (eq password 'joe-sent-me) "win" "lose") \\*
~~~~~~~~~~amount)) \\
\\
(wager :amount 100) \EV\ "You lose \$100" \\*
(wager :amount 100 'secret 'joe-sent-me) \EV\ "You win \$100"
\end{lisp}
The \cdf{secret} word could be made even more secret in this example
by placing it in some other \cdf{obscure} package, so that one would
have to write
\begin{lisp}
(wager :amount 100 'obscure:secret 'joe-sent-me) \EV\ "You win \$100"
\end{lisp}
to win anything.

In each keyword parameter specifier must be a name \emph{var} for the
parameter variable.  If an explicit \emph{keyword} is
specified, then that is the keyword name for the parameter.  Otherwise
the name \emph{var} serves to indicate the keyword name,
in that a keyword with the same name (in the \cdf{keyword} package) is used
as the keyword.  Thus
\begin{lisp}
(defun foo (\cd{\&key} radix (type 'integer)) ...)
\end{lisp}
means exactly the same as
\begin{lisp}
(defun foo (\cd{\&key} ((:radix radix)) ((:type type) 'integer)) ...)
\end{lisp}

The keyword parameter specifiers are, like all parameter specifiers,
effectively processed from left to right.
For each keyword parameter specifier, if there is an argument
pair whose keyword name matches that specifier's keyword name
(that is, the names are \cdf{eq}),
then the parameter variable for that specifier is bound to the
second item (the value) of that argument pair.
If more than one such argument pair matches, it is not an error;
the leftmost argument pair is used.
If no such argument pair exists, then
the \emph{initform} for that specifier is evaluated
and the parameter variable is bound to that value (or to {\false} if
no \emph{initform} was specified).  The variable \emph{svar} is treated
as for ordinary \emph{optional} parameters: it is bound to \emph{true}
if there was a matching argument pair, and to \emph{false} otherwise.

It is an error if an argument pair has a keyword name not matched
by any parameter specifier, unless at least one of the following
two conditions is met:

\begin{itemize}
\item
\cd{\&allow-other-keys} was specified in the lambda-list.

\item
Somewhere among the keyword argument pairs is a pair whose keyword
is \cd{:allow-other-keys} and whose value is not {\false}.
\end{itemize}
If either condition obtains, then it is not an error
for an argument pair to match no parameter specified,
and the argument pair is simply ignored (but such an
argument pair is accessible through the \cd{\&rest} parameter if
one was specified). The purpose of these mechanisms is to
allow sharing of argument lists among several functions
and to allow either the caller or the called function
to specify that such sharing may be taking place.

After all parameter specifiers have been processed, the auxiliary
variable specifiers (those following the lambda-list keyword \cd{\&aux}) are processed from
left to right.  For each one, the \emph{initform} is evaluated and the
variable \emph{var} bound to that value (or to {\false} if no \emph{initform} was
specified).  Nothing can be done with \cd{\&aux} variables that cannot be
done with the special operator \cdf{let*}:
\begin{lisp}
(lambda (x y \&aux (a (car x)) (b 2) c) ...) \\
~~~\EQ\ (lambda (x y) (let* ((a (car x)) (b 2) c) ...))
\end{lisp}

Which to use is purely a matter of style.

Whenever any \emph{initform} is evaluated for any parameter
specifier, that form may refer to any parameter variable to the left of
the specifier in which the \emph{initform} appears, including any supplied-p
variables, and may rely on the fact that no other parameter variable
has yet been bound (including its own parameter variable).

Once the lambda-list has been processed, the forms in the body of the
lambda-expression are executed.  These forms may refer to the arguments
to the function by using the names of the parameters.  On exit from the
function, either by a normal return of the function's value(s) or by a
non-local exit, the parameter bindings, whether lexical or special, are
no longer in effect.  (The bindings are not necessarily permanently discarded,
for a lexical binding can later be reinstated if a
``closure'' over that binding was created,
perhaps by using \cdf{function}, and saved before the exit occurred.)

\noindent
Examples of \cd{\&optional} and \cd{\&rest} parameters:
\begin{lisp}
((lambda (a b) (+ a (* b 3))) 4 5) \EV\ 19 \\
((lambda (a \cd{\&optional} (b 2)) (+ a (* b 3))) 4 5) \EV\ 19 \\
((lambda (a \cd{\&optional} (b 2)) (+ a (* b 3))) 4) \EV\ 10 \\
((lambda (\cd{\&optional} (a 2 b) (c 3 d) \cd{\&rest} x) (list a b c d x))) \\*
~~~\EV\ (2 {\false} 3 {\false} {\false}) \\
((lambda (\cd{\&optional} (a 2 b) (c 3 d) \cd{\&rest} x) (list a b c d x)) \\*
~6) \\*
~~~\EV\ (6 t 3 {\false} {\false}) \\
((lambda (\cd{\&optional} (a 2 b) (c 3 d) \cd{\&rest} x) (list a b c d x)) \\*
~6 3) \\*
~~~\EV\ (6 t 3 t {\false}) \\
((lambda (\cd{\&optional} (a 2 b) (c 3 d) \cd{\&rest} x) (list a b c d x)) \\*
~6 3 8) \\*
~~~\EV\ (6 t 3 t (8)) \\
((lambda (\cd{\&optional} (a 2 b) (c 3 d) \cd{\&rest} x) (list a b c d x)) \\*
~6 3 8 9 10 11) \\*
~~~\EV\ (6 t 3 t (8 9 10 11))
\end{lisp}
Examples of \cd{\&key} parameters:
\begin{lisp}
((lambda (a b \cd{\&key} c d) (list a b c d)) 1 2) \\*
~~~\EV\ (1 2 {\nil} {\nil}) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) 1 2 :c 6) \\*
~~~\EV\ (1 2 6 {\nil}) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) 1 2 :d 8) \\*
~~~\EV\ (1 2 {\nil} 8) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) 1 2 :c 6 :d 8) \\*
~~~\EV\ (1 2 6 8) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) 1 2 :d 8 :c 6) \\*
~~~\EV\ (1 2 6 8) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) :a 1 :d 8 :c 6) \\*
~~~\EV\ (:a 1 6 8) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) :a :b :c :d) \\
~~~\EV\ (:a :b :d {\nil})
\end{lisp}
Examples of mixtures:
\begin{lisp}
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~1)   \EV\ (1 3 {\nil} 1 ())
\end{lisp}

\begin{lisp}
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~1 2)   \EV\ (1 2 {\nil} 1 ()) \\
 \\
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~:c 7)   \EV\ (:c 7 {\nil} :c ()) \\
 \\
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~1 6 :c 7)   \EV\ (1 6 7 1 (:c 7)) \\
 \\
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~1 6 :d 8)   \EV\ (1 6 {\nil} 8 (:d 8)) \\
 \\
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~1 6 :d 8 :c 9 :d 10)   \EV\ (1 6 9 8 (:d 8 :c 9 :d 10))
\end{lisp}

All lambda-list keywords are permitted, but not terribly useful, in
lambda-expressions appearing explicitly as the first element of a
function-call form.  They are extremely
useful, however, in functions given global names by \cdf{defun}.

All symbols whose names begin with \cd{\&} are conventionally reserved
for use as lambda-list keywords and should not be used as variable names.
Implementations of Common Lisp are free to provide additional lambda-list
keywords.

\begin{defun}[Constant]
lambda-list-keywords

The value of \cdf{lambda-list-keywords} is a list of all the lambda-list
keywords used in the implementation, including the additional ones
used only by \cdf{defmacro}.  This list must contain at least the symbols
\cd{\&optional}, \cd{\&rest}, \cd{\&key}, \cd{\&allow-other-keys}, \cd{\&aux}, \cd{\&body}, \cd{\&whole},
and \cd{\&environment}.
\end{defun}

As an example of the use of \cd{\&allow-other-keys} and \cd{:allow-other-keys},
consider a function that takes two keyword arguments of its own and also
accepts additional keyword arguments to be passed to \cdf{make-array}:
\begin{lisp}
(defun array-of-strings (str dims \cd{\&rest} keyword-pairs \\*
~~~~~~~~~~~~~~~~~~~~~~~~~\cd{\&key} (start 0) end \cd{\&allow-other-keys}) \\*
~~(apply \#'make-array dims \\*
~~~~~~~~~:initial-element (subseq str start end) \\
~~~~~~~~~:allow-other-keys t \\*
~~~~~~~~~keyword-pairs))
\end{lisp}

This function takes a string and dimensioning information and returns
an array of the specified dimensions, each of whose elements is the
specified string.  However, \cd{:start} and \cd{:end} keyword arguments
may be used in the usual manner (see chapter~\ref{KSEQUE}) to specify
that a substring of the given string should be used.  In addition,
the presence of \cd{\&allow-other-keys} in the lambda-list indicates that the caller
may specify additional keyword arguments; the \cd{\&rest} argument provides
access to them.  These additional keyword arguments are fed to \cdf{make-array}.
Now, \cdf{make-array} normally does not allow the keywords \cd{:start}
and \cd{:end} to be used, and it would be an error to specify such
keyword arguments to \cdf{make-array}.  However, the presence in the
call to \cdf{make-array} of the keyword argument \cd{:allow-other-keys}
with a non-{\false} value causes any extraneous keyword arguments,
including \cd{:start} and \cd{:end}, to be acceptable and ignored.

\begin{defun}[Constant]
lambda-parameters-limit

The value of \cdf{lambda-parameters-limit} is a positive integer that is
the upper exclusive bound on the number of distinct parameter names
that may appear in a single lambda-list.
This bound depends on the implementation
but will not be smaller than 50.
Implementors are encouraged to make this limit as large as practicable
without sacrificing performance.
See \cdf{call-arguments-limit}.
\end{defun}

\section{Top-Level Forms}

The standard way for the user to interact with a Common Lisp implementation is
via a \emph{read-eval-print loop}: the system repeatedly
reads a form from some input source (such as a keyboard or a disk file),
evaluates it, and then prints the value(s) to some output sink (such as a
display screen or another disk file).  Any form (evaluable
data object) is acceptable; however, certain special operators are specifically
designed to be convenient for use as \emph{top-level} forms,
rather than as forms embedded within other forms in the way
that \cd{(+ 3 4)}
is embedded within \cd{(if p (+ 3 4) 6)}.
These top-level special operators may be used to define globally named
functions, to define macros, to make declarations,
and to define global values for special variables.

While defining forms normally appear at top level,
it is meaningful to place them in non-top-level contexts.
All defining forms that create functional objects from code appearing
as argument forms must ensure that
such argument forms refer to the enclosing lexical environment.
Compilers must handle defining forms properly in all situations,
not just top-level contexts.  However, certain
compile-time side effects of these defining forms are performed only
when the defining forms occur at top level (see section~\ref{COMPILER-SECTION}).

Macros are usually defined by using the special operator \cdf{defmacro}.
This facility is fairly complicated; it is described in chapter~\ref{MACROS}.

\subsection{Defining Named Functions}

The \cdf{defun} special operator is the usual means of defining named functions.

\begin{defmac}
defun name lambda-list <{declaration}* | doc-string> {form}*

Evaluating a \cdf{defun} form causes the symbol \emph{name} to be a global name
for the function specified by the lambda-expression
\begin{lisp}
(lambda \emph{lambda-list} \Mstar{\emph{declaration} {\Mor} \emph{doc-string}} \Mstar{\emph{form}})
\end{lisp}
defined in the lexical environment in which the \cdf{defun} form was
executed.  Because \cdf{defun} forms normally appear at top level, this is
normally the null lexical environment.

While defining forms normally appear at top level,
it is meaningful to place them in non-top-level contexts;
\cdf{defun} must define the function
within the enclosing lexical environment, not within the null lexical
environment.

\cdf{defun}
can accept any function-name (a symbol or a list
whose \emph{car} is \cdf{setf}---see section~\ref{FUNCTION-NAME-SECTION})
as a \emph{name}.
Thus one may write
\begin{lisp}
(defun (setf cadr) ...)
\end{lisp}
to define a \cdf{setf}
expansion function for \cdf{cadr} 
(although it may be much more convenient to
use \cdf{defsetf} or \cdf{define-modify-macro}).

If the optional documentation string \emph{doc-string} is present,
then it is attached to the \emph{name}
as a documentation string of type \cdf{function}; see \cdf{documentation}.
If \emph{doc-string} is not
followed by a declaration, it may be
present only if at least one \emph{form} is also specified, as it is
otherwise taken to be a \emph{form}.
It is an error if more than one \emph{doc-string} is present.

The \emph{forms} constitute the body of the defined function; they are
executed as an implicit \cdf{progn}.

The body of the defined function is implicitly enclosed
in a \cdf{block} construct whose name is the same as the \emph{name}
of the function.  Therefore \cdf{return-from}
may be used to exit from the function.

Other implementation-dependent bookkeeping actions may be taken as well
by \cdf{defun}.  The \emph{name} is returned as the value of the \cdf{defun}
form.
For example:
\begin{lisp}
(defun discriminant (a b c) \\
~~(declare (number a b c)) \\
~~"Compute the discriminant for a quadratic equation. \\
~~~Given a, b, and c, the value b{\Xcircumflex}2-4*a*c is calculated. \\
~~~If the coefficients a, b, and c are all real (that is, \\
~~~not complex), then the quadratic equation a*x{\Xcircumflex}2+b*x+c=0 \\
~~~has real, multiple, or complex roots depending on \\
~~~whether this calculated value is positive, zero, or \\
~~~negative, respectively."
~~(- (* b b) (* 4 a c))) \\
~~~\EV\ discriminant \\
~~~\textrm{and now} (discriminant 1 2/3 -2) \EV\ 76/9
\end{lisp}

It is permissible to use \cdf{defun} to redefine a function,
to install a corrected version of an incorrect definition, for example.
It is permissible to redefine a macro as a function.
It is an error to attempt to redefine the name of a special
form (see table~\ref{SPECIAL-FORM-TABLE}) as a function.
\end{defmac}

\subsection{Declaring Global Variables and Named Constants}

The \cdf{defvar} and \cdf{defparameter} special operators are
the usual means of specifying globally defined variables.
The \cdf{defconstant} special operator is used for defining named constants.

\begin{defmac}
defvar name [initial-value [documentation]] \\
defparameter name initial-value [documentation] \\
defconstant name initial-value [documentation]

\cdf{defvar} is the recommended way to declare the use
of a special variable in a program.
\begin{lisp}
(defvar \emph{variable})
\end{lisp}
proclaims \emph{variable} to be \cdf{special} (see \cdf{proclaim}),
and may perform other system-dependent bookkeeping actions.

If no \emph{initial-value} form is provided, \cdf{defvar}
does not change the value of the \emph{variable};
if no \emph{initial-value} form is provided and the variable
has no value, \cdf{defvar} does not give it a value.

If a second argument form is supplied,
\begin{lisp}
(defvar \emph{variable} \emph{initial-value})
\end{lisp}
then \emph{variable} is initialized to the result of evaluating the form
\emph{initial-value} unless it already has a value.  The \emph{initial-value} form
is not evaluated unless it is used; this fact is useful if
evaluation of the \emph{initial-value} form does something
expensive like creating a large data structure.

\begin{newer}
X3J13 voted in June 1987 \issue{DEFVAR-INIT-TIME} to clarify that
evaluation of the \emph{initial-value} and the initialization of the
variable occur, if at all, at the time the \cdf{defvar} form is executed,
and that the \emph{initial-value} form is evaluated
if and only if the \emph{variable} does not already have a value.
\end{newer}
The initialization is
performed by assignment and thus assigns a global value to the variable
unless there are currently special bindings of that variable.
Normally there should not be any such special bindings.

\cdf{defvar} also provides a good place to put a comment describing the
meaning of the variable, whereas an ordinary \cdf{special} proclamation
offers the
temptation to declare several variables at once and not have room to
describe them all.
\begin{lisp}
(defvar *visible-windows* 0 \\
~~"Number of windows at least partially visible on the screen")
\end{lisp}

\cdf{defparameter} is similar to \cdf{defvar}, but \cdf{defparameter} requires
an \emph{initial-value} form, always evaluates the form, and assigns the
result to the variable.  The semantic distinction is that \cdf{defvar}
is intended to declare a variable changed by the program, whereas
\cdf{defparameter} is intended to declare a variable that is normally
constant but can be changed (possibly at run time), where such a change
is considered a
change \emph{to} the program.  \cdf{defparameter} therefore does not indicate
that the quantity \emph{never} changes; in particular, it does not license
the compiler to build assumptions about the value into programs being
compiled.

\cdf{defconstant} is like \cdf{defparameter} but \emph{does} assert that
the value of the variable \emph{name} is fixed and does license
the compiler to build assumptions about the value into programs being
compiled.  (However, if the compiler chooses to replace references
to the name of the constant by the value of the constant in code
to be compiled, perhaps in order to allow further optimization,
the compiler must take care that such ``copies'' appear to be \cdf{eql}
to the object that is the actual value of the constant.  For example,
the compiler may freely make copies of numbers but must exercise
care when the value is a list.)

It is an error if there are any special bindings
of the variable at the time the \cdf{defconstant} form
is executed (but implementations may or may not check for this).

Once a name has been declared by \cdf{defconstant} to be constant,
any further assignment to or binding of that special variable is an error.
This is the case for such system-supplied constants as \cdf{t} and
\cdf{most-positive-fixnum}.
A compiler may also choose to issue warnings about bindings of
the lexical variable of the same name.

\begin{new}
X3J13 voted in January 1989
\issue{DEFCONSTANT-SPECIAL}
to clarify the preceding paragraph by specifying
that it is an error to rebind constant symbols
as either lexical or special variables.
Consequently, a valid reference to a symbol declared with \cdf{defconstant}
always refers to its global value.
(Unfortunately, this violates the principle of referential transparency,
for one cannot always choose names for lexical variables without regard
to surrounding context.)
\end{new}

For any of these constructs,
the documentation should be a string.  The string is attached
to the name of the variable, parameter, or constant
under the \cdf{variable} documentation type; see the \cdf{documentation}
function.

The \emph{documentation-string}
is not evaluated but must appear as a literal string when the \cdf{defvar},
\cdf{defparameter}, or \cdf{defconstant} form is evaluated.

For example,
the form
\begin{lisp}
(defvar *avoid-registers* nil "Compilation control switch \#43")
\end{lisp}
is legitimate, but
\begin{lisp}
(defvar *avoid-registers* nil \\*
~~(format nil "Compilation control switch \#{\Xtilde}D" \\*
~~~~~~~~~~(incf *compiler-switch-number*)))
\end{lisp}
is erroneous because the call to \cdf{format} is not a literal string.

(On the other hand, the form
\begin{lisp}
(defvar *avoid-registers* nil \\*
~~\#.(format nil "Compilation control switch \#{\Xtilde}D" \\*
~~~~~~~~~~~~(incf *compiler-switch-number*)))
\end{lisp}
might be used to accomplish the same purpose, because the call to
\cdf{format} is evaluated at \cdf{read} time; when the \cdf{defvar} form
is evaluated, only the result of the call to \cdf{format}, a string,
appears in the \cdf{defvar} form.)

These constructs are normally used only as top-level forms.  The
value returned by each of these constructs is the \emph{name} declared.
\end{defmac}

\subsection{Control of Time of Evaluation}

\begin{defspec}
eval-when ({situation}*) {form}*

  The body of an \cdf{eval-when} form is processed as an implicit \cdf{progn}, but
  only in the situations listed.  Each \emph{situation} must be a symbol,
  either \cd{:compile-toplevel},
  \cd{:load-toplevel}, or \cd{:execute}.

  The use of \cd{:compile-toplevel} and \cd{:load-toplevel}
  controls whether and when processing
  occurs for top-level forms. The use of \cd{:execute} controls whether
  processing occurs for non-top-level forms.

  The \cdf{eval-when} construct may be more precisely understood in terms of
  a model of how the file compiler, \cdf{compile-file}, processes forms in a
  file to be compiled.

  Successive forms are read from the file by the file compiler using 
  \cdf{read}. These top-level forms are normally processed in what we call
  ``not-compile-time'' mode. There is one other mode, called 
  ``compile-time-too'' mode, which can come into play for top-level
  forms. The \cdf{eval-when} special operator is used to annotate a program
  in a way that allows the program doing the processing to select
  the appropriate mode.

  Processing of top-level forms in the file compiler works as follows:

\begin{itemize}
   \item If the form is a macro call, it is expanded and the result is
     processed as a top-level form in the same processing mode
     (compile-time-too or not-compile-time).

   \item If the form is a \cdf{progn} (or \cdf{locally} \issue{LOCALLY-TOP-LEVEL})
     form, each of its body forms is
     sequentially processed as top-level forms in the same processing
     mode.

   \item If the form is a \cdf{compiler-let}, \cdf{macrolet},
     or \cdf{symbol-macrolet},
     the file compiler makes the appropriate bindings and recursively
     processes the body forms as an implicit top-level \cdf{progn} with those 
     bindings in effect, in the same processing mode.

   \item If the form is an \cdf{eval-when} form, it is handled according to
     the following table:
     \begin{flushleft}
     \begin{tabular*}{\linewidth}{@{\extracolsep{\fill}}c@{}cccl@{}}
     LT&CT&EX&CTTM&Action \\ \hlinesp
       yes & yes &--   & --  &    process body in compile-time-too mode \\
       yes & no  &yes  & yes &    process body in compile-time-too mode \\
       yes & no  &--   & no  &    process body in not-compile-time mode \\
       yes & no  &no   & --  &    process body in not-compile-time mode \\
       no  & yes &--   & --  &    evaluate body \\
       no  & no  &yes  & yes &    evaluate body \\
       no  & no  &--   & no  &    do nothing \\
       no  & no  &no   & --  &    do nothing \\
       \hline
     \end{tabular*}
     \end{flushleft}
     In the preceding table the column LT asks whether \cd{:load-toplevel}
     is one of the situations specified in the \cdf{eval-when} form;
     CT similarly refers to \cd{:compile-toplevel} and EX to \cd{:execute}.
     The column CTTM asks whether the \cdf{eval-when} form was encountered
     while in compile-time-too mode.  The phrase
     ``process body'' means to process the body as an implicit top-level
     \cdf{progn} in the indicated mode, and  ``evaluate body'' means to
     evaluate the body forms sequentially as an
     implicit \cdf{progn} in the dynamic execution context of the compiler and
     in the lexical environment in which the \cdf{eval-when} appears.

   \item Otherwise, the form is a top-level form that is not one of the
     special cases.  If in compile-time-too mode, the compiler first
     evaluates the form and then performs normal compiler processing
     on it.  If in not-compile-time mode, only normal compiler
     processing is performed (see section~\ref{COMPILER-SECTION}).
     Any subforms are treated as non-top-level forms.
\end{itemize}

  Note that top-level forms are guaranteed to be processed in the order
  in which they textually appear in the file, and that each top-level
  form read by the compiler is processed before the next is read.
  However, the order of processing (including, in particular, macro
  expansion) of subforms that are not top-level forms is unspecified.

  For an \cdf{eval-when} form that is not a top-level form in the file compiler
  (that is, either in the interpreter, in \cdf{compile}, or in the file
  compiler but not at top level), if the \cd{:execute} situation is specified,
  its body is treated as an implicit \cdf{progn}.  Otherwise, the body
  is ignored and the \cdf{eval-when} form has the value \cdf{nil}.

  For the sake of backward compatibility,
  a \emph{situation} may also be \cdf{compile}, \cdf{load}, or \cdf{eval}.
  Within a top-level \cdf{eval-when} form
  these have the same meaning as \cd{:compile-toplevel}, \cd{:load-toplevel},
  and \cd{:execute}, respectively; but their effect is undefined when used
  in an \cdf{eval-when} form that is not at top level.

  The following effects are logical consequences of the preceding specification:

  \begin{itemize}
   \item It is never the case that the execution of a single \cdf{eval-when}
     expression will execute the body code more than once.

   \item The old keyword \cdf{eval} was a misnomer because execution of
     the body need not be done by \cdf{eval}.  For example, when the
     function definition
     \begin{lisp}
     (defun foo () (eval-when (:execute) (print 'foo)))
     \end{lisp}
     is compiled
     the call to \cdf{print} should be compiled, not evaluated at compile time.

   \item Macros intended for use in top-level forms should arrange for all
     side-effects to be done by the forms in the macro expansion.
     The macro-expander itself should not perform the side-effects.

\begin{lisp}
(defmacro foo () \\*
~~(really-foo)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;{\rm Wrong}\\*
~~{\Xbq}(really-foo)) \\
\\
(defmacro foo () \\*
~~{\Xbq}(eval-when (:compile-toplevel \\*
~~~~~~~~~~~~~~~:load-toplevel :execute)~~~~~;{\rm Right} \\*
~~~~(really-foo)))
\end{lisp}

     Adherence to this convention will mean that such macros will behave
     intuitively when called in non-top-level positions.   

   \item Placing a variable binding around an \cdf{eval-when}
     reliably captures the
     binding because the ``compile-time-too'' mode cannot occur (because 
     the \cdf{eval-when} could not be a top-level form).
     For example,
\begin{lisp}
(let ((x 3)) \\*
~~(eval-when (:compile-toplevel :load-toplevel :execute) \\*
~~~~(print x)))
\end{lisp}
will print 3 at execution (that is, load) time
     and will not print anything at
     compile time.  This is important so that expansions of \cdf{defun} and 
     \cdf{defmacro} can be done in terms of \cdf{eval-when}
     and can correctly capture the lexical environment.
     For example, an implementation might expand a \cdf{defun} form such as
\begin{lisp}
(defun bar (x) (defun foo () (+ x 3)))
\end{lisp}
into
\begin{lisp}
(progn (eval-when (:compile-toplevel) \\*
~~~~~~~~~(compiler::notice-function 'bar '(x))) \\*
~~~~~~~(eval-when (:load-toplevel :execute) \\*
~~~~~~~~~(setf (symbol-function 'bar) \\*
~~~~~~~~~~~~~~~\#'(lambda (x) \\*
~~~~~~~~~~~~~~~~~~~(progn (eval-when (:compile-toplevel)  \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~(compiler::notice-function 'foo \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'())) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~(eval-when (:load-toplevel :execute) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~(setf (symbol-function 'foo) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\#'(lambda () (+ x 3)))))))))
\end{lisp}
     which by the preceding rules would be treated the same as
\begin{lisp}
(progn (eval-when (:compile-toplevel) \\*
~~~~~~~~~(compiler::notice-function 'bar '(x))) \\*
~~~~~~~(eval-when (:load-toplevel :execute) \\*
~~~~~~~~~(setf (symbol-function 'bar) \\*
~~~~~~~~~~~~~~~\#'(lambda (x) \\*
~~~~~~~~~~~~~~~~~~~(progn (eval-when (:load-toplevel :execute) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~(setf (symbol-function 'foo) \\*
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\#'(lambda () (+ x 3)))))))))
\end{lisp}

\end{itemize}

Here are some additional examples.
\begin{lisp} 
(let ((x 1)) \\*
~~(eval-when (:execute :load-toplevel :compile-toplevel) \\*
~~~~(setf (symbol-function 'foo1) \#'(lambda () x))))
\end{lisp}
 The \cdf{eval-when} in the preceding expression is not at top level,
       so only the \cd{:execute}
       keyword is considered.  At compile time, this has no effect.
       At load time (if the \cdf{let} is at top level), or at execution time
       (if the \cdf{let} is embedded in some other form which does not execute
       until later), this sets \cd{(symbol-function 'foo1)} to a function that
       returns \cd{1}.
\begin{lisp}
(eval-when (:execute :load-toplevel :compile-toplevel) \\*
~~(let ((x 2)) \\*
~~~~(eval-when (:execute :load-toplevel :compile-toplevel) \\*
~~~~~~(setf (symbol-function 'foo2) \#'(lambda () x)))))
\end{lisp}

 If the preceding expression occurs at the top level of a file to be compiled,
       it has \emph{both} a compile time \emph{and} a load-time effect of setting
       \cd{(symbol-function 'foo2)} to a function that returns \cd{2}.
\begin{lisp}
(eval-when (:execute :load-toplevel :compile-toplevel) \\*
~~(setf (symbol-function 'foo3) \#'(lambda () 3)))
\end{lisp}
 If the preceding expression occurs at the top level of a file to be compiled,
       it has \emph{both} a compile time \emph{and}
       a load-time effect of setting the
       function cell of \cd{foo3} to a function that returns \cd{3}.
\begin{lisp}
(eval-when (:compile-toplevel) \\*
~~(eval-when (:compile-toplevel)  \\*
~~~~(print 'foo4)))
\end{lisp}
  The preceding expression always does nothing; it simply returns \cdf{nil}.

\begin{lisp}
(eval-when (:compile-toplevel)  \\*
~~(eval-when (:execute) \\*
~~~~(print 'foo5)))
\end{lisp}
  If the preceding form occurs at the top level of a file to be compiled,
       \cd{foo5} is
       printed at compile time. If this form occurs in a non-top-level
       position, nothing is printed at compile time. Regardless of context,
       nothing is ever printed at load time or execution time.

\begin{lisp}
(eval-when (:execute :load-toplevel) \\*
~~(eval-when (:compile-toplevel) \\*
~~~~(print 'foo6)))
\end{lisp}

    If the preceding form occurs at the top level of a file to be compiled,
       \cd{foo6} is
       printed at compile time.  If this form occurs in a non-top-level
       position, nothing is printed at compile time. Regardless of context,
       nothing is ever printed at load time or execution time.
\end{defspec}

%RUSSIAN
\else

\chapter{ }
\label{PROGS}

 ~\ref{DTYPES}      Common Lisp' .
    Common Lisp'      ,  
   .

Lisp'      .  \emph{}
(  )     
.        . 
  \emph{}   . 
      ,  ,  
    .

  ,      .  , 
  <<  (top level)>>.     
 \cdf{defun},   ---    (
  ).

\section{}

     Common Lisp' 
\emph{},    ,   
      \emph{} ( 
  ).     \emph{}
 ,       . ,    
 ,     .   :
\cd{3},   \cd{3},  \cd{(+ 3 4)},   \cd{7}.
      \cd{3} \EV\ \cd{3}  \cd{(+ 3 4)} \EV\
\cd{7}. (\EV\  << >>)

       :
 ,   ,
,    ,
 .          :
 , 
 ,
 .

    Common Lisp,     
( \cdf{defstruct} ,    \cd{:type}) 
. 

\subsection{ }

 ,  ,     
\emph{} .
   ,   (     
   )     
.   {\emptylist},     
({\false}),    :  {\false} 
{\false}.
  ( :       
,  Common Lisp'   )     :
 \cd{:start}  \cd{:start}.

   ,  
        \cdf{quote},
 .

\subsection{}

 Common Lisp       .
    ,     
 ,    . ,  
\cd{(setq items 3)},    \cd{3}  
 \cdf{items},  \cdf{items}   \cd{3} (\cdf{items} \EV\
\cd{3}).
   \emph{}   \cdf{setq}  \emph{} 
 \cdf{let}.
  ,   ,  
 ,   ,     
  .

 Common Lisp'    .   \cd{} (
\emph{})  \emph{} ( \emph{}).
             
 .        ,
   .     ,  
    ,   \emph{} 
   ,     , 
  ,       ,   
  .

         
 .      
\emph{}   ,   . 
 ()      
\emph{}       , 
 .     
        
 (    ,    ,
     ).  , 
       
 (    ).
     ~\ref{SCOPE}.

  , ,   
,  \emph{}  () .
         ,
        .

      ,   ,
,   \emph{}. 
 ,     ,  
   ,        
,         Lisp .
 ,       
       \cdf{makunbound}.  
    <<>>,    ,
  ,  ,    FIXME.   
  .

        
     (  \cdf{safety}
 \cdf{optimize}).      
.
 ,       
 .
(<< >>       
\cdf{function},   \cdf{f}   \cd{(function~f)}    
,   \cdf{f}   \cd{(f~x~y)}.)

  \cdf{inline}  (    ),
      ,  
    \cdf{fboundp}   .  ,
  \cdf{fmakunbound}   \cdf{inline}   .


     \cdf{unbound-variable}, 
 \cdf{name}  \cdf{unbound-variable}   
,  .

     \cdf{unbound-function}, 
 \cdf{name}  \cdf{unbound-function}   
,  .

  \cdf{unbound-slot},    \cdf{cell-error},
   \cdf{instance},    
 \cd{:instance}   \cdf{make-condition}.
 \cdf{unbound-slot-instance}     .

 , -     
\cdf{slot-unbound} CLOS,  \cdf{unbound-slot}.
 \cdf{instance}  \cdf{unbound-slot}  
     \cdf{name}   
.

      <<
>>.
          .
  {\true}  {\false} .
    .     
   .     
\cdf{defconstant}       
   (       
\cdf{defconstant}).        
,       .

\subsection{ }

     ,    
  .        ,
  ~\ref{SPECIAL-FORM-TABLE},   
\emph{ }. (  <<>>  
       << >>.)

       .
      . ,
  \cdf{if}:
\cd{(if p (+ x 4) 5)}  Common Lisp'   ,  
<<\textbf{if} \emph{p} \textbf{then} \emph{x}+4 \textbf{else} 5>>  
Algol'.

        , 
     ;  \cdf{return-from},
\cdf{go}  \cdf{throw}.

    Common Lisp' . 
   .   
       .

    Common Lisp'   ,  
 ,  ,     
   .      
  ,     ,    
   . (  ,  , 
, ,       . 
    ,     , 
\cdf{typecase}  \cdf{multiple-value-bind}   -  
.)

\begin{table}[t]
\caption{   }
\label{SPECIAL-FORM-TABLE}
\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}lll@{}}
\cdf{block}&\cdf{if}&\cdf{progv} \\
\cdf{catch}&\cdf{labels}&\cdf{quote} \\
&\cdf{let}&\cdf{return-from} \\
\cdf{declare}&\cdf{let*}&\cdf{setq} \\
\cdf{eval-when}&\cdf{macrolet}&\cdf{tagbody} \\
\cdf{flet}&\cdf{multiple-value-call}&\cdf{the} \\
\cdf{function}&\cdf{multiple-value-prog1}&\cdf{throw} \\
\cdf{go}&\cdf{progn}&\cdf{unwind-protect} \\
& &\cdf{symbol-macrolet} \\
&\cdf{locally}&\cdf{load-time-value}
\end{tabular*}
\vskip 4pt
\end{table}

       ,   
 .  ,      
  ,    ,  ,   
   .
    ,   \cdf{macro-function} 
\cdf{special-operator-p}    ,      .
,        
        :

\begin{enumerate}
\item
        ,    
    .  ,  
  ~\ref{SPECIAL-FORM-TABLE}     .

\item
    ,     \cdf{macro-function}  
  ,   \cdf{macroexpand}  \cdf{macroexpand-1}  
  ,    .

\item
    ,      .
\end{enumerate}

\subsection{}

         
,     \emph{}.  ,  
 \emph{    (macrocall)}. 
 ,      .  
   ,   ,   . (
   \emph{ }.)
,    \cdf{return}  ,  : \cd{(return x)},
      : \cd{(return-from {\nil} x)}. 
:     .      
 .     ,  
 .

,         , 
        ,
 <<\cd{.~\emph{var}}>>  <<\cd{\&rest~\emph{var}}>>.
     ,   
     .

 Common Lisp'     , 
      \cdf{defmacro}.

,   Common Lisp'   , 
  ,       .
   ,       .

\beforenoterule
\begin{implementation}
Implementors are encouraged to implement the macros
defined in this book, as far as is possible, in such a way that
the expansion will not contain any implementation-dependent
special operators, nor contain as forms data objects that
are not considered to be forms in Common Lisp.
The purpose of this restriction is to ensure that the expansion
can be processed by a program-analyzing program in an
implementation-independent manner.
There is no problem with a macro expansion containing
calls to implementation-dependent functions.
This restriction is not a requirement of Common Lisp; it is recognized
that certain complex macros may be able to expand into significantly
more efficient code in certain implementations
by using implementation-dependent special operators in the macro expansion.
\end{implementation}
\afternoterule

\subsection{ }

    ,      ,
    ,  ,  
 \emph{ }.     
.      .   
    \emph{}  
. 
   \emph{}  .   
 ,        ,
 \cdf{throw}.    0   , 
\cdf{values}. 
     ,    
  .

,   : \cd{(+ (* 4 5))}.
 \cdf{+}   ,      .
    \cd{3}  \cd{(* 4 5)}   . 
\cd{3}   \cd{3},   \cd{(* 4 5)}   
().    \cd{4}  \cd{5}    , 
     .   
 \cd{20}   .  \cd{3}  \cd{20} 
  ,     
\cd{23}.     \cd{(+3 (* 4 5)) \EV\ 23}.

         ,
          ,
  . ,     ,   
   ,  .

\section{}

         
.         . 
        
      .  
   \emph{-},   
    \cdf{lambda}. - \emph{} 
,      .    ,
       ,  
       ,    
     \cdf{function}.  , 
      - , 
\emph{} .        
,  \emph{ ,    (function
  objects)},    \cdf{functionp},  
      \cdf{apply}  \cdf{funcall}. 

\subsection{ }

     .
\emph{ }       
\emph{defun}.
\emph{ }        
\cdf{flet}  \cdf{labels}.
    ,      - 
  ,       .
         , 
         \cdf{flet} 
\cdf{labels},       ,    
  ,    .

\subsection{-}
\label{LAMBDA-EXPRESSIONS-SECTION}
\indexterm{lambda-expression}
\indexterm{lambda-list}
% \indexterm{{\&optional!}}
% \indexterm{{\&rest!}}
% \indexterm{{\&key!}}
% \indexterm{{\&allow-other-keys!}}
% \indexterm{{\&aux!}}

\label{lambda-expression}
\label{lambda-list}
\label{optional}
\label{rest}
\label{key}
\label{allow-other-keys}
\label{aux}

\emph{-}     :
\begin{lisp}
(lambda \emph{lambda-list} . \emph{body})
\end{lisp}
     \cdf{lambda}.    
.   \emph{-},    
\emph{} .  ,  -,
  ,     
-. \emph{body}      
 . \emph{body}      (
 ).    ,   
    \emph{}  (  
,  {\false}).
  -:

\begingroup
\def\GrossOptVars{\Mstar{\emph{var} {\Mor} \cd{(}\emph{var} \Mopt{\emph{initform} \Mopt{\emph{svar}}}\cd{)}}}
\def\GrossKeyOptVars{\Mstar{\emph{var} {\Mor} \cd{(}\Mgroup{\emph{var} {\Mor} \cd{(}\emph{keyword} \emph{var}\cd{)}} \Mopt{\emph{initform} \Mopt{\emph{svar}}}\cd{)}}}
\def\GrossAuxVars{\Mstar{\emph{var} {\Mor} \cd{(}\emph{var} \Mopt{\emph{initform}}\cd{)}}}
\begin{lisp}
(lambda (\Mstar{\emph{var}} \\*
~~~~~~~~~\Mopt{\cd{\&optional} \GrossOptVars} \\*
~~~~~~~~~\Mopt{\cd{\&rest} \emph{var}} \\*
~~~~~~~~~\Mopt{\cd{\&key} \GrossKeyOptVars 
~~~~~~~~~~~~~~\Mopt{\cd{\&allow-other-keys}}} \\*
~~~~~~~~~\Mopt{\cd{\&aux} \GrossAuxVars}) \\*
~~~\Mchoice{\Mstar{\emph{declaration}} {\Mor} \emph{documentation-string}} \\*
~~~\Mstar{\emph{form}})
\end{lisp}
\endgroup

  -     
\emph{  -}.   -
   \cd{\&}.
 ,    -   
   .     \cdf{keyword}.  
 ,    .  
,    .

\emph{Keyword}    -   ,  
    \cdf{keyword}, .  .

-   ,      :

\begin{itemize}
\item
  \emph{ }.    
      -.  
  ,    .

\item
  \emph{} .
    \cd{\&optional},     
\emph{}      ,  
 .

\item
  \emph{    (rest)}
.     \cd{\&rest},    
   \emph{ (rest)} ,   
     -  .

\item
  \emph{ (keyword)} .   
 \cd{\&key},      
       
\emph{} .    
    
\cd{\&allow-others-keys}.

\item
  \emph{ (aux)} .   
.     \cd{\&aux}, 
      .
\end{itemize}

 ,  -,   ,  
     .
  ,  -   
.        \emph{var}
.
  ,     ,  
,       .   ,
     ,    
  ,    ,   
.  \cdf{defvar}, \cdf{proclaim}, \cdf{declare}.

   ,   \emph{n}  
(\emph{n}   ),      \emph{n}
,       \emph{n} 
.

   ,       ,
  .     , 
  \cd{var}     . 
 ,     .    , 
  \emph{initform},  
     (  {\false},  
\emph{initform}   ).
        \emph{svar},  
  \emph{true},    ,   \emph{false}
    (     \emph{initform}).
 \emph{svar}  \emph{supplied-p} . 
   ,   ,     
     .

 ,   \emph{}   , 
  \emph{ (rest)} .
 \emph{ (rest)}  ,      
  .     ,
\emph{ (rest)}      .   
  \emph{ (rest)}   \emph{
  (keyword)} ,       (
 ).

\begin{new}
X3J13 voted in January 1989
\issue{REST-LIST-ALLOCATION}
to clarify that if a function has a \emph{rest} parameter
and is called using \cdf{apply}, then the list to which the
\emph{rest} parameter is bound is permitted, but not required,
to share top-level list structure with the list that was the last
argument to \cdf{apply}.  Programmers should be careful about performing
side effects on the top-level list structure of a \emph{rest} parameter.

This was the result of a rather long discussion within X3J13 and the
wider Lisp community.  To set it in its historical context, I must remark
that in Lisp Machine Lisp the list to which a \emph{rest} parameter was
bound had only dynamic extent; this in conjunction with the
technique of ``cdr-coding'' permitted a clever stack-allocation technique
with very low overhead.  However, the early designers of
Common Lisp, after a great deal of debate, concluded that it was dangerous
for cons cells to have dynamic extent; as an example, the ``obvious''
definition of the function \cdf{list}
\begin{lisp}
(defun list (\&rest x) x)
\end{lisp}
could fail catastrophically.  Therefore the first edition simply implied
that the list for a \emph{rest} parameter, like all other lists, would
have indefinite extent.  This still left open the flip side of the
question, namely, Is the list for a \emph{rest} parameter guaranteed fresh?
This is the question addressed by the X3J13 vote.
If it is always freshly consed, then it is permissible to destroy it,
for example by giving it to \cdf{nconc}.  However, the requirement always
to cons fresh lists could impose an unacceptable overhead in many implementations.
The clarification approved by X3J13 specifies that the programmer may
not rely on the list being fresh; if the function was called using \cdf{apply},
there is no way to know where the list came from.
\end{new}

   \emph{ (keyword)} .
      ,   
\emph{ (rest)} .
,    \cd{\&rest}  \cd{\&key}.   
     :
       \cd{\&rest}   
 ,  \cd{\&key} .     
       .
  \cd{\&key},     .  
 .        ,
   ,     
.

   -    ,   
    \cdf{keyword}.   \cd{\&key} 
       (  
  \emph{svar}),       :  
        ,  
.     : \cd{((\emph{keyword}
  \emph{var})~...)}          
\cdf{keyword}.
:
\begin{lisp}
(defun wager (\&key ((secret password) nil) amount) \\*
~~(format nil " {\Xtilde}A \${\Xtilde}D" \\*
~~~~~~~~~~(if (eq password 'joe-sent-me) "" "") \\*
~~~~~~~~~~amount)) \\
\\
(wager :amount 100) \EV\ "  \$100" \\*
(wager :amount 100 'secret 'joe-sent-me) \EV\ "  \$100"
\end{lisp}
    \cdf{secret}     , 
     \cdf{obscure}.     
  :
\begin{lisp}
(wager :amount 100 'obscure:secret 'joe-sent-me) \EV\ "  \$100"
\end{lisp}

        \emph{var} 
 . FIXME
    ,      
.       \cdf{var}  
   .  :
\begin{lisp}
(defun foo (\cd{\&key} radix (type 'integer)) ...)
\end{lisp}
  ,  
\begin{lisp}
(defun foo (\cd{\&key} ((:radix radix)) ((:type type) 'integer)) ...)
\end{lisp}

  (keyword) ,    
,   .
    ,    , 
       (  
 \cdf{eq}),       
.
        ,    . 
     .
    ,   \emph{initform} 
      (  {\false}, 
\emph{initform}  ).  \emph{svar}    
,    \emph{} .    
\emph{},     ,   ---  \emph{}.

     ,  
      ,   
    :
\begin{itemize}
\item
 -   \cd{\&allow-other-keys}.

\item
-     ,     
\cd{:allow-other-keys}     {\false}.
\end{itemize}

      ,   
,      (  
,   \cd{\&rest} ). 
      - 
       (keyword)
.        
         . 

      ,   
  .     
\emph{initform}   \emph{var}     (
 {\false},  \emph{initform}  ).  \cd{\&aux} 
   ,      \cdf{let*}:
\begin{lisp}
(lambda (x y \&aux (a (car x)) (b 2) c) ...) \\
~~~\EQ\ (lambda (x y) (let* ((a (car x)) (b 2) c) ...))
\end{lisp}

     .

 -  \emph{initform}   - 
,        , 
   ,  supplied-p ,    
,        (  
).

     -,    
-.       , 
 .    ,     , 
    ,  ,  , 
, .    <<>>  
,    ,   ,  
  . 

\noindent
  \cd{\&optional}  \cd{\&rest} :
\begin{lisp}
((lambda (a b) (+ a (* b 3))) 4 5) \EV\ 19 \\
((lambda (a \cd{\&optional} (b 2)) (+ a (* b 3))) 4 5) \EV\ 19 \\
((lambda (a \cd{\&optional} (b 2)) (+ a (* b 3))) 4) \EV\ 10 \\
((lambda (\cd{\&optional} (a 2 b) (c 3 d) \cd{\&rest} x) (list a b c d x))) \\*
~~~\EV\ (2 {\false} 3 {\false} {\false}) \\
((lambda (\cd{\&optional} (a 2 b) (c 3 d) \cd{\&rest} x) (list a b c d x)) \\*
~6) \\*
~~~\EV\ (6 t 3 {\false} {\false}) \\
((lambda (\cd{\&optional} (a 2 b) (c 3 d) \cd{\&rest} x) (list a b c d x)) \\*
~6 3) \\*
~~~\EV\ (6 t 3 t {\false}) \\
((lambda (\cd{\&optional} (a 2 b) (c 3 d) \cd{\&rest} x) (list a b c d x)) \\*
~6 3 8) \\*
~~~\EV\ (6 t 3 t (8)) \\
((lambda (\cd{\&optional} (a 2 b) (c 3 d) \cd{\&rest} x) (list a b c d x)) \\*
~6 3 8 9 10 11) \\*
~~~\EV\ (6 t 3 t (8 9 10 11))
\end{lisp}
 \cd{\&key} :
\begin{lisp}
((lambda (a b \cd{\&key} c d) (list a b c d)) 1 2) \\*
~~~\EV\ (1 2 {\nil} {\nil}) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) 1 2 :c 6) \\*
~~~\EV\ (1 2 6 {\nil}) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) 1 2 :d 8) \\*
~~~\EV\ (1 2 {\nil} 8) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) 1 2 :c 6 :d 8) \\*
~~~\EV\ (1 2 6 8) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) 1 2 :d 8 :c 6) \\*
~~~\EV\ (1 2 6 8) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) :a 1 :d 8 :c 6) \\*
~~~\EV\ (:a 1 6 8) \\
((lambda (a b \cd{\&key} c d) (list a b c d)) :a :b :c :d) \\
~~~\EV\ (:a :b :d {\nil})
\end{lisp}
  :
\begin{lisp}
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~1)   \EV\ (1 3 {\nil} 1 ())
\end{lisp}

\begin{lisp}
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~1 2)   \EV\ (1 2 {\nil} 1 ()) \\
 \\
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~:c 7)   \EV\ (:c 7 {\nil} :c ()) \\
 \\
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~1 6 :c 7)   \EV\ (1 6 7 1 (:c 7)) \\
 \\
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~1 6 :d 8)   \EV\ (1 6 {\nil} 8 (:d 8)) \\
 \\
((lambda (a \cd{\&optional} (b 3) \cd{\&rest} x \cd{\&key} c (d a)) \\*
~~~(list a b c d x)) \\*
~1 6 :d 8 :c 9 :d 10)   \EV\ (1 6 9 8 (:d 8 :c 9 :d 10))
\end{lisp}

 -,           ,
    -,     -  
 .
      ,   
\cdf{defun}.

 ,    \cd{\&}     
   -,      
.
 Common Lisp'      
 -.

\begin{defun}[]
lambda-list-keywords

 \cdf{lambda-list-keywords}     
-,    ,  , 
   \cdf{defmacro}.      
 \cd{\&optional}, \cd{\&rest}, \cd{\&key}, \cd{\&allow-other-keys},
\cd{\&aux}, \cd{\&body}, \cd{\&whole}  \cd{\&environment}.
\end{defun}

   \cd{\&allow-other-keys}  \cd{:allow-other-keys}, 
 ,       
   ,   
\cdf{make-array}:
\begin{lisp}
(defun array-of-strings (str dims \cd{\&rest} keyword-pairs \\*
~~~~~~~~~~~~~~~~~~~~~~~~~\cd{\&key} (start 0) end \cd{\&allow-other-keys}) \\*
~~(apply \#'make-array dims \\*
~~~~~~~~~:initial-element (subseq str start end) \\
~~~~~~~~~:allow-other-keys t \\*
~~~~~~~~~keyword-pairs))
\end{lisp}

           
 ,      
.   \cd{:start}  \cd{:end},   (
~\ref{KSEQUE}),     ,  
 .  ,  \cd{\&allow-other-keys} 
    ,      
  .      \cd{\&rest}
.      
\cdf{make-array}. \cdf{make-array}    
\cd{:start}  \cd{:end},       . 
 \cd{:allow-other-keys}  -{\false}   
   ,  \cd{:start}  \cd{:end},   
   .

\begin{defun}[]
lambda-parameters-limit

 \cdf{lambda-parameters-limit}   , 
       ,
    -.
   ,      50.
          
.
 \cdf{call-arguments-list}.
\end{defun}

\section{  }

     Common Lisp 
\emph{ --} (\emph{read-eval-print loop}): 
       (, ),
 ,   ()     (,
 ).    (  ), 
          
\emph{ }.
        
  (globally named functions), ,   
     .

While defining forms normally appear at top level,
it is meaningful to place them in non-top-level contexts.
All defining forms that create functional objects from code appearing
as argument forms must ensure that
such argument forms refer to the enclosing lexical environment.
Compilers must handle defining forms properly in all situations,
not just top-level contexts.  However, certain
compile-time side effects of these defining forms are performed only
when the defining forms occur at top level (see section~\ref{COMPILER-SECTION}).

       \cdf{defmacro}.
   .    ~\ref{MACROS}.

\subsection{ }

  \cdf{defun}    .

\begin{defmac}
defun name lambda-list
  <{declaration}* | doc-string>
  {form}*

  \cdf{defun}   ,   \emph{name}
      -.
\begin{lisp}
(lambda \emph{lambda-list} \Mstar{\emph{declaration} {\Mor} \emph{doc-string}} \Mstar{\emph{form}})
\end{lisp}
   ,    
\cdf{defun}.     \cdf{defun}     
, -      .

         ,  
    . \cdf{defun}   
 ,  ,  .

\cdf{defun}    \emph{name}     (
 ,   \emph{car}   \cdf{setf}---
~\ref{FUNCTION-NAME-SECTION}).
    \cdf{setf}-   \cdf{cadr}  
\begin{lisp}
(defun (setf cadr) ...)
\end{lisp}
 ,   \cdf{defsetf}  \cdf{define-modify-macro}.

     \emph{doc-string},  
   \emph{name}     
\cdf{function}.  \cdf{documentation}.   \emph{doc-string} 
,        
      ,     
  \emph{form} .     
\emph{doc-string}  .

 \emph{forms}    .   
 \cdf{progn}.

       \cdf{block}, 
   \emph{ (name)} .      
   \cdf{return-from}.

    \cdf{defun}     
 . \emph{name}      \cdf{defun}.
:
\begin{lisp}
(defun discriminant (a b c) \\
~~(declare (number a b c)) \\
~~"   . \\
~~~ a, b  c       ( ), \\
~~~   b{\Xcircumflex}2-4*a*c. \\
~~~  a*x{\Xcircumflex}2+b*x+c=0  , multiple, \\
~~~      ,      \\
~~~,   ." \\
~~(- (* b b) (* 4 a c))) \\
~~~\EV\ discriminant \\
~~~\textrm{} (discriminant 1 2/3 -2) \EV\ 76/9
\end{lisp}

   \cdf{defun}   , , 
    .
      .
  ,      (
~\ref{SPECIAL-FORM-TABLE})  .
\end{defmac}

\subsection{    }

      
\cdf{defvar}  \cdf{defparameter}. 
      \cdf{defconstant}. 

\begin{defmac}
defvar name [initial-value [documentation]] \\
defparameter name initial-value [documentation] \\
defconstant name initial-value [documentation]

\cdf{defvar}       
.
\begin{lisp}
(defvar \emph{variable})
\end{lisp}
  ,   \emph{variable}  
(\cdf{special}) ( \cdf{proclaim}),     
,   .

 \emph{initial-value}   , \cdf{defvar}   
 \emph{variable}. 
 \emph{initial-value}        ,
\cdf{defvar}   .

     ,
\begin{lisp}
(defvar \emph{variable} \emph{initial-value})
\end{lisp}
  \emph{variable},      ,
    \emph{initial-value}. 
\emph{initial-value}  ,     . 
,   \emph{initial-value}  -
, , ,    .

      , 
    . 
,     . FIXME.

\cdf{defvar}      , 
 ,    \cd{special}  
         
 .
\begin{lisp}
(defvar *visible-windows* 0 \\
~~"    ")
\end{lisp}

\cdf{defparameter}  \cdf{defvar},  \cdf{defparameter} 
  \emph{initial-value}, ,    
 .     ,  
\cdf{defvar}   ,  ,
  \cdf{defparameter}    , 
,     (    ), 
  .   \cdf{defparameter}  ,
    ,  ,    
  ,      
.

\cdf{defconstant}   \cdf{defparameter},     ,
,    \emph{name}   
 ,      
. ,         
         ,  
  ,   <<>>   \cdf{eql}
- . ,    
,      ,   
 .

       \cdf{defconstant} 
 ,    (   , 
     ).

     \cdf{defconstant},
       
 .     , ,
\cdf{t}  \cdf{most-positive-fixnum}.
        
 .

    ,    . 
   ,      
\cdf{variable},   \cdf{documentation}.

\emph{documentation-string}
     ,   \cdf{defvar},
\cdf{defparameter}  \cdf{defconstant}.

, 
\begin{lisp}
(defvar *avoid-registers* nil "Compilation control switch \#43")
\end{lisp}
, 
\begin{lisp}
(defvar *avoid-registers* nil \\*
~~(format nil "Compilation control switch \#{\Xtilde}D" \\*
~~~~~~~~~~(incf *compiler-switch-number*)))
\end{lisp}
,    \cdf{format}    .

  , 
\begin{lisp}
(defvar *avoid-registers* nil \\*
~~\#.(format nil "Compilation control switch \#{\Xtilde}D" \\*
~~~~~~~~~~~~(incf *compiler-switch-number*)))
\end{lisp}
    ,    \cdf{format}
      \cdf{read},   \cdf{defvar}
,    ,    
\cdf{format}.

        . ,
    ,    \emph{name}.
\end{defmac}

\subsection{  }

\begin{defspec}
eval-when ({situation}*) {form}*

  \cdf{eval-when}    \cdf{progn},   
  .   \emph{situation}  
 , \cd{:compile-toplevel}, \cd{:load-toplevel}  \cd{:execute}.

 \cd{:compile-toplevel}  \cd{:load-toplevel} ,  
     .  \cd{:execute}
        .

 \cdf{eval-when}        ,
  , \cdf{compile-file},     
.

           
 \cdf{read}.        ,
    <<  (not-compile-time
mode)>>.    ,   <<-
(compile-time-too mode)>>,       
.   \cdf{eval-when}    
 ,   ,   .

        , 
 :

\begin{itemize}

\item    ,    
  ,         
  (-  -, (compile-time-too  not-compile-time).

\item   \cdf{progn} ( \cdf{locally}),      
  ,         .

\item   \cdf{compiler-let}, \cdf{macrolet} 
  \cdf{symbol-macrolet},      
     ,   \cdf{progn}  
          .

\item   \cdf{eval-when},     
   :
  \begin{flushleft}
    \begin{tabular*}{\linewidth}{@{\extracolsep{\fill}}c@{}cccl@{}}
      LT  &CT    &EX  &CTTM & \\ \hlinesp
        &    &--  & --  &        - \\
        &   &  &   &        - \\
        &   &--  &  &        - \\
        &   & & --  &        - \\
       &    &--  & --  &      \\
       &   &  &   &      \\
       &   &--  &  &       \\
       &   &  & -- &      
    \end{tabular*}
  \end{flushleft}
      LT    \cd{:load-toplevel} 
      \cdf{eval-when}.
  CT    \cd{:compile-toplevel}  EX 
  \cd{:execute}.  CTTM     \cdf{eval-when}
    -.  << >>  
    ,   \cdf{progn}   
   ,  << >>    
  ,   \cdf{progn}   
       ,    \cdf{eval-when}.

\item   ,   ,    
   .    -,  
         . 
    -,    
   ( ~\ref{COMPILER-SECTION}).
         .
\end{itemize}

 ,       
,         ,   
      ,  
 .
,   (,  ,  ) ,
     ,  .

  \cdf{eval-when},       
  (    ,  \cdf{compile},  
 ,     ),   
\cd{:execute},      \cdf{progn}.  
,     \cdf{eval-when}   \cdf{nil}.

   , \emph{situation}   
\cdf{compile}, \cdf{load}  \cdf{eval}.
    \cdf{eval-when},   
\cd{:compile-toplevel}, \cd{:load-toplevel}  \cd{:execute} .
        \cdf{eval-when} 
 .

      :

\begin{itemize}

\item    ,    \cdf{eval-when}
          .

\item    \cd{eval}   , 
        \cd{eval}. ,  
  
  \begin{lisp}
    (defun foo () (eval-when (:execute) (print 'foo)))
  \end{lisp}
  ,
   \cdf{print}   ,     
  .

\item ,       
  ,     ,   
     .
           
  .
  
  \begin{lisp}
    (defmacro foo () \\*
    ~~(really-foo)~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;\textrm{}\\*
    ~~{\Xbq}(really-foo)) \\
    \\
    (defmacro foo () \\*
    ~~{\Xbq}(eval-when (:compile-toplevel \\*
    ~~~~~~~~~~~~~~~:load-toplevel :execute)~~~~~;\textrm{} \\*
    ~~~~(really-foo)))
  \end{lisp}
      ,      
          .

\item     \cdf{eval-when}
   ,    <<->>  
   (  \cdf{eval-when}      )
  \begin{lisp}
    (let ((x 3)) \\*
    ~~(eval-when (:compile-toplevel :load-toplevel :execute) \\*
    ~~~~(print x)))
  \end{lisp}
   3    (   )    
     .  \cdf{defun}  \cdf{defmacro} 
      \cdf{eval-when}    
   .
  ,     \cdf{defun},  :
  \begin{lisp}
    (defun bar (x) (defun foo () (+ x 3)))
  \end{lisp}
  
  \begin{lisp}
    (progn (eval-when (:compile-toplevel) \\*
    ~~~~~~~~~(compiler::notice-function 'bar '(x))) \\*
    ~~~~~~~(eval-when (:load-toplevel :execute) \\*
    ~~~~~~~~~(setf (symbol-function 'bar) \\*
    ~~~~~~~~~~~~~~~\#'(lambda (x) \\*
    ~~~~~~~~~~~~~~~~~~~(progn (eval-when (:compile-toplevel)  \\*
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~(compiler::notice-function 'foo \\*
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'())) \\*
    ~~~~~~~~~~~~~~~~~~~~~~~~~~(eval-when (:load-toplevel :execute) \\*
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~(setf (symbol-function 'foo) \\*
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\#'(lambda () (+ x 3)))))))))
  \end{lisp}
        ,   
  \begin{lisp}
    (progn (eval-when (:compile-toplevel) \\*
    ~~~~~~~~~(compiler::notice-function 'bar '(x))) \\*
    ~~~~~~~(eval-when (:load-toplevel :execute) \\*
    ~~~~~~~~~(setf (symbol-function 'bar) \\*
    ~~~~~~~~~~~~~~~\#'(lambda (x) \\*
    ~~~~~~~~~~~~~~~~~~~(progn (eval-when (:load-toplevel :execute) \\*
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~(setf (symbol-function 'foo) \\*
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\#'(lambda () (+ x 3)))))))))
  \end{lisp}

\end{itemize}

   .
\begin{lisp} 
  (let ((x 1)) \\*
  ~~(eval-when (:execute :load-toplevel :compile-toplevel) \\*
  ~~~~(setf (symbol-function 'foo1) \#'(lambda () x))))
\end{lisp}
\cdf{eval-when}        , 
       \cd{:execute}.   
    .    
 \cd{(symbol-function 'foo1)}    \cd{1}  
 ( \cdf{let}   )     (
 \cdf{let}   -  ,    
). 
\begin{lisp}
  (eval-when (:execute :load-toplevel :compile-toplevel) \\*
  ~~(let ((x 2)) \\*
  ~~~~(eval-when (:execute :load-toplevel :compile-toplevel) \\*
  ~~~~~~(setf (symbol-function 'foo2) \#'(lambda () x)))))
\end{lisp}
         , 
    ,        .

\begin{lisp}
  (eval-when (:execute :load-toplevel :compile-toplevel) \\*
  ~~(setf (symbol-function 'foo3) \#'(lambda () 3)))
\end{lisp}
         , 
    ,        .

\begin{lisp}
  (eval-when (:compile-toplevel) \\*
  ~~(eval-when (:compile-toplevel)  \\*
  ~~~~(print 'foo4)))
\end{lisp}
    ,    \cdf{nil}.

\begin{lisp}
  (eval-when (:compile-toplevel)  \\*
  ~~(eval-when (:execute) \\*
  ~~~~(print 'foo5)))
\end{lisp}
         ,
\cd{foo5}     .       
,       .    
,         .

\begin{lisp}
  (eval-when (:execute :load-toplevel) \\*
  ~~(eval-when (:compile-toplevel) \\*
  ~~~~(print 'foo6)))
\end{lisp}
         ,
\cd{foo6}     .      
,       .   
,          .
\end{defspec}

\fi